'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

"use strict";
global.__VERSION__ = '0.7.0';
global.deref = function (ref) {
    return Game.getObjectById(ref) || Game.flags[ref] || Game.creeps[ref] || Game.spawns[ref] || null;
};
global.derefRoomPosition = function (protoPos) {
    return new RoomPosition(protoPos.x, protoPos.y, protoPos.roomName);
};
global.NO_ACTION = 1;
global.PERMACACHE = {};

"use strict";
const _marketDeal = Game.market.deal;
Game.market.deal = function (orderId, amount, targetRoomName) {
    const response = _marketDeal(orderId, amount, targetRoomName);
    if (response == OK) {
        if (targetRoomName && Game.rooms[targetRoomName] && Game.rooms[targetRoomName].terminal
            && Game.rooms[targetRoomName].terminal.my) {
            Game.rooms[targetRoomName].terminal._notReady = true;
        }
    }
    return response;
};

"use strict";
Object.defineProperty(Creep.prototype, 'boosts', {
    get() {
        if (!this._boosts) {
            this._boosts = _.compact(_.unique(_.map(this.body, bodyPart => bodyPart.boost)));
        }
        return this._boosts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'boostCounts', {
    get() {
        if (!this._boostCounts) {
            this._boostCounts = _.countBy(this.body, bodyPart => bodyPart.boost);
        }
        return this._boostCounts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'approxMoveSpeed', {
    get() {
        if (this._moveSpeed == undefined) {
            const movePower = _.sum(this.body, (part) => {
                if (part.type == MOVE && part.boost) {
                    return BOOSTS.move[part.boost].fatigue;
                }
                else {
                    return 0;
                }
            });
            const nonMoveParts = _.sum(this.body, (part) => part.type != MOVE ? 1 : 0);
            this._moveSpeed = Math.max(movePower / nonMoveParts, 1);
        }
        return this._moveSpeed;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'inRampart', {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART);
    },
    configurable: true,
});
PERMACACHE.bodypartCounts = PERMACACHE.bodypartCounts || {};
Object.defineProperty(Creep.prototype, 'bodypartCounts', {
    get() {
        if (PERMACACHE.bodypartCounts[this.id] === undefined) {
            PERMACACHE.bodypartCounts[this.id] = _.countBy(this.body, (part) => part.type);
            _.defaults(PERMACACHE.bodypartCounts[this.id], {
                [MOVE]: 0,
                [WORK]: 0,
                [CARRY]: 0,
                [ATTACK]: 0,
                [RANGED_ATTACK]: 0,
                [TOUGH]: 0,
                [HEAL]: 0,
                [CLAIM]: 0,
            });
        }
        return PERMACACHE.bodypartCounts[this.id];
    },
    configurable: true,
});
PERMACACHE.isPlayer = PERMACACHE.isPlayer || {};
Object.defineProperty(Creep.prototype, 'isPlayer', {
    get() {
        if (PERMACACHE.isPlayer[this.id] === undefined) {
            PERMACACHE.isPlayer[this.id] = this.owner.username != 'Invader' &&
                this.owner.username != 'Source Keeper' &&
                this.owner.username != 'Screeps';
        }
        return PERMACACHE.isPlayer[this.id];
    },
    configurable: true,
});

"use strict";
Object.defineProperty(PowerCreep.prototype, 'inRampart', {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART);
    },
    configurable: true,
});

function isStructure(obj) {
    return obj.structureType != undefined;
}
function isOwnedStructure(structure) {
    return structure.owner != undefined;
}
function isExtension(structure) {
    return structure.structureType == STRUCTURE_EXTENSION;
}
function isRampart(structure) {
    return structure.structureType == STRUCTURE_RAMPART;
}
function isRoad(structure) {
    return structure.structureType == STRUCTURE_ROAD;
}
function isSpawn(structure) {
    return structure.structureType == STRUCTURE_SPAWN;
}
function isLink(structure) {
    return structure.structureType == STRUCTURE_LINK;
}
function isWall(structure) {
    return structure.structureType == STRUCTURE_WALL;
}
function isStorage(structure) {
    return structure.structureType == STRUCTURE_STORAGE;
}
function isTower(structure) {
    return structure.structureType == STRUCTURE_TOWER;
}
function isObserver(structure) {
    return structure.structureType == STRUCTURE_OBSERVER;
}
function isPowerSpawn(structure) {
    return structure.structureType == STRUCTURE_POWER_SPAWN;
}
function isExtractor(structure) {
    return structure.structureType == STRUCTURE_EXTRACTOR;
}
function isLab(structure) {
    return structure.structureType == STRUCTURE_LAB;
}
function isTerminal(structure) {
    return structure.structureType == STRUCTURE_TERMINAL;
}
function isContainer(structure) {
    return structure.structureType == STRUCTURE_CONTAINER;
}
function isNuker(structure) {
    return structure.structureType == STRUCTURE_NUKER;
}
function isFactory(structure) {
    return structure.structureType == STRUCTURE_FACTORY;
}
function isSource(obj) {
    return obj.energy != undefined;
}
function isTombstone(obj) {
    return obj.deathTime != undefined;
}
function isRuin(obj) {
    return obj.destroyTime != undefined;
}
function isResource(obj) {
    return obj.amount != undefined;
}
function isConstructionSite(obj) {
    const site = obj;
    return site.progress !== undefined && site.structureType !== undefined;
}
function isMineral(obj) {
    return obj.mineralType !== undefined;
}
function isDeposit(obj) {
    return obj.depositType !== undefined;
}
function _HasRoomPosition(obj) {
    return obj.pos != undefined;
}
function isDirective(thing) {
    return thing.isDirective || false;
}
function isCreep(obj) {
    return obj.fatigue != undefined;
}
function isPowerCreep(obj) {
    return obj.powers != undefined;
}
function isAnyZerg(thing) {
    return thing.isAnyZerg || false;
}
function isStandardZerg(creep) {
    return creep.isStandardZerg || false;
}
function isPowerZerg(creep) {
    return creep.isPowerZerg || false;
}
function isCombatZerg(zerg) {
    return zerg.isCombatZerg || false;
}
function isNeuralZerg(zerg) {
    return zerg.isNeuralZerg || false;
}

function roomObjectType(obj) {
    let type;
    if (isRuin(obj))
        type = "ruin";
    else if (isTombstone(obj))
        type = "tombstone";
    else if (isResource(obj))
        type = "resource";
    else if (isStructure(obj))
        type = obj.structureType;
    else if (isSource(obj))
        type = "source";
    else if (isMineral(obj))
        type = `mineral of ${obj.mineralType}`;
    else if (isDeposit(obj))
        type = `deposit of ${obj.depositType}`;
    else if (isConstructionSite(obj))
        type = `${obj.structureType} (site)`;
    else if (obj instanceof PowerCreep) {
        type = `powercreep ${obj.name} (owned by ${obj.owner.username})`;
    }
    else if (isCreep(obj)) {
        type = `creep ${obj.name} (owned by ${obj.owner.username})`;
    }
    else {
        type = "unknown";
    }
    return type;
}
Object.defineProperty(RoomObject.prototype, "print", {
    get() {
        return `${roomObjectType(this)} ${this.pos.print}`;
    },
    configurable: true,
});
Object.defineProperty(RoomObject.prototype, 'ref', {
    get: function () {
        return this.id || this.name || '';
    },
    configurable: true,
});
Object.defineProperty(RoomObject.prototype, 'targetedBy', {
    get: function () {
        return Overmind.cache.targets[this.ref] || [];
    },
    configurable: true,
});
RoomObject.prototype.serialize = function () {
    const pos = {
        x: this.pos.x,
        y: this.pos.y,
        roomName: this.pos.roomName
    };
    return {
        pos: pos,
        ref: this.ref
    };
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};

function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};

function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;

}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while (r = env.stack.pop()) {
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                else s |= 1;
            }
            catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
        });
    }
    return path;
}

var tslib_es6 = {
    __extends: __extends,
    __assign: __assign,
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __esDecorate: __esDecorate,
    __runInitializers: __runInitializers,
    __propKey: __propKey,
    __setFunctionName: __setFunctionName,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet,
    __classPrivateFieldIn: __classPrivateFieldIn,
    __addDisposableResource: __addDisposableResource,
    __disposeResources: __disposeResources,
    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,
};

const bullet = '\u2023 ';
const rightArrow = '\u27f6';
const leftArrow = '\u27f5';
const leftAngleQuote = '\u00ab';
const rightAngleQuote = '\u00bb';
const alignedNewline = '\n' + ' '.repeat('INFO    '.length + Game.time.toString().length + ' '.length);

function getAllRooms() {
    if (!Game._allRooms) {
        Game._allRooms = _.values(Game.rooms);
    }
    return Game._allRooms;
}
function getOwnedRooms() {
    if (!Game._ownedRooms) {
        Game._ownedRooms = _.filter(getAllRooms(), room => room.my);
    }
    return Game._ownedRooms;
}
function canClaimAnotherRoom() {
    return getOwnedRooms().length < Game.gcl.level;
}
function printRoomName(roomName, aligned = false) {
    if (aligned) {
        const msg = '<a href="#!/room/' + Game.shard.name + '/' + roomName + '">' + roomName + '</a>';
        const extraSpaces = 'E12S34'.length - roomName.length;
        return msg + ' '.repeat(extraSpaces);
    }
    else {
        return '<a href="#!/room/' + Game.shard.name + '/' + roomName + '">' + roomName + '</a>';
    }
}
function stringToColorHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash += (i * 123) ^ (hash >> 2);
        hash = hash & hash;
    }
    let color = '#';
    for (let i = 0; i < 3; i++) {
        const value = (hash >> (i * 8)) & 0xff;
        color += value.toString(16).padStart(2, '0');
    }
    return color;
}
function color(str, color) {
    return `<font color='${color}'>${str}</font>`;
}
function componentToHex(n) {
    const hex = n.toString(16);
    return hex.length == 1 ? '0' + hex : hex;
}
function rgbToHex(r, g, b) {
    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function mod(n, m) {
    return ((n % m) + m) % m;
}
function minMax(value, min, max) {
    return Math.max(Math.min(value, max), min);
}
function hasMinerals(store) {
    for (const resourceType in store) {
        if (resourceType != RESOURCE_ENERGY && (store[resourceType] || 0) > 0) {
            return true;
        }
    }
    return false;
}
function hasContents(store) {
    for (const resourceType in store) {
        if ((store[resourceType] || 0) > 0) {
            return true;
        }
    }
    return false;
}
function getMyUsername() {
    for (const i in Game.rooms) {
        const room = Game.rooms[i];
        if (room.controller && room.controller.owner && room.controller.my) {
            return room.controller.owner.username;
        }
    }
    for (const i in Game.creeps) {
        const creep = Game.creeps[i];
        if (creep.owner) {
            return creep.owner.username;
        }
    }
    console.log('ERROR: Could not determine username. You can set this manually in src/settings/settings_user');
    return 'ERROR: Could not determine username.';
}
function isAlly(username) {
    return (Memory.settings.allies || []).includes(username);
}
function hasJustSpawned() {
    return _.keys(Overmind.colonies).length == 1 && _.keys(Game.creeps).length == 0 && _.keys(Game.spawns).length == 1;
}
function onPublicServer() {
    return Game.shard.name.includes('shard');
}
function onBotArena() {
    return Game.shard.name.toLowerCase() == 'botarena';
}
function bulleted(text, aligned = true, startWithNewLine = true) {
    if (text.length == 0) {
        return '';
    }
    const prefix = (startWithNewLine ? (aligned ? alignedNewline : '\n') : '') + bullet;
    if (aligned) {
        return prefix + text.join(alignedNewline + bullet);
    }
    else {
        return prefix + text.join('\n' + bullet);
    }
}
function toColumns(obj, opts = {}) {
    _.defaults(opts, {
        padChar: ' ',
        justify: false
    });
    const ret = [];
    const keyPadding = _.max(_.map(_.keys(obj), str => str.length)) + 1;
    const valPadding = _.max(_.mapValues(obj, str => str.length));
    for (const key in obj) {
        if (opts.justify) {
            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key].padLeft(valPadding, opts.padChar));
        }
        else {
            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key]);
        }
    }
    return ret;
}
function mergeSum(objects) {
    const ret = {};
    for (const object of objects) {
        for (const key in object) {
            const amount = object[key] || 0;
            if (!ret[key]) {
                ret[key] = 0;
            }
            ret[key] += amount;
        }
    }
    return ret;
}
const CHARCODE_A = 65;
function posFromReadableName(str) {
    if (!str)
        return;
    const posName = _.first(str.match(/(E|W)\d+(N|S)\d+:\d+:\d+/g) || []);
    if (posName) {
        const [roomName, x, y] = posName.split(':');
        return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
    }
}
function equalXYR(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y && pos1.roomName == pos2.roomName;
}
function averageBy(objects, iteratee) {
    if (objects.length == 0) {
        return undefined;
    }
    else {
        return _.sum(objects, obj => iteratee(obj)) / objects.length;
    }
}
function minBy(objects, iteratee) {
    let minObj;
    let minVal = Infinity;
    let val;
    for (const i in objects) {
        val = iteratee(objects[i]);
        if (val !== false && val < minVal) {
            minVal = val;
            minObj = objects[i];
        }
    }
    return minObj;
}
function maxBy(objects, iteratee) {
    let maxObj;
    let maxVal = -Infinity;
    let val;
    for (const i in objects) {
        val = iteratee(objects[i]);
        if (val !== false && val > maxVal) {
            maxVal = val;
            maxObj = objects[i];
        }
    }
    return maxObj;
}
function logHeapStats() {
    if (typeof Game.cpu.getHeapStatistics === 'function') {
        const heapStats = Game.cpu.getHeapStatistics();
        const heapPercent = Math.round(100 * (heapStats.total_heap_size + heapStats.externally_allocated_size)
            / heapStats.heap_size_limit);
        const heapSize = Math.round((heapStats.total_heap_size) / 1048576);
        const externalHeapSize = Math.round((heapStats.externally_allocated_size) / 1048576);
        const heapLimit = Math.round(heapStats.heap_size_limit / 1048576);
        console.log(`Heap usage: ${heapSize} MB + ${externalHeapSize} MB of ${heapLimit} MB (${heapPercent}%).`);
    }
}
function isIVM() {
    return typeof Game.cpu.getHeapStatistics === 'function';
}
function getCacheExpiration(timeout, offset = 5) {
    return Game.time + timeout + Math.round((Math.random() * offset * 2) - offset);
}
const hexChars = '0123456789abcdef';
function randomHex(length) {
    let result = '';
    for (let i = 0; i < length; i++) {
        result += hexChars[Math.floor(Math.random() * hexChars.length)];
    }
    return result;
}
function ema(current, avg, window, zeroThreshold = 1e-9) {
    let newAvg = (current + (avg || 0) * (window - 1)) / window;
    if (zeroThreshold && Math.abs(newAvg) < zeroThreshold) {
        newAvg = 0;
    }
    return newAvg;
}
function irregularEma(current, avg, dt, window) {
    return (current * dt + avg * (window - dt)) / window;
}
function clone2DArray(a) {
    return _.map(a, e => e.slice());
}
function rotateMatrix(matrix) {
    matrix.reverse();
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < i; j++) {
            const temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
function rotatedMatrix(matrix, clockwiseTurns) {
    const mat = clone2DArray(matrix);
    for (let i = 0; i < clockwiseTurns; i++) {
        rotateMatrix(mat);
    }
    return mat;
}
function cyclicListPermutation(list, offset) {
    return list.slice(offset).concat(list.slice(0, offset));
}

const MY_USERNAME = getMyUsername();
var user = getMyUsername();
const USE_SCREEPS_PROFILER = false;
var ALLIES;
const PROFILER_COLONY_LIMIT = Math.ceil(Game.gcl.level / 2);
const PROFILER_INCLUDE_COLONIES = ['W7N7', 'W3N7', 'W7N4'];
const USE_TRY_CATCH = true;
const SUPPRESS_INVALID_DIRECTIVE_ALERTS = false;
const OVERMIND_SMALL_CAPS = 'NOVAMIND';
const DEFAULT_OVERMIND_SIGNATURE = leftAngleQuote + OVERMIND_SMALL_CAPS + rightAngleQuote;
global.__DEFAULT_OVERMIND_SIGNATURE__ = DEFAULT_OVERMIND_SIGNATURE;
const DEFAULT_OPERATION_MODE = 'automatic';
const MAX_OWNED_ROOMS = Infinity;
const SHARD3_MAX_OWNED_ROOMS = 2;
const RESERVE_CREDITS = onPublicServer() ? (Game.gcl.level >= 10 ? 1e6 : 1e5) : 1000;
const NEW_OVERMIND_INTERVAL = onPublicServer() ? 20 : 5;
const GUI_SCALE = 1.0;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

'use strict';

// This is a modified version of screeps-profiler taken from https://github.com/samogot/screeps-profiler


let usedOnStart = 0;
let enabled = false;
let depth = 0;
let parentFn = '(tick)';

function AlreadyWrappedError() {
    this.name = 'AlreadyWrappedError';
    this.message = 'Error attempted to double wrap a function.';
    this.stack = ((new Error())).stack;
}

function setupProfiler() {
    depth = 0; // reset depth, this needs to be done each tick.
    parentFn = '(tick)';
    Game.profiler = {
        stream(duration, filter) {
            setupMemory('stream', duration || 10, filter);
        },
        email(duration, filter) {
            setupMemory('email', duration || 100, filter);
        },
        profile(duration, filter) {
            setupMemory('profile', duration || 100, filter);
        },
        background(filter) {
            setupMemory('background', false, filter);
        },
        callgrind() {
            const id = `id${Math.random()}`;
            /* eslint-disable */
            const download = `
<script>
  var element = document.getElementById('${id}');
  if (!element) {
    element = document.createElement('a');
    element.setAttribute('id', '${id}');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,${encodeURIComponent(Profiler.callgrind())}');
    element.setAttribute('download', 'callgrind.out.${Game.time}');
  
    element.style.display = 'none';
    document.body.appendChild(element);
  
    element.click();
  }
</script>
      `;
            /* eslint-enable */
            console.log(download.split('\n').map((s) => s.trim()).join(''));
        },
        restart() {
            if (Profiler.isProfiling()) {
                const filter = Memory.screepsProfiler.filter;
                let duration = false;
                if (!!Memory.screepsProfiler.disableTick) {
                    // Calculate the original duration, profile is enabled on the tick after the first call,
                    // so add 1.
                    duration = Memory.screepsProfiler.disableTick - Memory.screepsProfiler.enabledTick + 1;
                }
                const type = Memory.screepsProfiler.type;
                setupMemory(type, duration, filter);
            }
        },
        reset : resetMemory,
        output: Profiler.output,
    };

    overloadCPUCalc();
}

function setupMemory(profileType, duration, filter) {
    resetMemory();
    const disableTick = Number.isInteger(duration) ? Game.time + duration : false;
    if (!Memory.screepsProfiler) {
        Memory.screepsProfiler = {
            map        : {},
            totalTime  : 0,
            enabledTick: Game.time + 1,
            disableTick,
            type       : profileType,
            filter,
        };
    }
}

function resetMemory() {
    Memory.screepsProfiler = null;
}

function overloadCPUCalc() {
    if (Game.rooms.sim) {
        usedOnStart = 0; // This needs to be reset, but only in the sim.
        Game.cpu.getUsed = function getUsed() {
            return performance.now() - usedOnStart;
        };
    }
}

function getFilter() {
    return Memory.screepsProfiler.filter;
}

const functionBlackList = [
    'getUsed', // Let's avoid wrapping this... may lead to recursion issues and should be inexpensive.
    'constructor', // es6 class constructors need to be called with `new`
];

const commonProperties = ['length', 'name', 'arguments', 'caller', 'prototype'];

function wrapFunction(name, originalFunction) {
    if (originalFunction.profilerWrapped) {
        throw new AlreadyWrappedError();
    }

    function wrappedFunction() {
        if (Profiler.isProfiling()) {
            const nameMatchesFilter = name === getFilter();
            const start = Game.cpu.getUsed();
            if (nameMatchesFilter) {
                depth++;
            }
            const curParent = parentFn;
            parentFn = name;
            let result;
            if (this && this.constructor === wrappedFunction) {
                // eslint-disable-next-line new-cap
                result = new originalFunction(...arguments);
            } else {
                result = originalFunction.apply(this, arguments);
            }
            parentFn = curParent;
            if (depth > 0 || !getFilter()) {
                const end = Game.cpu.getUsed();
                Profiler.record(name, end - start, parentFn);
            }
            if (nameMatchesFilter) {
                depth--;
            }
            return result;
        }

        if (this && this.constructor === wrappedFunction) {
            // eslint-disable-next-line new-cap
            return new originalFunction(...arguments);
        }
        return originalFunction.apply(this, arguments);
    }

    wrappedFunction.profilerWrapped = true;
    wrappedFunction.toString = () =>
        `// screeps-profiler wrapped function:\n${originalFunction.toString()}`;

    Object.getOwnPropertyNames(originalFunction).forEach(property => {
        if (!commonProperties.includes(property)) {
            wrappedFunction[property] = originalFunction[property];
        }
    });

    return wrappedFunction;
}

function hookUpPrototypes() {
    Profiler.prototypes.forEach(proto => {
        profileObjectFunctions(proto.val, proto.name);
    });
}

function profileObjectFunctions(object, label) {
    if (object.prototype) {
        profileObjectFunctions(object.prototype, label);
    }
    const objectToWrap = object;

    Object.getOwnPropertyNames(objectToWrap).forEach(functionName => {
        const extendedLabel = `${label}.${functionName}`;

        const isBlackListed = functionBlackList.indexOf(functionName) !== -1;
        if (isBlackListed) {
            return;
        }

        const descriptor = Object.getOwnPropertyDescriptor(objectToWrap, functionName);
        if (!descriptor) {
            return;
        }

        const hasAccessor = descriptor.get || descriptor.set;
        if (hasAccessor) {
            const configurable = descriptor.configurable;
            if (!configurable) {
                return;
            }

            const profileDescriptor = {};

            if (descriptor.get) {
                const extendedLabelGet = `${extendedLabel}:get`;
                profileDescriptor.get = profileFunction(descriptor.get, extendedLabelGet);
            }

            if (descriptor.set) {
                const extendedLabelSet = `${extendedLabel}:set`;
                profileDescriptor.set = profileFunction(descriptor.set, extendedLabelSet);
            }

            Object.defineProperty(objectToWrap, functionName, profileDescriptor);
            return;
        }

        const isFunction = typeof descriptor.value === 'function';
        if (!isFunction || !descriptor.writable) {
            return;
        }
        const originalFunction = objectToWrap[functionName];
        objectToWrap[functionName] = profileFunction(originalFunction, extendedLabel);
    });

    return objectToWrap;
}

function profileFunction(fn, functionName) {
    const fnName = functionName || fn.name;
    if (!fnName) {
        console.log('Couldn\'t find a function name for - ', fn);
        console.log('Will not profile this function.');
        return fn;
    }

    return wrapFunction(fnName, fn);
}

const Profiler = {
    printProfile() {
        console.log(Profiler.output());
    },

    emailProfile() {
        Game.notify(Profiler.output(1000));
    },

    callgrind() {
        setupMemory('callgrind', duration || 100, filter);
    },

    downloadCallgrind() {
		const id = `id${Math.random()}`;
		/* eslint-disable */
		const download = `
<script>
var element = document.getElementById('${id}');
if (!element) {
element = document.createElement('a');
element.setAttribute('id', '${id}');
element.setAttribute('href', 'data:text/plain;charset=utf-8,${encodeURIComponent(Profiler.callgrind())}');
element.setAttribute('download', 'callgrind.out.${Game.time}');

element.style.display = 'none';
document.body.appendChild(element);

element.click();
}
</script>
  `;
		/* eslint-enable */
		console.log(download.split('\n').map((s) => s.trim()).join(''));
	},

    output(passedOutputLengthLimit) {
        const outputLengthLimit = passedOutputLengthLimit || 1000;
        if (!Memory.screepsProfiler || !Memory.screepsProfiler.enabledTick) {
            return 'Profiler not active.';
        }

        const endTick = Math.min(Memory.screepsProfiler.disableTick || Game.time, Game.time);
        const startTick = Memory.screepsProfiler.enabledTick;
        const elapsedTicks = endTick - startTick + 1;
        const header = 'calls\t\ttime\t\tavg\t\tfunction';
        const footer = [
            `Ticks: ${elapsedTicks}`,
            `Total: ${Memory.screepsProfiler.totalTime.toFixed(2)}`,
            `Avg: ${(Memory.screepsProfiler.totalTime / elapsedTicks).toFixed(2)}`,
        ].join('\t');

        const lines = [header];
        let currentLength = header.length + 1 + footer.length;
        const allLines = Profiler.lines();
        let done = false;
        while (!done && allLines.length) {
            const line = allLines.shift();
            // each line added adds the line length plus a new line character.
            if (currentLength + line.length + 1 < outputLengthLimit) {
                lines.push(line);
                currentLength += line.length + 1;
            } else {
                done = true;
            }
        }
        lines.push(footer);
        return lines.join('\n');
    },

    lines() {
        const stats = Object.keys(Memory.screepsProfiler.map).map(functionName => {
            const functionCalls = Memory.screepsProfiler.map[functionName];
            return {
                name       : functionName,
                calls      : functionCalls.calls,
                totalTime  : functionCalls.time,
                averageTime: functionCalls.time / functionCalls.calls,
            };
        }).sort((val1, val2) => {
            return val2.totalTime - val1.totalTime;
        });

        const lines = stats.map(data => {
            return [
                data.calls,
                data.totalTime.toFixed(1),
                data.averageTime.toFixed(3),
                data.name,
            ].join('\t\t');
        });

        return lines;
    },

    prototypes: [
        {name: 'Game', val: commonjsGlobal.Game},
        {name: 'Map', val: commonjsGlobal.Game.map},
        {name: 'Market', val: commonjsGlobal.Game.market},
        {name: 'PathFinder', val: commonjsGlobal.PathFinder},
        {name: 'RawMemory', val: commonjsGlobal.RawMemory},
        {name: 'ConstructionSite', val: commonjsGlobal.ConstructionSite},
        {name: 'Creep', val: commonjsGlobal.Creep},
        {name: 'Flag', val: commonjsGlobal.Flag},
        {name: 'Mineral', val: commonjsGlobal.Mineral},
        {name: 'Nuke', val: commonjsGlobal.Nuke},
        {name: 'OwnedStructure', val: commonjsGlobal.OwnedStructure},
        {name: 'CostMatrix', val: commonjsGlobal.PathFinder.CostMatrix},
        {name: 'Resource', val: commonjsGlobal.Resource},
        {name: 'Room', val: commonjsGlobal.Room},
        {name: 'RoomObject', val: commonjsGlobal.RoomObject},
        {name: 'RoomPosition', val: commonjsGlobal.RoomPosition},
        {name: 'RoomVisual', val: commonjsGlobal.RoomVisual},
        {name: 'Source', val: commonjsGlobal.Source},
        {name: 'Structure', val: commonjsGlobal.Structure},
        {name: 'StructureContainer', val: commonjsGlobal.StructureContainer},
        {name: 'StructureController', val: commonjsGlobal.StructureController},
        {name: 'StructureExtension', val: commonjsGlobal.StructureExtension},
        {name: 'StructureExtractor', val: commonjsGlobal.StructureExtractor},
        {name: 'StructureKeeperLair', val: commonjsGlobal.StructureKeeperLair},
        {name: 'StructureLab', val: commonjsGlobal.StructureLab},
        {name: 'StructureLink', val: commonjsGlobal.StructureLink},
        {name: 'StructureNuker', val: commonjsGlobal.StructureNuker},
        {name: 'StructureObserver', val: commonjsGlobal.StructureObserver},
        {name: 'StructurePowerBank', val: commonjsGlobal.StructurePowerBank},
        {name: 'StructurePowerSpawn', val: commonjsGlobal.StructurePowerSpawn},
        {name: 'StructurePortal', val: commonjsGlobal.StructurePortal},
        {name: 'StructureRampart', val: commonjsGlobal.StructureRampart},
        {name: 'StructureRoad', val: commonjsGlobal.StructureRoad},
        {name: 'StructureSpawn', val: commonjsGlobal.StructureSpawn},
        {name: 'StructureStorage', val: commonjsGlobal.StructureStorage},
        {name: 'StructureTerminal', val: commonjsGlobal.StructureTerminal},
        {name: 'StructureTower', val: commonjsGlobal.StructureTower},
        {name: 'StructureWall', val: commonjsGlobal.StructureWall},
    ],

    checkMapItem(functionName, map = Memory.screepsProfiler.map) {
        if (!map[functionName]) {
            // eslint-disable-next-line no-param-reassign
            map[functionName] = {
                time : 0,
                calls: 0,
                subs : {},
            };
        }
    },

    record(functionName, time, parent) {
        this.checkMapItem(functionName);
        Memory.screepsProfiler.map[functionName].calls++;
        Memory.screepsProfiler.map[functionName].time += time;
        if (parent) {
            this.checkMapItem(parent);
            this.checkMapItem(functionName, Memory.screepsProfiler.map[parent].subs);
            Memory.screepsProfiler.map[parent].subs[functionName].calls++;
            Memory.screepsProfiler.map[parent].subs[functionName].time += time;
        }
    },

    endTick() {
        if (Game.time >= Memory.screepsProfiler.enabledTick) {
            const cpuUsed = Game.cpu.getUsed();
            Memory.screepsProfiler.totalTime += cpuUsed;
            Profiler.report();
        }
    },

    report() {
        if (Profiler.shouldPrint()) {
            Profiler.printProfile();
        } else if (Profiler.shouldEmail()) {
            Profiler.emailProfile();
        } else if (Profiler.shouldCallgrind()) {
            Profiler.downloadCallgrind();
        }
    },

    isProfiling() {
        if (!enabled || !Memory.screepsProfiler) {
            return false;
        }
        return !Memory.screepsProfiler.disableTick || Game.time <= Memory.screepsProfiler.disableTick;
    },

    type() {
        return Memory.screepsProfiler.type;
    },

    shouldPrint() {
        const streaming = Profiler.type() === 'stream';
        const profiling = Profiler.type() === 'profile';
        const onEndingTick = Memory.screepsProfiler.disableTick === Game.time;
        return streaming || (profiling && onEndingTick);
    },

    shouldEmail() {
        return Profiler.type() === 'email' && Memory.screepsProfiler.disableTick === Game.time;
    },

	shouldCallgrind() {
		return Profiler.type() === 'callgrind' && Memory.screepsProfiler.disableTick === Game.time;
	}
};

var screepsProfiler = {
    wrap(callback) {
        if (enabled) {
            setupProfiler();
        }

        if (Profiler.isProfiling()) {
            usedOnStart = Game.cpu.getUsed();

            // Commented lines are part of an on going experiment to keep the profiler
            // performant, and measure certain types of overhead.

            // var callbackStart = Game.cpu.getUsed();
            const returnVal = callback();
            // var callbackEnd = Game.cpu.getUsed();
            Profiler.endTick();
            // var end = Game.cpu.getUsed();

            // var profilerTime = (end - start) - (callbackEnd - callbackStart);
            // var callbackTime = callbackEnd - callbackStart;
            // var unaccounted = end - profilerTime - callbackTime;
            // console.log('total-', end, 'profiler-', profilerTime, 'callbacktime-',
            // callbackTime, 'start-', start, 'unaccounted', unaccounted);
            return returnVal;
        }

        return callback();
    },

    enable() {
        enabled = true;
        hookUpPrototypes();
    },

    output   : Profiler.output,
    callgrind: Profiler.callgrind,

    registerObject: profileObjectFunctions,
    registerFN    : profileFunction,
    registerClass : profileObjectFunctions,
};
var screepsProfiler_1 = screepsProfiler.wrap;
var screepsProfiler_2 = screepsProfiler.enable;
var screepsProfiler_3 = screepsProfiler.output;
var screepsProfiler_4 = screepsProfiler.callgrind;
var screepsProfiler_5 = screepsProfiler.registerObject;
var screepsProfiler_6 = screepsProfiler.registerFN;
var screepsProfiler_7 = screepsProfiler.registerClass;

function profile(target, key, _descriptor) {
    if (!USE_SCREEPS_PROFILER) {
        return;
    }
    if (key) {
        screepsProfiler.registerFN(target, key);
        return;
    }
    const ctor = target;
    if (!ctor.prototype) {
        return;
    }
    const className = ctor.name;
    screepsProfiler.registerClass(target, className);
}

var Cartographer_1;
const ROOMTYPE_SOURCEKEEPER = 'SK';
const ROOMTYPE_CORE = 'CORE';
const ROOMTYPE_CONTROLLER = 'CTRL';
const ROOMTYPE_ALLEY = 'ALLEY';
const ROOMTYPE_CROSSROAD = 'CROSSROAD';
PERMACACHE.cartographerRoomTypes = PERMACACHE.cartographerRoomTypes || {};
let Cartographer = Cartographer_1 = class Cartographer {
    static findRoomsInRange(roomName, depth) {
        return _.flatten(_.values(this.recursiveRoomSearch(roomName, depth)));
    }
    static findRoomsAtRange(roomName, depth) {
        return this.recursiveRoomSearch(roomName, depth)[depth];
    }
    static recursiveRoomSearch(roomName, maxDepth) {
        const visitedRooms = this._recursiveRoomSearch(roomName, 0, maxDepth, {});
        const roomDepths = {};
        for (const room in visitedRooms) {
            const depth = visitedRooms[room];
            if (!roomDepths[depth]) {
                roomDepths[depth] = [];
            }
            roomDepths[depth].push(room);
        }
        return roomDepths;
    }
    static _recursiveRoomSearch(roomName, depth, maxDepth, visited) {
        if (visited[roomName] == undefined) {
            visited[roomName] = depth;
        }
        else {
            visited[roomName] = Math.min(depth, visited[roomName]);
        }
        const neighbors = _.values(Game.map.describeExits(roomName));
        if (depth < maxDepth) {
            for (const neighbor of neighbors) {
                if (visited[neighbor] == undefined || depth + 1 < visited[neighbor]) {
                    this._recursiveRoomSearch(neighbor, depth + 1, maxDepth, visited);
                }
            }
        }
        return visited;
    }
    static roomType(roomName) {
        if (!PERMACACHE.cartographerRoomTypes[roomName]) {
            let roomType;
            const coords = Cartographer_1.getRoomCoordinates(roomName);
            if (coords.x % 10 === 0 && coords.y % 10 === 0) {
                roomType = ROOMTYPE_CROSSROAD;
            }
            else if (coords.x % 10 === 0 || coords.y % 10 === 0) {
                roomType = ROOMTYPE_ALLEY;
            }
            else if (coords.x % 10 != 0 && coords.x % 5 === 0 && coords.y % 10 != 0 && coords.y % 5 === 0) {
                roomType = ROOMTYPE_CORE;
            }
            else if (coords.x % 10 <= 6 && coords.x % 10 >= 4 && coords.y % 10 <= 6 && coords.y % 10 >= 4) {
                roomType = ROOMTYPE_SOURCEKEEPER;
            }
            else {
                roomType = ROOMTYPE_CONTROLLER;
            }
            PERMACACHE.cartographerRoomTypes[roomName] = roomType;
        }
        return PERMACACHE.cartographerRoomTypes[roomName];
    }
    static findRelativeRoomName(roomName, xDelta, yDelta) {
        const coords = this.getRoomCoordinates(roomName);
        let xDir = coords.xDir;
        if (xDir === 'W') {
            xDelta = -xDelta;
        }
        let yDir = coords.yDir;
        if (yDir === 'N') {
            yDelta = -yDelta;
        }
        let x = coords.x + xDelta;
        let y = coords.y + yDelta;
        if (x < 0) {
            x = Math.abs(x) - 1;
            xDir = this.oppositeDir(xDir);
        }
        if (y < 0) {
            y = Math.abs(y) - 1;
            yDir = this.oppositeDir(yDir);
        }
        return xDir + x + yDir + y;
    }
    static findRoomCoordDeltas(origin, otherRoom) {
        const originCoords = this.getRoomCoordinates(origin);
        const otherCoords = this.getRoomCoordinates(otherRoom);
        let xDelta = otherCoords.x - originCoords.x;
        if (originCoords.xDir !== otherCoords.xDir) {
            xDelta = otherCoords.x + originCoords.x + 1;
        }
        let yDelta = otherCoords.y - originCoords.y;
        if (originCoords.yDir !== otherCoords.yDir) {
            yDelta = otherCoords.y + originCoords.y + 1;
        }
        if (originCoords.xDir === 'W') {
            xDelta = -xDelta;
        }
        if (originCoords.yDir === 'N') {
            yDelta = -yDelta;
        }
        return { x: xDelta, y: yDelta };
    }
    static findRelativeRoomDir(origin, otherRoom) {
        const coordDeltas = this.findRoomCoordDeltas(origin, otherRoom);
        if (Math.abs(coordDeltas.x) == Math.abs(coordDeltas.y)) {
            if (coordDeltas.x > 0) {
                if (coordDeltas.y > 0) {
                    return 2;
                }
                else {
                    return 4;
                }
            }
            else if (coordDeltas.x < 0) {
                if (coordDeltas.y > 0) {
                    return 8;
                }
                else {
                    return 6;
                }
            }
            else {
                return 0;
            }
        }
        else {
            if (Math.abs(coordDeltas.x) > Math.abs(coordDeltas.y)) {
                if (coordDeltas.x > 0) {
                    return 3;
                }
                else {
                    return 7;
                }
            }
            else {
                if (coordDeltas.y > 0) {
                    return 1;
                }
                else {
                    return 5;
                }
            }
        }
    }
    static oppositeDir(dir) {
        switch (dir) {
            case 'W':
                return 'E';
            case 'E':
                return 'W';
            case 'N':
                return 'S';
            case 'S':
                return 'N';
            default:
                return 'error';
        }
    }
    static getRoomCoordinates(roomName) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = match[2];
        const yDir = match[3];
        const y = match[4];
        return {
            x: Number(x),
            y: Number(y),
            xDir: xDir,
            yDir: yDir,
        };
    }
};
Cartographer = Cartographer_1 = __decorate([
    profile
], Cartographer);
global.Cartographer = Cartographer;

Object.defineProperty(RoomPosition.prototype, 'print', {
    get() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.roomName + '">[' + this.roomName + ', ' + this.x +
            ', ' + this.y + ']</a>';
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'printPlain', {
    get() {
        return `[${this.roomName}, ${this.x}, ${this.y}]`;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'room', {
    get: function () {
        return Game.rooms[this.roomName];
    },
    configurable: true,
});
RoomPosition.prototype.toCoord = function () {
    return { x: this.x, y: this.y };
};
Object.defineProperty(RoomPosition.prototype, 'readableName', {
    get: function () {
        return this.roomName + ':' + this.x + ':' + this.y;
    },
    configurable: true,
});
RoomPosition.prototype.lookForStructure = function (structureType) {
    return _.find(this.lookFor(LOOK_STRUCTURES), s => s.structureType === structureType);
};
RoomPosition.prototype.getOffsetPos = function (dx, dy) {
    let roomName = this.roomName;
    let x = this.x + dx;
    if (x < 0 || x > 49) {
        const dxRoom = Math.floor(x / 50);
        x = mod(x, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, dxRoom, 0);
    }
    let y = this.y + dy;
    if (y < 0 || y > 49) {
        const dyRoom = Math.floor(y / 50);
        y = mod(y, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, 0, dyRoom);
    }
    return new RoomPosition(x, y, roomName);
};
Object.defineProperty(RoomPosition.prototype, 'isEdge', {
    get: function () {
        return this.x === 0 || this.x === 49 || this.y === 0 || this.y === 49;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'isVisible', {
    get: function () {
        return Game.rooms[this.roomName] != undefined;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'rangeToEdge', {
    get: function () {
        return _.min([this.x, 49 - this.x, this.y, 49 - this.y]);
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'roomCoords', {
    get: function () {
        const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.roomName);
        let x = parseInt(parsed[1], 10);
        let y = parseInt(parsed[2], 10);
        if (this.roomName.includes('W'))
            x = -x;
        if (this.roomName.includes('N'))
            y = -y;
        return { x: x, y: y };
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'neighbors', {
    get: function () {
        const adjPos = [];
        for (const dx of [-1, 0, 1]) {
            for (const dy of [-1, 0, 1]) {
                if (!(dx == 0 && dy == 0)) {
                    const x = this.x + dx;
                    const y = this.y + dy;
                    if (0 < x && x < 49 && 0 < y && y < 49) {
                        adjPos.push(new RoomPosition(x, y, this.roomName));
                    }
                }
            }
        }
        return adjPos;
    },
    configurable: true,
});
RoomPosition.prototype.inRangeToPos = function (pos, range) {
    return this.roomName === pos.roomName &&
        ((pos.x - this.x) < 0 ? (this.x - pos.x) : (pos.x - this.x)) <= range &&
        ((pos.y - this.y) < 0 ? (this.y - pos.y) : (pos.y - this.y)) <= range;
};
RoomPosition.prototype.inRangeToXY = function (x, y, range) {
    return ((x - this.x) < 0 ? (this.x - x) : (x - this.x)) <= range
        && ((y - this.y) < 0 ? (this.y - y) : (y - this.y)) <= range;
};
RoomPosition.prototype.getRangeToXY = function (x, y) {
    return Math.max((x - this.x) < 0 ? (this.x - x) : (x - this.x), ((y - this.y) < 0 ? (this.y - y) : (y - this.y)));
};
RoomPosition.prototype.getPositionsInRange = function (range, includeWalls = false, includeEdges = false) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.getPositionsAtRange = function (range, includeWalls = false, includeEdges = false) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            if (Math.max(Math.abs(dx), Math.abs(dy)) < range) {
                continue;
            }
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.isWalkable = function (ignoreCreeps = false) {
    if (Game.map.getRoomTerrain(this.roomName).get(this.x, this.y) == TERRAIN_MASK_WALL)
        return false;
    if (this.isVisible) {
        if (ignoreCreeps == false && this.lookFor(LOOK_CREEPS).length > 0)
            return false;
        if (_.filter(this.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable).length > 0)
            return false;
    }
    return true;
};
RoomPosition.prototype.availableNeighbors = function (ignoreCreeps = false) {
    return _.filter(this.neighbors, pos => pos.isWalkable(ignoreCreeps));
};
RoomPosition.prototype.getPositionAtDirection = function (direction, range = 1) {
    let dx = 0;
    let dy = 0;
    switch (direction) {
        case 1:
            dy = -range;
            break;
        case 2:
            dy = -range;
            dx = range;
            break;
        case 3:
            dx = range;
            break;
        case 4:
            dx = range;
            dy = range;
            break;
        case 5:
            dy = range;
            break;
        case 6:
            dy = range;
            dx = -range;
            break;
        case 7:
            dx = -range;
            break;
        case 8:
            dx = -range;
            dy = -range;
            break;
    }
    return this.getOffsetPos(dx, dy);
};
RoomPosition.prototype.getMultiRoomRangeTo = function (pos) {
    if (this.roomName == pos.roomName) {
        return this.getRangeTo(pos);
    }
    else {
        const from = this.roomCoords;
        const to = pos.roomCoords;
        const dx = Math.abs(50 * (to.x - from.x) + pos.x - this.x);
        const dy = Math.abs(50 * (to.y - from.y) + pos.y - this.y);
        return _.max([dx, dy]);
    }
};
RoomPosition.prototype.findClosestByLimitedRange = function (objects, rangeLimit, opts) {
    const objectsInRange = this.findInRange(objects, rangeLimit, opts);
    return this.findClosestByRange(objectsInRange, opts);
};
RoomPosition.prototype.findClosestByMultiRoomRange = function (objects) {
    return minBy(objects, (obj) => this.getMultiRoomRangeTo(obj.pos));
};
RoomPosition.prototype.findClosestByRangeThenPath = function (objects) {
    const distances = _.map(objects, obj => this.getRangeTo(obj));
    const minDistance = _.min(distances);
    if (minDistance > 4) {
        return this.findClosestByRange(objects);
    }
    else {
        const closestObjects = _.filter(objects, obj => this.getRangeTo(obj) == minDistance);
        return this.findClosestByPath(closestObjects);
    }
};

"use strict";
RoomVisual.prototype.infoBox = function (info, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: 'verdana',
        opacity: 0.7,
    });
    let fontstring = '';
    if (opts.textstyle) {
        fontstring = opts.textstyle + ' ';
    }
    fontstring += opts.textsize + ' ' + opts.textfont;
    let pointer = [
        [.9, -0.25],
        [.9, 0.25],
        [0.3, 0.0],
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    this.poly(pointer, {
        fill: undefined,
        stroke: opts.color,
        opacity: opts.opacity,
        strokeWidth: 0.0
    });
    const x0 = x + 0.9;
    const y0 = y - 0.8 * opts.textsize;
    this.line(x0, y0, x0, y0 + info.length * opts.textsize, {
        color: opts.color,
    });
    let dy = 0;
    for (const line of info) {
        this.text(line, x + 1, y + dy, {
            color: opts.color,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: 'left',
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.multitext = function (textLines, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: 'verdana',
        opacity: 0.7,
    });
    let fontstring = '';
    if (opts.textstyle) {
        fontstring = opts.textstyle + ' ';
    }
    fontstring += opts.textsize + ' ' + opts.textfont;
    let dy = 0;
    for (const line of textLines) {
        this.text(line, x, y + dy, {
            color: opts.color,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: 'left',
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.box = function (x, y, w, h, style) {
    return this.line(x, y, x + w, y, style)
        .line(x + w, y, x + w, y + h, style)
        .line(x + w, y + h, x, y + h, style)
        .line(x, y + h, x, y, style);
};
const colors = {
    gray: '#555555',
    light: '#AAAAAA',
    road: '#666',
    energy: '#FFE87B',
    power: '#F53547',
    dark: '#181818',
    outline: '#8FBB93',
    speechText: '#000000',
    speechBackground: '#aebcc4',
    infoBoxGood: '#09ff00',
    infoBoxBad: '#ff2600'
};
const speechSize = 0.5;
const speechFont = 'Times New Roman';
RoomVisual.prototype.structure = function (x, y, type, opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    switch (type) {
        case STRUCTURE_EXTENSION:
            this.circle(x, y, {
                radius: 0.5,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.35,
                fill: colors.gray,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: '#CCCCCC',
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_POWER_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: colors.power,
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_LINK: {
            let outer = [
                [0.0, -0.5],
                [0.4, 0.0],
                [0.0, 0.5],
                [-0.4, 0.0]
            ];
            let inner = [
                [0.0, -0.3],
                [0.25, 0.0],
                [0.0, 0.3],
                [-0.25, 0.0]
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.poly(inner, {
                fill: colors.gray,
                stroke: false,
                opacity: opts.opacity
            });
            break;
        }
        case STRUCTURE_TERMINAL: {
            let outer = [
                [0.0, -0.8],
                [0.55, -0.55],
                [0.8, 0.0],
                [0.55, 0.55],
                [0.0, 0.8],
                [-0.55, 0.55],
                [-0.8, 0.0],
                [-0.55, -0.55],
            ];
            let inner = [
                [0.0, -0.65],
                [0.45, -0.45],
                [0.65, 0.0],
                [0.45, 0.45],
                [0.0, 0.65],
                [-0.45, 0.45],
                [-0.65, 0.0],
                [-0.45, -0.45],
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.poly(inner, {
                fill: colors.light,
                stroke: false,
                opacity: opts.opacity
            });
            this.rect(x - 0.45, y - 0.45, 0.9, 0.9, {
                fill: colors.gray,
                stroke: colors.dark,
                strokeWidth: 0.1,
                opacity: opts.opacity
            });
            break;
        }
        case STRUCTURE_LAB:
            this.circle(x, y - 0.025, {
                radius: 0.55,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x, y - 0.025, {
                radius: 0.40,
                fill: colors.gray,
                opacity: opts.opacity
            });
            this.rect(x - 0.45, y + 0.3, 0.9, 0.25, {
                fill: colors.dark,
                stroke: false,
                opacity: opts.opacity
            });
            {
                let box = [
                    [-0.45, 0.3],
                    [-0.45, 0.55],
                    [0.45, 0.55],
                    [0.45, 0.3],
                ];
                box = relPoly(x, y, box);
                this.poly(box, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
            }
            break;
        case STRUCTURE_TOWER:
            this.circle(x, y, {
                radius: 0.6,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.rect(x - 0.4, y - 0.3, 0.8, 0.6, {
                fill: colors.gray,
                opacity: opts.opacity
            });
            this.rect(x - 0.2, y - 0.9, 0.4, 0.5, {
                fill: colors.light,
                stroke: colors.dark,
                strokeWidth: 0.07,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_ROAD:
            this.circle(x, y, {
                radius: 0.175,
                fill: colors.road,
                stroke: false,
                opacity: opts.opacity
            });
            if (!this.roads)
                this.roads = [];
            this.roads.push([x, y]);
            break;
        case STRUCTURE_RAMPART:
            this.circle(x, y, {
                radius: 0.65,
                fill: '#434C43',
                stroke: '#5D735F',
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_WALL:
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.dark,
                stroke: colors.light,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_STORAGE:
            const storageOutline = relPoly(x, y, [
                [-0.45, -0.55],
                [0, -0.65],
                [0.45, -0.55],
                [0.55, 0],
                [0.45, 0.55],
                [0, 0.65],
                [-0.45, 0.55],
                [-0.55, 0],
                [-0.45, -0.55],
            ]);
            this.poly(storageOutline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity
            });
            this.rect(x - 0.35, y - 0.45, 0.7, 0.9, {
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_OBSERVER:
            this.circle(x, y, {
                fill: colors.dark,
                radius: 0.45,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x + 0.225, y, {
                fill: colors.outline,
                radius: 0.20,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_NUKER:
            let outline = [
                [0, -1],
                [-0.47, 0.2],
                [-0.5, 0.5],
                [0.5, 0.5],
                [0.47, 0.2],
                [0, -1],
            ];
            outline = relPoly(x, y, outline);
            this.poly(outline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity
            });
            let inline = [
                [0, -.80],
                [-0.40, 0.2],
                [0.40, 0.2],
                [0, -.80],
            ];
            inline = relPoly(x, y, inline);
            this.poly(inline, {
                stroke: colors.outline,
                strokeWidth: 0.01,
                fill: colors.gray,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_CONTAINER:
            this.rect(x - 0.225, y - 0.3, 0.45, 0.6, {
                fill: 'yellow',
                opacity: opts.opacity,
                stroke: colors.dark,
                strokeWidth: 0.10,
            });
            break;
        default:
            this.circle(x, y, {
                fill: colors.light,
                radius: 0.35,
                stroke: colors.dark,
                strokeWidth: 0.20,
                opacity: opts.opacity
            });
            break;
    }
    return this;
};
const dirs = [
    [],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
];
RoomVisual.prototype.connectRoads = function (opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    const color = opts.color || colors.road || 'white';
    if (!this.roads)
        return;
    this.roads.forEach((r) => {
        for (let i = 1; i <= 4; i++) {
            const d = dirs[i];
            const c = [r[0] + d[0], r[1] + d[1]];
            const rd = _.some(this.roads, r => r[0] == c[0] && r[1] == c[1]);
            if (rd) {
                this.line(r[0], r[1], c[0], c[1], {
                    color: color,
                    width: 0.35,
                    opacity: opts.opacity
                });
            }
        }
    });
    return this;
};
RoomVisual.prototype.speech = function (text, x, y, opts = {}) {
    const background = !!opts.background ? opts.background : colors.speechBackground;
    const textcolor = !!opts.textcolor ? opts.textcolor : colors.speechText;
    const textstyle = !!opts.textstyle ? opts.textstyle : false;
    const textsize = !!opts.textsize ? opts.textsize : speechSize;
    const textfont = !!opts.textfont ? opts.textfont : speechFont;
    const opacity = !!opts.opacity ? opts.opacity : 1;
    let fontstring = '';
    if (textstyle) {
        fontstring = textstyle + ' ';
    }
    fontstring += textsize + ' ' + textfont;
    let pointer = [
        [-0.2, -0.8],
        [0.2, -0.8],
        [0, -0.3]
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    this.poly(pointer, {
        fill: background,
        stroke: background,
        opacity: opacity,
        strokeWidth: 0.0
    });
    this.text(text, x, y - 1, {
        color: textcolor,
        backgroundColor: background,
        backgroundPadding: 0.1,
        opacity: opacity,
        font: fontstring
    });
    return this;
};
RoomVisual.prototype.animatedPosition = function (x, y, opts = {}) {
    const color = !!opts.color ? opts.color : 'blue';
    const opacity = !!opts.opacity ? opts.opacity : 0.5;
    let radius = !!opts.radius ? opts.radius : 0.75;
    const frames = !!opts.frames ? opts.frames : 6;
    const angle = (Game.time % frames * 90 / frames) * (Math.PI / 180);
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    const sizeMod = Math.abs(Game.time % frames - frames / 2) / 10;
    radius += radius * sizeMod;
    const points = [
        rotate(0, -radius, s, c, x, y),
        rotate(radius, 0, s, c, x, y),
        rotate(0, radius, s, c, x, y),
        rotate(-radius, 0, s, c, x, y),
        rotate(0, -radius, s, c, x, y),
    ];
    this.poly(points, { stroke: color, opacity: opacity });
    return this;
};
function rotate(x, y, s, c, px, py) {
    const xDelta = x * c - y * s;
    const yDelta = x * s + y * c;
    return { x: px + xDelta, y: py + yDelta };
}
function relPoly(x, y, poly) {
    return poly.map(p => {
        p[0] += x;
        p[1] += y;
        return p;
    });
}
RoomVisual.prototype.test = function () {
    const demopos = [19, 24];
    this.clear();
    this.structure(demopos[0] + 0, demopos[1] + 0, STRUCTURE_LAB);
    this.structure(demopos[0] + 1, demopos[1] + 1, STRUCTURE_TOWER);
    this.structure(demopos[0] + 2, demopos[1] + 0, STRUCTURE_LINK);
    this.structure(demopos[0] + 3, demopos[1] + 1, STRUCTURE_TERMINAL);
    this.structure(demopos[0] + 4, demopos[1] + 0, STRUCTURE_EXTENSION);
    this.structure(demopos[0] + 5, demopos[1] + 1, STRUCTURE_SPAWN);
    this.animatedPosition(demopos[0] + 7, demopos[1]);
    this.speech('This is a test!', demopos[0] + 10, demopos[1], { opacity: 0.7 });
    return this;
};
const ColorSets = {
    white: ['#ffffff', '#4c4c4c'],
    grey: ['#b4b4b4', '#4c4c4c'],
    red: ['#ff7b7b', '#592121'],
    yellow: ['#fdd388', '#5d4c2e'],
    green: ['#00f4a2', '#236144'],
    blue: ['#50d7f9', '#006181'],
    purple: ['#a071ff', '#371383'],
};
const ResourceColors = {
    [RESOURCE_ENERGY]: ColorSets.yellow,
    [RESOURCE_POWER]: ColorSets.red,
    [RESOURCE_HYDROGEN]: ColorSets.grey,
    [RESOURCE_OXYGEN]: ColorSets.grey,
    [RESOURCE_UTRIUM]: ColorSets.blue,
    [RESOURCE_LEMERGIUM]: ColorSets.green,
    [RESOURCE_KEANIUM]: ColorSets.purple,
    [RESOURCE_ZYNTHIUM]: ColorSets.yellow,
    [RESOURCE_CATALYST]: ColorSets.red,
    [RESOURCE_GHODIUM]: ColorSets.white,
    [RESOURCE_HYDROXIDE]: ColorSets.grey,
    [RESOURCE_ZYNTHIUM_KEANITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_LEMERGITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_HYDRIDE]: ColorSets.blue,
    [RESOURCE_UTRIUM_OXIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_HYDRIDE]: ColorSets.purple,
    [RESOURCE_KEANIUM_OXIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_HYDRIDE]: ColorSets.green,
    [RESOURCE_LEMERGIUM_OXIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_HYDRIDE]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_OXIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_HYDRIDE]: ColorSets.white,
    [RESOURCE_GHODIUM_OXIDE]: ColorSets.white,
    [RESOURCE_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_GHODIUM_ALKALIDE]: ColorSets.white,
    [RESOURCE_CATALYZED_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_CATALYZED_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: ColorSets.white,
};
RoomVisual.prototype.resource = function (type, x, y, size = 0.25, opacity = 1) {
    if (type == RESOURCE_ENERGY || type == RESOURCE_POWER) {
        this._fluid(type, x, y, size, opacity);
    }
    else if ([RESOURCE_CATALYST, RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_LEMERGIUM, RESOURCE_UTRIUM,
        RESOURCE_ZYNTHIUM, RESOURCE_KEANIUM]
        .includes(type)) {
        this._mineral(type, x, y, size, opacity);
    }
    else if (ResourceColors[type] != undefined) {
        this._compound(type, x, y, size, opacity);
    }
    else {
        return ERR_INVALID_ARGS;
    }
    return OK;
};
RoomVisual.prototype._fluid = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.text(type[0], x, y - (size * 0.1), {
        font: (size * 1.5),
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0,
        opacity: opacity
    });
};
RoomVisual.prototype._mineral = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.circle(x, y, {
        radius: size * 0.8,
        fill: ResourceColors[type][1],
        opacity: opacity,
    });
    this.text(type, x, y + (size * 0.03), {
        font: 'bold ' + (size * 1.25) + ' arial',
        color: ResourceColors[type][0],
        backgroundColor: ResourceColors[type][1],
        backgroundPadding: 0,
        opacity: opacity
    });
};
RoomVisual.prototype._compound = function (type, x, y, size = 0.25, opacity = 1) {
    const label = type.replace('2', '₂');
    this.text(label, x, y, {
        font: 'bold ' + (size * 1) + ' arial',
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0.3 * size,
        opacity: opacity
    });
};

Object.defineProperty(Room.prototype, 'print', {
    get() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.name + '">' + this.name + '</a>';
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'my', {
    get() {
        return this.controller && this.controller.my;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isColony', {
    get() {
        return Overmind.colonies[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isOutpost', {
    get() {
        return Overmind.colonyMap[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'owner', {
    get() {
        return this.controller && this.controller.owner ? this.controller.owner.username : undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'reservedByMe', {
    get() {
        return this.controller && this.controller.reservation && this.controller.reservation.username == MY_USERNAME;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'signedByMe', {
    get() {
        return this.controller && this.controller.sign && this.controller.sign.text == Memory.settings.signature;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'creeps', {
    get() {
        if (!this._creeps) {
            this._creeps = this.find(FIND_MY_CREEPS);
        }
        return this._creeps;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'hostiles', {
    get() {
        if (!this._hostiles) {
            this._hostiles = this.find(FIND_HOSTILE_CREEPS, { filter: (creep) => !isAlly(creep.owner.username) });
        }
        return this._hostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'friendlies', {
    get() {
        if (!this._friendlies) {
            this._friendlies = this.find(FIND_HOSTILE_CREEPS, { filter: (creep) => isAlly(creep.owner.username) });
        }
        return this._friendlies;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'invaders', {
    get() {
        if (!this._invaders) {
            this._invaders = _.filter(this.hostiles, (creep) => creep.owner.username == 'Invader');
        }
        return this._invaders;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'sourceKeepers', {
    get() {
        if (!this._sourceKeepers) {
            this._sourceKeepers = _.filter(this.hostiles, (creep) => creep.owner.username == 'Source Keeper');
        }
        return this._sourceKeepers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'playerHostiles', {
    get() {
        if (!this._playerHostiles) {
            this._playerHostiles = _.filter(this.hostiles, (creep) => creep.isPlayer);
        }
        return this._playerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'dangerousHostiles', {
    get() {
        if (!this._dangerousHostiles) {
            if (this.my) {
                this._dangerousHostiles = _.filter(this.hostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0
                    || creep.getActiveBodyparts(RANGED_ATTACK) > 0
                    || creep.getActiveBodyparts(WORK) > 0);
            }
            else {
                this._dangerousHostiles = _.filter(this.hostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0
                    || creep.getActiveBodyparts(RANGED_ATTACK) > 0);
            }
        }
        return this._dangerousHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'dangerousPlayerHostiles', {
    get() {
        if (!this._dangerousPlayerHostiles) {
            if (this.my) {
                this._dangerousPlayerHostiles = _.filter(this.playerHostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0
                    || creep.getActiveBodyparts(RANGED_ATTACK) > 0
                    || creep.getActiveBodyparts(WORK) > 0);
            }
            else {
                this._dangerousPlayerHostiles = _.filter(this.playerHostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0
                    || creep.getActiveBodyparts(RANGED_ATTACK) > 0);
            }
        }
        return this._dangerousPlayerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'fleeDefaults', {
    get() {
        if (!this._fleeDefaults) {
            this._fleeDefaults = [
                ...this.dangerousHostiles,
                ..._.filter(this.keeperLairs, (l) => (l.ticksToSpawn || Infinity) <= 10)
            ];
        }
        return this._fleeDefaults;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'structures', {
    get() {
        if (!this._allStructures) {
            this._allStructures = this.find(FIND_STRUCTURES);
        }
        return this._allStructures;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'hostileStructures', {
    get() {
        if (!this._hostileStructures) {
            this._hostileStructures = this.find(FIND_HOSTILE_STRUCTURES, {
                filter: (s) => (s.hitsMax) && !isAlly(_.get(s, ['owner', 'username']))
            });
        }
        return this._hostileStructures;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'flags', {
    get() {
        if (!this._flags) {
            this._flags = this.find(FIND_FLAGS);
        }
        return this._flags;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'constructionSites', {
    get() {
        if (!this._constructionSites) {
            this._constructionSites = this.find(FIND_MY_CONSTRUCTION_SITES);
        }
        return this._constructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'allConstructionSites', {
    get() {
        if (!this._allConstructionSites) {
            this._allConstructionSites = this.find(FIND_CONSTRUCTION_SITES);
        }
        return this._allConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'hostileConstructionSites', {
    get() {
        if (!this._hostileConstructionSites) {
            this._hostileConstructionSites = this.find(FIND_HOSTILE_CONSTRUCTION_SITES);
        }
        return this._hostileConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'tombstones', {
    get() {
        if (!this._tombstones) {
            this._tombstones = this.find(FIND_TOMBSTONES);
        }
        return this._tombstones;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'ruins', {
    get() {
        if (!this._ruins) {
            this._ruins = this.find(FIND_RUINS);
        }
        return this._ruins;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'drops', {
    get() {
        if (!this._drops) {
            this._drops = _.groupBy(this.find(FIND_DROPPED_RESOURCES), (r) => r.resourceType);
        }
        return this._drops;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'droppedEnergy', {
    get() {
        return this.drops[RESOURCE_ENERGY] || [];
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'droppedPower', {
    get() {
        return this.drops[RESOURCE_POWER] || [];
    },
    configurable: true,
});

const roomStructureIDs = {};
const roomStructuresExpiration = {};
const multipleList = [
    STRUCTURE_SPAWN, STRUCTURE_EXTENSION, STRUCTURE_ROAD, STRUCTURE_WALL,
    STRUCTURE_RAMPART, STRUCTURE_KEEPER_LAIR, STRUCTURE_PORTAL, STRUCTURE_LINK,
    STRUCTURE_TOWER, STRUCTURE_LAB, STRUCTURE_CONTAINER, STRUCTURE_POWER_BANK,
];
const singleList = [
    STRUCTURE_OBSERVER, STRUCTURE_POWER_SPAWN, STRUCTURE_EXTRACTOR,
    STRUCTURE_NUKER, STRUCTURE_FACTORY, STRUCTURE_INVADER_CORE,
];
const notRepairable = [STRUCTURE_KEEPER_LAIR, STRUCTURE_PORTAL, STRUCTURE_POWER_BANK, STRUCTURE_INVADER_CORE];
const STRUCTURE_TIMEOUT = onPublicServer() ? 50 : 10;
Room.prototype._refreshStructureCache = function () {
    if (!roomStructuresExpiration[this.name]
        || !roomStructureIDs[this.name]
        || Game.time > roomStructuresExpiration[this.name]) {
        roomStructuresExpiration[this.name] = getCacheExpiration(STRUCTURE_TIMEOUT);
        roomStructureIDs[this.name] = _.mapValues(_.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType), (structures) => _.map(structures, s => s.id));
    }
};
multipleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type + 's', {
        get: function () {
            if (this['_' + type + 's']) {
                return this['_' + type + 's'];
            }
            else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    return this['_' + type + 's'] = _.compact(_.map(roomStructureIDs[this.name][type], Game.getObjectById));
                }
                else {
                    return this['_' + type + 's'] = [];
                }
            }
        },
        configurable: true,
    });
});
singleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type, {
        get: function () {
            if (this['_' + type]) {
                return this['_' + type];
            }
            else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    return this['_' + type] = Game.getObjectById(roomStructureIDs[this.name][type][0]);
                }
                else {
                    return this['_' + type] = undefined;
                }
            }
        },
        configurable: true,
    });
});
Object.defineProperty(Room.prototype, 'storageUnits', {
    get() {
        if (!this._storageUnits) {
            this._storageUnits = _.compact([this.storage, this.terminal]).concat(this.containers);
        }
        return this._storageUnits;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'sources', {
    get() {
        if (!this._sources) {
            this._sources = this.find(FIND_SOURCES);
        }
        return this._sources;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'mineral', {
    get() {
        if (!this._mineral) {
            this._mineral = this.find(FIND_MINERALS)[0];
        }
        return this._mineral;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'repairables', {
    get() {
        if (!this._repairables) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].repairables) {
                return this._repairables = _.compact(_.map(roomStructureIDs[this.name].repairables, Game.getObjectById));
            }
            else {
                let repairables = [];
                for (const structureType of singleList) {
                    if (this[structureType]) {
                        repairables.push(this[structureType]);
                    }
                }
                for (const structureType of multipleList) {
                    if (structureType != STRUCTURE_WALL &&
                        structureType != STRUCTURE_RAMPART &&
                        structureType != STRUCTURE_ROAD &&
                        !notRepairable.includes(structureType)) {
                        repairables = repairables.concat(this[structureType + 's']);
                    }
                }
                roomStructureIDs[this.name].repairables = _.map(repairables, s => s.id);
                return this._repairables = repairables;
            }
        }
        return this._repairables;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'walkableRamparts', {
    get() {
        if (!this._walkableRamparts) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].walkableRamparts) {
                return this._walkableRamparts = _.compact(_.map(roomStructureIDs[this.name].walkableRamparts, Game.getObjectById));
            }
            else {
                const walkableRamparts = _.filter(this.ramparts, (r) => r.pos.isWalkable(true));
                roomStructureIDs[this.name].walkableRamparts = _.map(walkableRamparts, r => r.id);
                return this._walkableRamparts = walkableRamparts;
            }
        }
        return this._walkableRamparts;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'rechargeables', {
    get() {
        if (!this._rechargeables) {
            this._rechargeables = [...this.storageUnits,
                ...this.droppedEnergy,
                ...this.tombstones,
                ...this.ruins];
        }
        return this._rechargeables;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'barriers', {
    get() {
        if (!this._barriers) {
            this._barriers = [].concat(this.ramparts, this.constructedWalls);
        }
        return this._barriers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'walls', {
    get() {
        return this.constructedWalls;
    },
    configurable: true,
});

PERMACACHE.structureWalkability = PERMACACHE.structureWalkability || {};
Object.defineProperty(Structure.prototype, 'isWalkable', {
    get() {
        if (PERMACACHE.structureWalkability[this.id] !== undefined) {
            return PERMACACHE.structureWalkability[this.id];
        }
        if (this.structureType === STRUCTURE_RAMPART) {
            return (this.my || this.isPublic);
        }
        else {
            PERMACACHE.structureWalkability[this.id] = this.structureType == STRUCTURE_ROAD ||
                this.structureType == STRUCTURE_CONTAINER ||
                this.structureType == STRUCTURE_PORTAL;
            return PERMACACHE.structureWalkability[this.id];
        }
    },
    configurable: true,
});
OwnedStructure.prototype._isActive = OwnedStructure.prototype.isActive;
Object.defineProperty(StructureContainer.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureContainer.prototype, 'isFull', {
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureContainer.prototype, 'isEmpty', {
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'reservedByMe', {
    get: function () {
        return this.reservation && this.reservation.username == MY_USERNAME;
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'signedByMe', {
    get: function () {
        return this.sign && this.sign.username == MY_USERNAME && Game.time - this.sign.time < 250000;
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'signedByScreeps', {
    get: function () {
        return this.sign && this.sign.username == 'Screeps';
    },
    configurable: true,
});
StructureController.prototype.needsReserving = function (reserveBuffer) {
    return !this.reservation || (this.reservedByMe && this.reservation.ticksToEnd < reserveBuffer);
};
Object.defineProperty(StructureExtension.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureExtension.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureLink.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureLink.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureLink.prototype, 'storeCapacity', {
    get() {
        return this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureSpawn.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureSpawn.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
Object.defineProperty(Store.prototype, 'contents', {
    get() {
        return Object.entries(this);
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'isFull', {
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'isEmpty', {
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isFull', {
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isEmpty', {
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isReady', {
    get() {
        return this.cooldown == 0 && !this._notReady;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'hasReceived', {
    get() {
        return this._hasReceived;
    },
    configurable: true,
});
const _terminalSend = StructureTerminal.prototype.send;
StructureTerminal.prototype.send = function (resourceType, amount, destination, description) {
    const response = _terminalSend.call(this, resourceType, amount, destination, description);
    if (response == OK) {
        this._notReady = true;
        if (Game.rooms[destination] && Game.rooms[destination].terminal) {
            Game.rooms[destination].terminal._hasReceived = true;
        }
    }
    return response;
};
Object.defineProperty(StructureTower.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureTower.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
Object.defineProperty(Tombstone.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});

"use strict";
String.prototype.padRight = function (length, char = ' ') {
    return this + char.repeat(Math.max(length - this.length, 0));
};
String.prototype.padLeft = function (length, char = ' ') {
    return char.repeat(Math.max(length - this.length, 0)) + this;
};
Number.prototype.toPercent = function (decimals = 0) {
    return (this * 100).toFixed(decimals) + '%';
};
Number.prototype.truncate = function (decimals) {
    const re = new RegExp('(\\d+\\.\\d{' + decimals + '})(\\d)'), m = this.toString().match(re);
    return m ? parseFloat(m[1]) : this.valueOf();
};
PERMACACHE.structureWalkability = PERMACACHE.structureWalkability || {};
Object.defineProperty(ConstructionSite.prototype, 'isWalkable', {
    get() {
        if (PERMACACHE.structureWalkability[this.id] === undefined) {
            PERMACACHE.structureWalkability[this.id] = this.structureType == STRUCTURE_ROAD ||
                this.structureType == STRUCTURE_CONTAINER ||
                this.structureType == STRUCTURE_RAMPART;
        }
        return PERMACACHE.structureWalkability[this.id];
    },
    configurable: true,
});

var Log_1;
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["ERROR"] = 0] = "ERROR";
    LogLevels[LogLevels["WARNING"] = 1] = "WARNING";
    LogLevels[LogLevels["ALERT"] = 2] = "ALERT";
    LogLevels[LogLevels["INFO"] = 3] = "INFO";
    LogLevels[LogLevels["DEBUG"] = 4] = "DEBUG";
})(LogLevels || (LogLevels = {}));
const LOG_LEVEL = LogLevels.INFO;
const LOG_PRINT_TICK = true;
const LOG_PRINT_LINES = false;
const LOG_LOAD_SOURCE_MAP = false;
const LOG_MAX_PAD = 100;
const LOG_VSC = { repo: '@@_repo_@@', revision: '@@_revision_@@', valid: false };
const LOG_VSC_URL_TEMPLATE = (path, line) => {
    return `${LOG_VSC.repo}/blob/${LOG_VSC.revision}/${path}#${line}`;
};
const stackLineRe = /([^ ]*) \(([^:]*):([0-9]*):([0-9]*)\)/;
const FATAL = -1;
const fatalColor = '#d65156';
function resolve(fileLine) {
    const split = _.trim(fileLine).match(stackLineRe);
    if (!split || !Log.sourceMap) {
        return { compiled: fileLine, final: fileLine };
    }
    const pos = { column: parseInt(split[4], 10), line: parseInt(split[3], 10) };
    const original = Log.sourceMap.originalPositionFor(pos);
    const line = `${split[1]} (${original.source}:${original.line})`;
    const out = {
        caller: split[1],
        compiled: fileLine,
        final: line,
        line: original.line,
        original: line,
        path: original.source,
    };
    return out;
}
function makeVSCLink(pos) {
    if (!LOG_VSC.valid || !pos.caller || !pos.path || !pos.line || !pos.original) {
        return pos.final;
    }
    return link(vscUrl(pos.path, `L${pos.line.toString()}`), pos.original);
}
function tooltip(str, tooltip) {
    return `<abbr title='${tooltip}'>${str}</abbr>`;
}
function vscUrl(path, line) {
    return LOG_VSC_URL_TEMPLATE(path, line);
}
function link(href, title) {
    return `<a href='${href}' target="_blank">${title}</a>`;
}
function time() {
    return color(Game.time.toString(), 'gray');
}
function debug(thing, ...args) {
    if (thing.memory && thing.memory.debug) {
        this.debug(`${thing.name} @ ${thing.pos.print}: `, args);
    }
}
let Log = Log_1 = class Log {
    constructor() {
        this._maxFileString = 0;
        _.defaultsDeep(Memory, {
            settings: {
                log: {
                    level: LOG_LEVEL,
                    showSource: LOG_PRINT_LINES,
                    showTick: LOG_PRINT_TICK,
                }
            }
        });
    }
    static loadSourceMap() {
        console.log('Source mapping deprecated.');
    }
    get level() {
        return Memory.settings.log.level;
    }
    setLogLevel(value) {
        let changeValue = true;
        switch (value) {
            case LogLevels.ERROR:
                console.log(`Logging level set to ${value}. Displaying: ERROR.`);
                break;
            case LogLevels.WARNING:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING.`);
                break;
            case LogLevels.ALERT:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT.`);
                break;
            case LogLevels.INFO:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO.`);
                break;
            case LogLevels.DEBUG:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO, DEBUG.`);
                break;
            default:
                console.log(`Invalid input: ${value}. Loging level can be set to integers between `
                    + LogLevels.ERROR + ' and ' + LogLevels.DEBUG + ', inclusive.');
                changeValue = false;
                break;
        }
        if (changeValue) {
            Memory.settings.log.level = value;
        }
    }
    get showSource() {
        return Memory.settings.log.showSource;
    }
    set showSource(value) {
        Memory.settings.log.showSource = value;
    }
    get showTick() {
        return Memory.settings.log.showTick;
    }
    set showTick(value) {
        Memory.settings.log.showTick = value;
    }
    trace(error) {
        if (this.level >= LogLevels.ERROR && error.stack) {
            console.log(this.resolveStack(error.stack));
        }
        return this;
    }
    throw(e) {
        console.log.apply(this, this.buildArguments(FATAL).concat([color(e.toString(), fatalColor)]));
    }
    error(...args) {
        if (this.level >= LogLevels.ERROR) {
            console.log.apply(this, this.buildArguments(LogLevels.ERROR).concat([].slice.call(args)));
        }
        return undefined;
    }
    warning(...args) {
        if (this.level >= LogLevels.WARNING) {
            console.log.apply(this, this.buildArguments(LogLevels.WARNING).concat([].slice.call(args)));
        }
        return undefined;
    }
    alert(...args) {
        if (this.level >= LogLevels.ALERT) {
            console.log.apply(this, this.buildArguments(LogLevels.ALERT).concat([].slice.call(args)));
        }
        return undefined;
    }
    notify(message) {
        this.alert(message);
        Game.notify(message);
        return undefined;
    }
    info(...args) {
        if (this.level >= LogLevels.INFO) {
            console.log.apply(this, this.buildArguments(LogLevels.INFO).concat([].slice.call(args)));
        }
        return undefined;
    }
    debug(...args) {
        if (this.level >= LogLevels.DEBUG) {
            console.log.apply(this, this.buildArguments(LogLevels.DEBUG).concat([].slice.call(args)));
        }
    }
    debugCreep(creep, ...args) {
        if (creep.memory && creep.memory.debug) {
            this.debug(`${creep.name} @ ${creep.pos.print}: `, args);
        }
    }
    printObject(obj) {
        console.log.apply(this, this.buildArguments(LogLevels.DEBUG).concat(JSON.stringify(obj)));
    }
    getFileLine(upStack = 4) {
        const stack = new Error('').stack;
        if (stack) {
            const lines = stack.split('\n');
            if (lines.length > upStack) {
                const originalLines = _.drop(lines, upStack).map(resolve);
                const hoverText = _.map(originalLines, 'final').join('&#10;');
                return this.adjustFileLine(originalLines[0].final, tooltip(makeVSCLink(originalLines[0]), hoverText));
            }
        }
        return '';
    }
    buildArguments(level) {
        const out = [];
        switch (level) {
            case LogLevels.ERROR:
                out.push(color('ERROR  ', 'red'));
                break;
            case LogLevels.WARNING:
                out.push(color('WARNING', 'orange'));
                break;
            case LogLevels.ALERT:
                out.push(color('ALERT  ', 'yellow'));
                break;
            case LogLevels.INFO:
                out.push(color('INFO   ', 'green'));
                break;
            case LogLevels.DEBUG:
                out.push(color('DEBUG  ', 'gray'));
                break;
            case FATAL:
                out.push(color('FATAL  ', fatalColor));
                break;
            default:
                break;
        }
        if (this.showTick) {
            out.push(time());
        }
        if (this.showSource && level <= LogLevels.ERROR) {
            out.push(this.getFileLine());
        }
        return out;
    }
    resolveStack(stack) {
        if (!Log_1.sourceMap) {
            return stack;
        }
        return _.map(stack.split('\n').map(resolve), 'final').join('\n');
    }
    adjustFileLine(visibleText, line) {
        const newPad = Math.max(visibleText.length, this._maxFileString);
        this._maxFileString = Math.min(newPad, LOG_MAX_PAD);
        return `|${_.padRight(line, line.length + this._maxFileString - visibleText.length, ' ')}|`;
    }
};
Log = Log_1 = __decorate([
    profile
], Log);
if (LOG_LOAD_SOURCE_MAP) {
    Log.loadSourceMap();
}
const log = new Log();

let Task = class Task {
    constructor(taskName, target, options = {}) {
        this.name = taskName;
        this._creep = {
            name: '',
        };
        if (target) {
            this._target = {
                ref: target.ref,
                _pos: target.pos,
            };
        }
        else {
            this._target = {
                ref: '',
                _pos: {
                    x: -1,
                    y: -1,
                    roomName: '',
                }
            };
        }
        this._parent = null;
        this.settings = {
            targetRange: 1,
            workOffRoad: false,
            oneShot: false,
            timeout: Infinity,
            blind: true,
        };
        this.tick = Game.time;
        this.options = options;
        this.data = {};
    }
    get print() {
        let descriptor = this.name;
        if (this.targetPos) {
            descriptor += ' targetPos: ' + this.targetPos.print;
        }
        if (this.target) {
            const targetId = this.target.id;
            if (targetId && Game.getObjectById(targetId)) {
                descriptor += ' target: ' + Game.getObjectById(targetId).toString();
            }
        }
        if (this.parent) {
            descriptor += ' parent:\n' + ' ' + this.parent.print;
        }
        return descriptor;
    }
    toString() {
        return this.print;
    }
    get proto() {
        return {
            name: this.name,
            _creep: this._creep,
            _target: this._target,
            _parent: this._parent,
            tick: this.tick,
            options: this.options,
            data: this.data,
        };
    }
    set proto(protoTask) {
        this._creep = protoTask._creep;
        this._target = protoTask._target;
        this._parent = protoTask._parent;
        this.tick = protoTask.tick;
        this.options = protoTask.options;
        this.data = protoTask.data;
    }
    get creep() {
        return Overmind.zerg[this._creep.name];
    }
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
    }
    get target() {
        return deref(this._target.ref);
    }
    get targetPos() {
        if (!this._targetPos) {
            if (this.target) {
                this._target._pos = this.target.pos;
            }
            this._targetPos = derefRoomPosition(this._target._pos);
        }
        return this._targetPos;
    }
    get parent() {
        return (this._parent ? initializeTask(this._parent) : null);
    }
    set parent(parentTask) {
        this._parent = parentTask ? parentTask.proto : null;
        if (this.creep) {
            this.creep.task = this;
        }
    }
    get manifest() {
        const manifest = [this];
        let parent = this.parent;
        while (parent) {
            manifest.push(parent);
            parent = parent.parent;
        }
        return manifest;
    }
    get targetManifest() {
        const targetRefs = [this._target.ref];
        let parent = this._parent;
        while (parent) {
            targetRefs.push(parent._target.ref);
            parent = parent._parent;
        }
        return _.map(targetRefs, ref => deref(ref));
    }
    get targetPosManifest() {
        const targetPositions = [this._target._pos];
        let parent = this._parent;
        while (parent) {
            targetPositions.push(parent._target._pos);
            parent = parent._parent;
        }
        return _.map(targetPositions, protoPos => derefRoomPosition(protoPos));
    }
    fork(newTask) {
        newTask.parent = this;
        if (this.creep) {
            this.creep.task = newTask;
        }
        return newTask;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask() && Game.time - this.tick < this.settings.timeout;
        }
        let validTarget = false;
        if (this.target) {
            validTarget = this.isValidTarget();
        }
        else if ((this.settings.blind || this.options.blind) && !Game.rooms[this.targetPos.roomName]) {
            validTarget = true;
        }
        if (validTask && validTarget) {
            return true;
        }
        else {
            this.finish();
            const isValid = this.parent ? this.parent.isValid() : false;
            return isValid;
        }
    }
    moveToTarget(range = this.settings.targetRange) {
        return this.creep.goTo(this.targetPos, { range: range });
    }
    moveToNextPos() {
        if (this.options.nextPos) {
            const nextPos = derefRoomPosition(this.options.nextPos);
            return this.creep.goTo(nextPos);
        }
    }
    get eta() {
        if (this.creep && this.creep.memory._go && this.creep.memory._go.path) {
            return this.creep.memory._go.path.length;
        }
    }
    run() {
        if (this.isWorking) {
            delete this.creep.memory._go;
            const result = this.work();
            if (this.settings.oneShot && result === OK) {
                this.finish();
            }
            return result;
        }
        else {
            this.moveToTarget();
        }
    }
    get isWorking() {
        return this.creep.pos.inRangeToPos(this.targetPos, this.settings.targetRange) && !this.creep.pos.isEdge;
    }
    finish() {
        this.moveToNextPos();
        if (this.creep) {
            this.creep.task = this.parent;
        }
        else {
            log.debug(`No creep executing ${this.name}! Proto: ${JSON.stringify(this.proto)}`);
        }
    }
};
Task = __decorate([
    profile
], Task);

const attackTaskName = 'attack';
let TaskAttack = class TaskAttack extends Task {
    constructor(target, options = {}) {
        super(attackTaskName, target, options);
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(ATTACK) > 0 || this.creep.getActiveBodyparts(RANGED_ATTACK) > 0);
    }
    isValidTarget() {
        return !!this.target && this.target.hits > 0;
    }
    work() {
        const creep = this.creep;
        const target = this.target;
        if (!target) {
            return ERR_INVALID_TARGET;
        }
        let attackReturn = 0;
        let rangedAttackReturn = 0;
        if (creep.getActiveBodyparts(ATTACK) > 0) {
            if (creep.pos.isNearTo(target)) {
                attackReturn = creep.attack(target);
            }
            else {
                attackReturn = this.moveToTarget(1);
            }
        }
        if (creep.pos.inRangeTo(target, 3) && creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
            rangedAttackReturn = creep.rangedAttack(target);
        }
        if (attackReturn == OK && rangedAttackReturn == OK) {
            return OK;
        }
        else {
            if (attackReturn != OK) {
                return rangedAttackReturn;
            }
            else {
                return attackReturn;
            }
        }
    }
};
TaskAttack = __decorate([
    profile
], TaskAttack);

const buildTaskName = 'build';
let TaskBuild = class TaskBuild extends Task {
    constructor(target, options = {}) {
        super(buildTaskName, target, options);
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        return !!this.target && this.target.my && this.target.progress < this.target.progressTotal;
    }
    work() {
        if (!this.target) {
            return ERR_INVALID_TARGET;
        }
        if (!this.target.isWalkable) {
            const creepOnTarget = this.target.pos.lookFor(LOOK_CREEPS)[0];
            if (creepOnTarget) {
                const zerg = Overmind.zerg[creepOnTarget.name];
                if (zerg) {
                    this.creep.say('move pls');
                    zerg.moveOffCurrentPos();
                }
            }
        }
        return this.creep.build(this.target);
    }
};
TaskBuild = __decorate([
    profile
], TaskBuild);

const claimTaskName = 'claim';
let TaskClaim = class TaskClaim extends Task {
    constructor(target, options = {}) {
        super(claimTaskName, target, options);
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(CLAIM) > 0);
    }
    isValidTarget() {
        return (this.target != null && (!this.target.room || !this.target.owner));
    }
    work() {
        if (!this.target) {
            return ERR_INVALID_TARGET;
        }
        return this.creep.claimController(this.target);
    }
};
TaskClaim = __decorate([
    profile
], TaskClaim);

const dismantleTaskName = 'dismantle';
let TaskDismantle = class TaskDismantle extends Task {
    constructor(target, options = {}) {
        super(dismantleTaskName, target, options);
        this.settings.timeout = 100;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(WORK) > 0);
    }
    isValidTarget() {
        return !!this.target && this.target.hits > 0;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.dismantle(this.target);
    }
};
TaskDismantle = __decorate([
    profile
], TaskDismantle);

var TaskDrop_1;
const dropTaskName = 'drop';
let TaskDrop = TaskDrop_1 = class TaskDrop extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(TaskDrop_1.taskName, { ref: '', pos: target.pos }, options);
        this.settings.targetRange = 0;
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.carry[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        if (validTask) {
            return true;
        }
        else {
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return this.creep.drop(this.data.resourceType, this.data.amount);
    }
};
TaskDrop.taskName = 'drop';
TaskDrop = TaskDrop_1 = __decorate([
    profile
], TaskDrop);

const fortifyTaskName = 'fortify';
let TaskFortify = class TaskFortify extends Task {
    constructor(target, hitsMax, options = {}) {
        super(fortifyTaskName, target, options);
        this.settings.timeout = 100;
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
        this.data.hitsMax = hitsMax;
    }
    isValidTask() {
        return (this.creep.carry.energy > 0);
    }
    isValidTarget() {
        return !!this.target && this.target.hits < (this.data.hitsMax || this.target.hitsMax);
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.repair(this.target);
    }
};
TaskFortify = __decorate([
    profile
], TaskFortify);

const generateSafeModeTaskName = 'generateSafeMode';
let TaskGenerateSafeMode = class TaskGenerateSafeMode extends Task {
    constructor(target, options = {}) {
        super(generateSafeModeTaskName, target, options);
    }
    isValidTask() {
        return (this.creep.carry[RESOURCE_GHODIUM] >= 1000);
    }
    isValidTarget() {
        return (!!this.target && !!this.target.owner);
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.generateSafeMode(this.target);
    }
};
TaskGenerateSafeMode = __decorate([
    profile
], TaskGenerateSafeMode);

const RESOURCES_ALL_EXCEPT_ENERGY = _.without(RESOURCES_ALL, RESOURCE_ENERGY);
const BOOSTS_T3 = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
];
const BOOSTS_T2 = [
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
];
const BOOSTS_T1 = [
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
];
const INTERMEDIATE_REACTANTS = [
    RESOURCE_HYDROXIDE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
];
const BASE_RESOURCES = [
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
];
const _baseResourcesLookup = _.zipObject(BASE_RESOURCES, _.map(BASE_RESOURCES, i => true));
const RESOURCE_IMPORTANCE = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_OPS,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_GHODIUM,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_HYDROXIDE,
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_POWER,
    RESOURCE_ENERGY,
];
const REAGENTS = {
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_GHODIUM_ACID]: [RESOURCE_GHODIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: [RESOURCE_LEMERGIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_KEANIUM_ACID]: [RESOURCE_KEANIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ACID]: [RESOURCE_UTRIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_GHODIUM_ACID]: [RESOURCE_GHODIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ALKALIDE]: [RESOURCE_LEMERGIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ACID]: [RESOURCE_KEANIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ACID]: [RESOURCE_UTRIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_HYDRIDE]: [RESOURCE_GHODIUM, RESOURCE_HYDROGEN],
    [RESOURCE_GHODIUM_OXIDE]: [RESOURCE_GHODIUM, RESOURCE_OXYGEN],
    [RESOURCE_ZYNTHIUM_HYDRIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_OXIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_OXYGEN],
    [RESOURCE_LEMERGIUM_OXIDE]: [RESOURCE_LEMERGIUM, RESOURCE_OXYGEN],
    [RESOURCE_LEMERGIUM_HYDRIDE]: [RESOURCE_LEMERGIUM, RESOURCE_HYDROGEN],
    [RESOURCE_KEANIUM_OXIDE]: [RESOURCE_KEANIUM, RESOURCE_OXYGEN],
    [RESOURCE_KEANIUM_HYDRIDE]: [RESOURCE_KEANIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_HYDRIDE]: [RESOURCE_UTRIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_OXIDE]: [RESOURCE_UTRIUM, RESOURCE_OXYGEN],
    [RESOURCE_GHODIUM]: [RESOURCE_ZYNTHIUM_KEANITE, RESOURCE_UTRIUM_LEMERGITE],
    [RESOURCE_HYDROXIDE]: [RESOURCE_OXYGEN, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_KEANITE]: [RESOURCE_ZYNTHIUM, RESOURCE_KEANIUM],
    [RESOURCE_UTRIUM_LEMERGITE]: [RESOURCE_UTRIUM, RESOURCE_LEMERGIUM]
};
const MINERAL_COMPOUNDS_ALL = _.keys(REAGENTS).concat(BASE_RESOURCES);
const _mineralCompoundsAllLookup = _.zipObject(MINERAL_COMPOUNDS_ALL, _.map(MINERAL_COMPOUNDS_ALL, i => true));
const BOOST_PARTS = {
    UH: ATTACK,
    UO: WORK,
    KH: CARRY,
    KO: RANGED_ATTACK,
    LH: WORK,
    LO: HEAL,
    ZH: WORK,
    ZO: MOVE,
    GH: WORK,
    GO: TOUGH,
    UH2O: ATTACK,
    UHO2: WORK,
    KH2O: CARRY,
    KHO2: RANGED_ATTACK,
    LH2O: WORK,
    LHO2: HEAL,
    ZH2O: WORK,
    ZHO2: MOVE,
    GH2O: WORK,
    GHO2: TOUGH,
    XUH2O: ATTACK,
    XUHO2: WORK,
    XKH2O: CARRY,
    XKHO2: RANGED_ATTACK,
    XLH2O: WORK,
    XLHO2: HEAL,
    XZH2O: WORK,
    XZHO2: MOVE,
    XGH2O: WORK,
    XGHO2: TOUGH,
};
const BoostTypeBodyparts = {
    attack: ATTACK,
    carry: CARRY,
    ranged: RANGED_ATTACK,
    heal: HEAL,
    move: MOVE,
    tough: TOUGH,
    harvest: WORK,
    construct: WORK,
    dismantle: WORK,
    upgrade: WORK,
};
function isBoostType(str) {
    return str === 'attack'
        || str === 'carry'
        || str === 'ranged'
        || str === 'heal'
        || str === 'move'
        || str === 'tough'
        || str === 'harvest'
        || str === 'construct'
        || str === 'dismantle'
        || str === 'upgrade';
}
const BOOST_TIERS = {
    attack: {
        T1: 'UH',
        T2: 'UH2O',
        T3: 'XUH2O',
    },
    carry: {
        T1: 'KH',
        T2: 'KH2O',
        T3: 'XKH2O',
    },
    ranged: {
        T1: 'KO',
        T2: 'KHO2',
        T3: 'XKHO2',
    },
    heal: {
        T1: 'LO',
        T2: 'LHO2',
        T3: 'XLHO2',
    },
    move: {
        T1: 'ZO',
        T2: 'ZHO2',
        T3: 'XZHO2',
    },
    tough: {
        T1: 'GO',
        T2: 'GHO2',
        T3: 'XGHO2',
    },
    harvest: {
        T1: 'UO',
        T2: 'UHO2',
        T3: 'XUHO2',
    },
    construct: {
        T1: 'LH',
        T2: 'LH2O',
        T3: 'XLH2O',
    },
    dismantle: {
        T1: 'ZH',
        T2: 'ZH2O',
        T3: 'XZH2O',
    },
    upgrade: {
        T1: 'GH',
        T2: 'GH2O',
        T3: 'XGH2O',
    },
};
const _boostTypesTierLookup = _.mapValues(BOOST_TIERS, boostType => _.invert(boostType));
const _boostTierLookupAllTypes = _.extend({}, ..._.values(_boostTypesTierLookup));
const COMMODITIES_ALL = [
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_BATTERY,
    RESOURCE_COMPOSITE,
    RESOURCE_CRYSTAL,
    RESOURCE_LIQUID,
    RESOURCE_WIRE,
    RESOURCE_CELL,
    RESOURCE_ALLOY,
    RESOURCE_CONDENSATE,
    RESOURCE_TUBE,
    RESOURCE_FIXTURES,
    RESOURCE_FRAME,
    RESOURCE_HYDRAULICS,
    RESOURCE_MACHINE,
    RESOURCE_PHLEGM,
    RESOURCE_TISSUE,
    RESOURCE_MUSCLE,
    RESOURCE_ORGANOID,
    RESOURCE_ORGANISM,
    RESOURCE_SWITCH,
    RESOURCE_TRANSISTOR,
    RESOURCE_MICROCHIP,
    RESOURCE_CIRCUIT,
    RESOURCE_DEVICE,
    RESOURCE_CONCENTRATE,
    RESOURCE_EXTRACT,
    RESOURCE_SPIRIT,
    RESOURCE_EMANATION,
    RESOURCE_ESSENCE
];
const _commoditiesLookup = _.zipObject(COMMODITIES_ALL, _.map(COMMODITIES_ALL, i => true));
const DEPOSITS_ALL = [
    RESOURCE_SILICON,
    RESOURCE_BIOMASS,
    RESOURCE_METAL,
    RESOURCE_MIST,
];
const ALL_ZERO_ASSETS = _.zipObject(RESOURCES_ALL, _.map(RESOURCES_ALL, i => 0));

const getBoostedTaskName = 'getBoosted';
const MIN_LIFETIME_FOR_BOOST = 0.85;
let TaskGetBoosted = class TaskGetBoosted extends Task {
    constructor(target, boostType, partCount, options = {}) {
        super(getBoostedTaskName, target, options);
        this.data.resourceType = boostType;
        this.data.amount = partCount;
    }
    isValidTask() {
        const lifetime = _.any(this.creep.body, part => part.type == CLAIM) ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        if (this.creep.ticksToLive && this.creep.ticksToLive < MIN_LIFETIME_FOR_BOOST * lifetime) {
            return false;
        }
        const partCount = (this.data.amount || this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]));
        return (this.creep.boostCounts[this.data.resourceType] || 0) < partCount;
    }
    isValidTarget() {
        const partCount = (this.data.amount || this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]));
        const lab = this.target;
        return !!lab &&
            lab.mineralType == this.data.resourceType &&
            lab.store[lab.mineralType] >= LAB_BOOST_MINERAL * partCount &&
            lab.store.energy >= LAB_BOOST_ENERGY * partCount;
    }
    work() {
        if (this.creep.spawning) {
            return ERR_INVALID_TARGET;
        }
        const partCount = (this.data.amount || this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]));
        const lab = this.target;
        if (!lab)
            return ERR_INVALID_TARGET;
        if (lab.mineralType == this.data.resourceType &&
            lab.store[lab.mineralType] >= LAB_BOOST_MINERAL * partCount &&
            lab.store.energy >= LAB_BOOST_ENERGY * partCount) {
            const result = this.target.boostCreep(deref(this._creep.name), this.data.amount);
            log.info(`Lab@${this.target.pos.print}: boosting creep ${this.creep.print} with ${this.target.mineralType}!`
                + ` Response: ${result}`);
            return result;
        }
        else {
            return ERR_NOT_FOUND;
        }
    }
};
TaskGetBoosted = __decorate([
    profile
], TaskGetBoosted);

const getRenewedTaskName = 'getRenewed';
let TaskGetRenewed = class TaskGetRenewed extends Task {
    constructor(target, options = {}) {
        super(getRenewedTaskName, target, options);
    }
    isValidTask() {
        const hasClaimPart = _.filter(this.creep.body, (part) => part.type == CLAIM).length > 0;
        const lifetime = hasClaimPart ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        return this.creep.ticksToLive != undefined && this.creep.ticksToLive < 0.9 * lifetime;
    }
    isValidTarget() {
        return !!this.target && this.target.my && !this.target.spawning;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.target.renewCreep(this.creep.creep);
    }
};
TaskGetRenewed = __decorate([
    profile
], TaskGetRenewed);

const goToTaskName = 'goTo';
let TaskGoTo = class TaskGoTo extends Task {
    constructor(target, options = {}) {
        super(goToTaskName, { ref: '', pos: target.pos }, options);
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(this.targetPos, this.settings.targetRange);
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        if (validTask) {
            return true;
        }
        else {
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoTo = __decorate([
    profile
], TaskGoTo);

const goToRoomTaskName = 'goToRoom';
let TaskGoToRoom = class TaskGoToRoom extends Task {
    constructor(_HasRoomPositionObj, options = {}) {
        super(goToRoomTaskName, { ref: '', pos: _HasRoomPositionObj.pos }, options);
        this.settings.targetRange = 23;
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(this.targetPos, this.settings.targetRange);
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        if (validTask) {
            return true;
        }
        else {
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoToRoom = __decorate([
    profile
], TaskGoToRoom);

const harvestTaskName = 'harvest';
let TaskHarvest = class TaskHarvest extends Task {
    constructor(target, options = {}) {
        super(harvestTaskName, target, options);
    }
    isValidTask() {
        return _.sum(this.creep.carry) < this.creep.carryCapacity;
    }
    isValidTarget() {
        if (!this.target)
            return false;
        if (isSource(this.target)) {
            return this.target.energy > 0;
        }
        else {
            return this.target.mineralAmount > 0;
        }
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.harvest(this.target);
    }
};
TaskHarvest = __decorate([
    profile
], TaskHarvest);

const healTaskName = 'heal';
let TaskHeal = class TaskHeal extends Task {
    constructor(target, options = {}) {
        super(healTaskName, target, options);
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(HEAL) > 0);
    }
    isValidTarget() {
        return !!this.target && this.target.hits < this.target.hitsMax && this.target.my;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        if (this.creep.pos.isNearTo(this.target)) {
            return this.creep.heal(this.target);
        }
        else {
            this.moveToTarget(1);
        }
        return this.creep.rangedHeal(this.target);
    }
};
TaskHeal = __decorate([
    profile
], TaskHeal);

const invalidTarget = {
    ref: '',
    pos: {
        x: 25,
        y: 25,
        roomName: 'W6N1',
    }
};
let TaskInvalid = class TaskInvalid extends Task {
    constructor() {
        super('INVALID', invalidTarget);
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    work() {
        return OK;
    }
};
TaskInvalid = __decorate([
    profile
], TaskInvalid);

const meleeAttackTaskName = 'meleeAttack';
let TaskMeleeAttack = class TaskMeleeAttack extends Task {
    constructor(target, options = {}) {
        super(meleeAttackTaskName, target, options);
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(ATTACK) > 0;
    }
    isValidTarget() {
        return !!this.target && this.target.hits > 0;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.attack(this.target);
    }
};
TaskMeleeAttack = __decorate([
    profile
], TaskMeleeAttack);

const pickupTaskName = 'pickup';
let TaskPickup = class TaskPickup extends Task {
    constructor(target, options = {}) {
        super('pickup', target, options);
        this.settings.oneShot = true;
    }
    isValidTask() {
        return _.sum(this.creep.carry) < this.creep.carryCapacity;
    }
    isValidTarget() {
        return !!this.target && this.target.amount > 0;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.pickup(this.target);
    }
};
TaskPickup = __decorate([
    profile
], TaskPickup);

const rangedAttackTaskName = 'rangedAttack';
let TaskRangedAttack = class TaskRangedAttack extends Task {
    constructor(target, options = {}) {
        super(rangedAttackTaskName, target, options);
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(RANGED_ATTACK) > 0;
    }
    isValidTarget() {
        return !!this.target && this.target.hits > 0;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.rangedAttack(this.target);
    }
};
TaskRangedAttack = __decorate([
    profile
], TaskRangedAttack);

const CACHE_TIMEOUT = 50;
const SHORT_CACHE_TIMEOUT = 10;
const COSTMATRIX_TIMEOUT = 20;
const PATH_TIMEOUT = 1000;
let $ = class $ {
    static structures(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + 's' + key;
        if (!_cache.structures[cacheKey] || Game.time > _cache.expiration[cacheKey]) {
            _cache.structures[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        else {
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                _cache.structures[cacheKey] = _.compact(_.map(_cache.structures[cacheKey] || [], s => Game.getObjectById(s.id)));
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        return _cache.structures[cacheKey];
    }
    static number(saver, key, callback, timeout = SHORT_CACHE_TIMEOUT) {
        const cacheKey = saver.ref + '#' + key;
        if (_cache.numbers[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            _cache.numbers[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.numbers[cacheKey];
    }
    static numberRecall(saver, key) {
        const cacheKey = saver.ref + '#' + key;
        return _cache.numbers[cacheKey];
    }
    static pos(saver, key, callback, timeout) {
        const cacheKey = saver.ref + 'p' + key;
        if (_cache.roomPositions[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            _cache.roomPositions[cacheKey] = callback();
            if (!timeout)
                timeout = CACHE_TIMEOUT;
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.roomPositions[cacheKey];
    }
    static list(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + 'l' + key;
        if (_cache.lists[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            _cache.lists[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.lists[cacheKey];
    }
    static costMatrix(roomName, key, callback, timeout = COSTMATRIX_TIMEOUT) {
        const cacheKey = roomName + 'm' + key;
        if (_cache.costMatrices[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            _cache.costMatrices[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.costMatrices[cacheKey];
    }
    static costMatrixRecall(roomName, key) {
        const cacheKey = roomName + 'm' + key;
        return _cache.costMatrices[cacheKey];
    }
    static path(fromPos, toPos, opts) {
        return [];
    }
    static set(thing, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = thing.ref + '$' + key;
        if (!_cache.things[cacheKey] || Game.time > _cache.expiration[cacheKey]) {
            _cache.things[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        else {
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                if (_.isArray(_cache.things[cacheKey])) {
                    _cache.things[cacheKey] = _.compact(_.map(_cache.things[cacheKey], s => Game.getObjectById(s.id)));
                }
                else {
                    _cache.things[cacheKey] = Game.getObjectById(_cache.things[cacheKey].id);
                }
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        thing[key] = _cache.things[cacheKey];
    }
    static refresh(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (thing[key]) {
                if (_.isArray(thing[key])) {
                    thing[key] = _.compact(_.map(thing[key], s => Game.getObjectById(s.id)));
                }
                else {
                    thing[key] = Game.getObjectById(thing[key].id);
                }
            }
        });
    }
    static refreshObject(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (_.isObject(thing[key])) {
                for (const prop in thing[key]) {
                    if (_.isArray(thing[key][prop])) {
                        thing[key][prop] = _.compact(_.map(thing[key][prop], s => Game.getObjectById(s.id)));
                    }
                    else {
                        thing[key][prop] = Game.getObjectById(thing[key][prop].id);
                    }
                }
            }
        });
    }
    static refreshRoom(thing) {
        thing.room = Game.rooms[thing.room.name];
    }
};
$ = __decorate([
    profile
], $);

var CombatCreepSetup_1;
const allZeroParts = () => ({
    move: 0,
    attack: 0,
    ranged: 0,
    heal: 0,
    tough: 0,
    work: 0,
    carry: 0,
    claim: 0,
});
const BOOST_EFFECTS = BOOSTS;
const BODYPART_COSTS = _.extend(_.clone(BODYPART_COST), { ranged: BODYPART_COST[RANGED_ATTACK] });
let CombatCreepSetup = CombatCreepSetup_1 = class CombatCreepSetup {
    constructor(roleName, opts, bodyGenerator) {
        this.role = roleName;
        this.opts = opts;
        this.bodyGenerator = bodyGenerator;
        this.cache = {};
    }
    create(colony, useCache = false) {
        if (useCache && this.cache[colony.name] && Game.time < this.cache[colony.name].expiration) {
            return this.cache[colony.name].result;
        }
        const result = this.bodyGenerator(colony, this.opts);
        this.cache[colony.name] = {
            result: result,
            expiration: Game.time + 20,
        };
        return result;
    }
    static getBestBoostsAvailable(colony, opts) {
        const availableBoosts = {};
        if (colony.evolutionChamber) {
            if (opts.bodyRatio.tough && opts.boosts.includes('tough')) {
                const toughBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.tough || 0);
                availableBoosts.tough = colony.evolutionChamber.bestBoostAvailable('tough', toughBoostNeeded);
            }
            if (opts.bodyRatio.heal && opts.boosts.includes('heal')) {
                const healBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.heal || 0);
                availableBoosts.heal = colony.evolutionChamber.bestBoostAvailable('heal', healBoostNeeded);
            }
            if (opts.bodyRatio.ranged && opts.boosts.includes('ranged')) {
                const rangedBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.ranged || 0);
                availableBoosts.ranged = colony.evolutionChamber.bestBoostAvailable('ranged', rangedBoostNeeded);
            }
            if (opts.bodyRatio.attack && opts.boosts.includes('attack')) {
                const attackBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.attack || 0);
                availableBoosts.attack = colony.evolutionChamber.bestBoostAvailable('attack', attackBoostNeeded);
            }
            if (opts.bodyRatio.carry && opts.boosts.includes('carry')) {
                const carryBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.carry || 0);
                availableBoosts.carry = colony.evolutionChamber.bestBoostAvailable('carry', carryBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes('dismantle')) {
                const dismantleBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.dismantle = colony.evolutionChamber.bestBoostAvailable('dismantle', dismantleBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes('upgrade')) {
                const upgradeBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.upgrade = colony.evolutionChamber.bestBoostAvailable('upgrade', upgradeBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes('construct')) {
                const constructBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.construct = colony.evolutionChamber.bestBoostAvailable('construct', constructBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes('harvest')) {
                const harvestBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.harvest = colony.evolutionChamber.bestBoostAvailable('harvest', harvestBoostNeeded);
            }
            if (opts.boosts.includes('move')) {
                const moveBoostNeeded = LAB_BOOST_MINERAL * 50 / 3;
                availableBoosts.move = colony.evolutionChamber.bestBoostAvailable('move', moveBoostNeeded);
            }
        }
        if (_.sum(opts.boosts, b => ['dismantle', 'upgrade', 'construct', 'harvest'].includes(b) ? 1 : 0) > 1) {
            log.warning(`Multiple boost types requested for work part! opts.boosts: ${print(opts.boosts)}`);
        }
        return availableBoosts;
    }
    static generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities, unweightedCarryParts = false) {
        if (partPriorities.includes(rootPart)) {
            log.error(`generateBodyCounts() error: part priorities ${partPriorities} cannot ` +
                `include root part ${rootPart}`);
            return allZeroParts();
        }
        const bodyRatio = _.defaults(_.clone(opts.bodyRatio), allZeroParts());
        const maxParts = _.defaults(_.clone(opts.maxParts), allZeroParts());
        const nonZeroParts = _.filter(_.keys(opts.bodyRatio), part => opts.bodyRatio[part] > 0);
        const maxPartCost = _.max(_.map(nonZeroParts, part => BODYPART_COSTS[part]));
        const bodyCounts = {
            move: 1,
            attack: bodyRatio.attack > 0 ? 1 : 0,
            ranged: bodyRatio.ranged > 0 ? 1 : 0,
            heal: bodyRatio.heal > 0 ? 1 : 0,
            tough: bodyRatio.tough > 0 ? 1 : 0,
            work: bodyRatio.work > 0 ? 1 : 0,
            carry: bodyRatio.carry > 0 ? 1 : 0,
            claim: bodyRatio.claim > 0 ? 1 : 0,
        };
        let cost = 0;
        for (const part in bodyCounts) {
            cost += bodyCounts[part] * BODYPART_COSTS[part];
        }
        while (_.sum(bodyCounts) < MAX_CREEP_SIZE && cost <= colony.room.energyCapacityAvailable - maxPartCost) {
            const weightedParts = unweightedCarryParts ? _.sum(bodyCounts) - bodyCounts.move - bodyCounts.carry
                : _.sum(bodyCounts) - bodyCounts.move;
            if (weightedParts >= moveRatio * bodyCounts.move) {
                bodyCounts.move++;
                cost += BODYPART_COST[MOVE];
            }
            else {
                let nonRootPartAdded = false;
                for (const part of partPriorities) {
                    if (bodyCounts[part] < maxParts[part] &&
                        bodyCounts[part] / bodyCounts[rootPart] < bodyRatio[part] / bodyRatio[rootPart]) {
                        bodyCounts[part]++;
                        cost += BODYPART_COSTS[part];
                        nonRootPartAdded = true;
                        break;
                    }
                }
                if (!nonRootPartAdded) {
                    bodyCounts[rootPart]++;
                    cost += BODYPART_COSTS[rootPart];
                }
            }
        }
        return bodyCounts;
    }
    static arrangeBodyParts(partialBodyCounts, opts) {
        const bodyCounts = _.defaults(partialBodyCounts, {
            move: 1,
            attack: 0,
            ranged: 0,
            heal: 0,
            tough: 0,
            work: 0,
            carry: 0,
            claim: 0,
        });
        const body = [];
        _.forEach(_.range(bodyCounts.tough), i => body.push(TOUGH));
        if (opts.putMoveFirstInBody) {
            _.forEach(_.range(bodyCounts.carry), i => body.push(CARRY));
            _.forEach(_.range(bodyCounts.move - 1), i => body.push(MOVE));
            _.forEach(_.range(bodyCounts.ranged), i => body.push(RANGED_ATTACK));
            _.forEach(_.range(bodyCounts.work), i => body.push(WORK));
            _.forEach(_.range(bodyCounts.attack), i => body.push(ATTACK));
            _.forEach(_.range(bodyCounts.claim), i => body.push(CLAIM));
            _.forEach(_.range(bodyCounts.heal), i => body.push(HEAL));
        }
        else {
            _.forEach(_.range(bodyCounts.carry), i => body.push(CARRY));
            _.forEach(_.range(bodyCounts.ranged), i => body.push(RANGED_ATTACK));
            _.forEach(_.range(bodyCounts.work), i => body.push(WORK));
            _.forEach(_.range(bodyCounts.attack), i => body.push(ATTACK));
            _.forEach(_.range(bodyCounts.claim), i => body.push(CLAIM));
            _.forEach(_.range(bodyCounts.move - 1), i => body.push(MOVE));
            _.forEach(_.range(bodyCounts.heal), i => body.push(HEAL));
        }
        body.push(MOVE);
        return body;
    }
    static generateMeleeAttackerBody(colony, opts) {
        if (!opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No attack!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.ranged) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires ranged body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_MELEE = { attack: 50, tough: 10, heal: 2 };
        opts.maxParts.attack = opts.maxParts.attack || DEFAULT_MAX_PARTS_MELEE.attack;
        opts.maxParts.tough = opts.maxParts.tough || DEFAULT_MAX_PARTS_MELEE.tough;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_MELEE.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ? BOOST_EFFECTS.move[availableBoosts.move].fatigue : 1)
            * opts.moveSpeed;
        opts.bodyRatio.attack = opts.bodyRatio.attack || 1;
        opts.bodyRatio.tough = opts.bodyRatio.tough || 0;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 0;
        const rootPart = 'attack';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    static generateRangedAttackerBody(colony, opts) {
        if (!opts.bodyRatio.ranged) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No ranged!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_RANGED = { ranged: 40, tough: 10, heal: 20 };
        opts.maxParts.ranged = opts.maxParts.ranged || DEFAULT_MAX_PARTS_RANGED.ranged;
        opts.maxParts.tough = opts.maxParts.tough || DEFAULT_MAX_PARTS_RANGED.tough;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_RANGED.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ? BOOST_EFFECTS.move[availableBoosts.move].fatigue : 1)
            * opts.moveSpeed;
        opts.bodyRatio.ranged = opts.bodyRatio.ranged || 1;
        const rootPart = 'ranged';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    static generateHealerBody(colony, opts) {
        if (!opts.bodyRatio.heal) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No heal!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_HEAL = { heal: 40, tough: 10, ranged: 30 };
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_HEAL.heal;
        opts.maxParts.ranged = opts.maxParts.ranged || DEFAULT_MAX_PARTS_HEAL.ranged;
        opts.maxParts.tough = opts.maxParts.tough || DEFAULT_MAX_PARTS_HEAL.tough;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ? BOOST_EFFECTS.move[availableBoosts.move].fatigue : 1)
            * opts.moveSpeed;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 1;
        const rootPart = 'heal';
        const partPriorities = ['tough', 'ranged'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    static generateDismantlerBody(colony, opts) {
        if (!opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No dismantle!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using attack parts requires melee body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_DISMANTLER = { work: 40, tough: 10, ranged: 10, heal: 2 };
        opts.maxParts.work = opts.maxParts.work || DEFAULT_MAX_PARTS_DISMANTLER.work;
        opts.maxParts.ranged = opts.maxParts.ranged || DEFAULT_MAX_PARTS_DISMANTLER.ranged;
        opts.maxParts.tough = opts.maxParts.tough || DEFAULT_MAX_PARTS_DISMANTLER.tough;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_DISMANTLER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ? BOOST_EFFECTS.move[availableBoosts.move].fatigue : 1)
            * opts.moveSpeed;
        opts.bodyRatio.work = opts.bodyRatio.work || 1;
        const rootPart = 'work';
        const partPriorities = ['tough', 'ranged', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    static generateUpgraderBody(colony, opts) {
        if (!opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No dismantle!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_UPGRADER = { work: 50, tough: 10, carry: 20, heal: 2 };
        opts.maxParts.work = opts.maxParts.work || DEFAULT_MAX_PARTS_UPGRADER.work;
        opts.maxParts.tough = opts.maxParts.tough || DEFAULT_MAX_PARTS_UPGRADER.tough;
        opts.maxParts.carry = opts.maxParts.carry || DEFAULT_MAX_PARTS_UPGRADER.carry;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_UPGRADER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ? BOOST_EFFECTS.move[availableBoosts.move].fatigue : 1)
            * opts.moveSpeed;
        opts.bodyRatio.work = opts.bodyRatio.work || 1;
        const rootPart = 'work';
        const partPriorities = ['tough', 'carry', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities, true);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    static generateCarrierBody(colony, opts) {
        if (!opts.bodyRatio.carry) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No carry!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_CARRIER = { carry: 50, tough: 10, heal: 3 };
        opts.maxParts.carry = opts.maxParts.attack || DEFAULT_MAX_PARTS_CARRIER.carry;
        opts.maxParts.tough = opts.maxParts.tough || DEFAULT_MAX_PARTS_CARRIER.tough;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_CARRIER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ? BOOST_EFFECTS.move[availableBoosts.move].fatigue : 1)
            * opts.moveSpeed;
        opts.bodyRatio.carry = opts.bodyRatio.carry || 1;
        opts.bodyRatio.tough = opts.bodyRatio.tough || 0;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 0;
        const rootPart = 'carry';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
};
CombatCreepSetup = CombatCreepSetup_1 = __decorate([
    profile
], CombatCreepSetup);
class ZerglingSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, armored: false, healing: false, bodyOpts: {} });
        const zerglingBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: true,
            bodyRatio: { attack: 30, tough: opts.armored ? 10 : 0, heal: opts.healing ? 2 : 0 },
            maxParts: { attack: 50, tough: 10, heal: 2 },
            boosts: opts.boosted ? ['attack', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, zerglingBodyOpts);
        super(Roles.melee, bodyOpts, CombatCreepSetup.generateMeleeAttackerBody);
    }
}
class HydraliskSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, armored: false, healing: true, bodyOpts: {} });
        const hydraliskBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { ranged: 12, tough: opts.armored ? 3 : 0, heal: opts.healing ? 4 : 0 },
            maxParts: { ranged: 30, tough: 8, heal: 10 },
            boosts: opts.boosted ? ['ranged', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, hydraliskBodyOpts);
        super(Roles.ranged, bodyOpts, CombatCreepSetup.generateRangedAttackerBody);
    }
}
class TransfuserSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, armored: false, withRanged: false, bodyOpts: {} });
        const healerBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { heal: 12, tough: opts.armored ? 3 : 0, ranged: opts.withRanged ? 4 : 0 },
            maxParts: { heal: 30, tough: 8, ranged: 10 },
            boosts: opts.boosted ? ['ranged', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, healerBodyOpts);
        super(Roles.healer, bodyOpts, CombatCreepSetup.generateHealerBody);
    }
}
class LurkerSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, armored: false, healing: false, bodyOpts: {} });
        const lurkerBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                work: 24,
                tough: opts.armored ? 6 : 0,
                ranged: opts.withRanged ? 8 : 0,
                heal: opts.healing ? 2 : 0
            },
            maxParts: { work: 30, tough: 10, ranged: 10, heal: 2 },
            boosts: opts.boosted ? ['dismantle', 'ranged', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, lurkerBodyOptions);
        super(Roles.dismantler, bodyOpts, CombatCreepSetup.generateDismantlerBody);
    }
}
class RavagerSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 0.5, boosted: false, armored: false, healing: false, bodyOpts: {} });
        const ravagerBodyDefaults = {
            moveSpeed: opts.moveSpeed || 0.5,
            putMoveFirstInBody: true,
            bodyRatio: { attack: 30, tough: opts.armored ? 10 : 0, heal: opts.healing ? 2 : 0 },
            maxParts: { attack: 50, tough: 10, heal: 2 },
            boosts: opts.boosted ? ['attack', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, ravagerBodyDefaults);
        super(Roles.bunkerDefender, bodyOpts, CombatCreepSetup.generateMeleeAttackerBody);
    }
}
class RemoteUpgraderSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, bodyOpts: {} });
        const remoteUpgraderBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { work: 8, carry: 1 },
            maxParts: { work: 40, carry: 10 },
            boosts: opts.boosted ? ['upgrade', 'carry', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, remoteUpgraderBodyOptions);
        super(Roles.upgrader, bodyOpts, CombatCreepSetup.generateUpgraderBody);
    }
}
class CarrierSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, healing: false, bodyOpts: {} });
        const carrierBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { carry: 1, heal: opts.healing ? 0.01 : 0 },
            maxParts: { carry: 40, heal: opts.healing ? 1 : 0 },
            boosts: opts.boosted ? ['carry', 'move', 'heal'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, carrierBodyOptions);
        super(Roles.transport, bodyOpts, CombatCreepSetup.generateCarrierBody);
    }
}
global.CombatCreepSetup = CombatCreepSetup;
global.DefaultCombatCreepSetups = {
    zergling: ZerglingSetup,
    hydralisk: HydraliskSetup,
    transfuser: TransfuserSetup,
    lurker: LurkerSetup,
    ravager: RavagerSetup,
    remoteUpgrader: RemoteUpgraderSetup,
    carrier: CarrierSetup,
};

var CreepSetup_1;
function bodyCost(bodyparts) {
    return _.sum(bodyparts, part => BODYPART_COST[part]);
}
function patternCost(setup) {
    return bodyCost(setup.bodySetup.pattern);
}
let CreepSetup = CreepSetup_1 = class CreepSetup {
    constructor(roleName, bodySetup = {}, boosts) {
        this.role = roleName;
        _.defaults(bodySetup, {
            pattern: [],
            sizeLimit: Infinity,
            prefix: [],
            suffix: [],
            proportionalPrefixSuffix: false,
            ordered: true,
        });
        this.bodySetup = bodySetup;
        this.boosts = boosts || [];
        this.cache = {};
    }
    static boosted(setup, boosts) {
        return new CreepSetup_1(setup.role, setup.bodySetup, boosts);
    }
    create(colony, useCache = false) {
        if (useCache && this.cache[colony.name] && Game.time < this.cache[colony.name].expiration) {
            return this.cache[colony.name].result;
        }
        const body = this.generateBody(colony.room.energyCapacityAvailable);
        const bodyCounts = _.countBy(body);
        const boosts = [];
        if (this.boosts.length > 0 && colony.evolutionChamber) {
            for (const boostType of this.boosts) {
                const numParts = bodyCounts[BoostTypeBodyparts[boostType]];
                const bestBoost = colony.evolutionChamber.bestBoostAvailable(boostType, numParts * LAB_BOOST_MINERAL);
                if (bestBoost) {
                    boosts.push(bestBoost);
                }
            }
        }
        const result = {
            body: body,
            boosts: boosts,
        };
        this.cache[colony.name] = {
            result: result,
            expiration: Game.time + 20,
        };
        return result;
    }
    generateBody(availableEnergy) {
        let patternCost, patternLength, numRepeats;
        const prefix = this.bodySetup.prefix;
        const suffix = this.bodySetup.suffix;
        let body = [];
        if (this.bodySetup.proportionalPrefixSuffix) {
            patternCost = bodyCost(prefix) + bodyCost(this.bodySetup.pattern) + bodyCost(suffix);
            patternLength = prefix.length + this.bodySetup.pattern.length + suffix.length;
            const energyLimit = Math.floor(availableEnergy / patternCost);
            const maxPartLimit = Math.floor(MAX_CREEP_SIZE / patternLength);
            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);
        }
        else {
            const extraCost = bodyCost(prefix) + bodyCost(suffix);
            patternCost = bodyCost(this.bodySetup.pattern);
            patternLength = this.bodySetup.pattern.length;
            const energyLimit = Math.floor((availableEnergy - extraCost) / patternCost);
            const maxPartLimit = Math.floor((MAX_CREEP_SIZE - prefix.length - suffix.length) / patternLength);
            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);
        }
        if (numRepeats < 1) {
            log.debug(`body count is 0 role: ${this.role}`);
            numRepeats = 1;
        }
        if (this.bodySetup.proportionalPrefixSuffix) {
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(prefix);
            }
        }
        else {
            body = body.concat(prefix);
        }
        if (this.bodySetup.ordered) {
            for (const part of this.bodySetup.pattern) {
                for (let i = 0; i < numRepeats; i++) {
                    body.push(part);
                }
            }
        }
        else {
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(this.bodySetup.pattern);
            }
        }
        if (this.bodySetup.proportionalPrefixSuffix) {
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(suffix);
            }
        }
        else {
            body = body.concat(suffix);
        }
        return body;
    }
    generateMaxedBody() {
        return this.generateBody(11100);
    }
    getBodyPotential(partType, colony) {
        let energyCapacity = colony.room.energyCapacityAvailable;
        if (colony.spawnGroup) {
            const colonies = _.compact(_.map(colony.spawnGroup.memory.colonies, name => Overmind.colonies[name]));
            energyCapacity = _.max(_.map(colonies, colony => colony.room.energyCapacityAvailable));
        }
        const body = this.generateBody(energyCapacity);
        return _.filter(body, (part) => part == partType).length;
    }
};
CreepSetup = CreepSetup_1 = __decorate([
    profile
], CreepSetup);

const Roles = {
    drone: 'drone',
    filler: 'filler',
    claim: 'infestor',
    pioneer: 'pioneer',
    manager: 'manager',
    queen: 'queen',
    scout: 'changeling',
    transport: 'transport',
    worker: 'worker',
    upgrader: 'upgrader',
    praiser: 'praiser',
    guardMelee: 'broodling',
    melee: 'zergling',
    ranged: 'hydralisk',
    rangedDistractor: 'babbylisk',
    healer: 'transfuser',
    dismantler: 'lurker',
    bunkerDefender: 'ravager',
    drill: 'drill',
    coolant: 'coolant',
    roomPoisoner: 'poisoner',
    strongholdKiller: 'strongman',
};
const Setups = {
    drones: {
        extractor: new CreepSetup(Roles.drone, {
            pattern: [WORK, WORK, MOVE],
            sizeLimit: Infinity,
            prefix: [CARRY, CARRY]
        }),
        miners: {
            default: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 3,
            }),
            standard: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, WORK],
                sizeLimit: 1,
            }),
            standardCPU: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, MOVE, WORK],
                sizeLimit: 1,
            }),
            linkOptimized: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, CARRY, MOVE, MOVE, WORK],
                sizeLimit: 4,
            }),
            emergency: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 1,
            }),
            double: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE],
                sizeLimit: 2,
            }),
            sourceKeeper: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 5,
            })
        }
    },
    filler: new CreepSetup(Roles.filler, {
        pattern: [CARRY, CARRY, MOVE],
        sizeLimit: 1,
    }),
    infestors: {
        claim: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 1
        }),
        fastClaim: new CreepSetup(Roles.claim, {
            pattern: [MOVE, MOVE, MOVE, MOVE, CLAIM, MOVE],
            sizeLimit: 1
        }),
        reserve: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 4,
        }),
        controllerAttacker: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: Infinity,
        }),
    },
    pioneers: {
        armored: new CreepSetup(Roles.pioneer, {
            pattern: [MOVE, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
            prefix: [MOVE, MOVE],
            proportionalPrefixSuffix: true,
            ordered: false
        }),
        default: new CreepSetup(Roles.pioneer, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
    managers: {
        default: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, CARRY, CARRY, MOVE],
            sizeLimit: 3,
        }),
        twoPart: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: 8,
        }),
        stationary: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY],
            sizeLimit: 16,
        }),
        stationary_work: new CreepSetup(Roles.manager, {
            pattern: [WORK, WORK, WORK, WORK, CARRY, CARRY],
            sizeLimit: 8,
        }),
    },
    queens: {
        default: new CreepSetup(Roles.queen, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.queen, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
    scout: new CreepSetup(Roles.scout, {
        pattern: [MOVE],
        sizeLimit: 1,
    }),
    transporters: {
        default: new CreepSetup(Roles.transport, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.transport, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        boosted: new CarrierSetup({ boosted: true }),
    },
    workers: {
        inhouse: new CreepSetup(Roles.worker, {
            pattern: [WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
    upgraders: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        rcl8: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: 5,
        }),
        rcl8_boosted: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: 5,
        }, ['upgrade']),
        remote: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        remote_boosted: new RemoteUpgraderSetup({ boosted: true }),
    },
    roomPoisoner: new CreepSetup(Roles.roomPoisoner, {
        pattern: [WORK, CARRY, MOVE, MOVE],
        sizeLimit: 4,
    }),
    praisers: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    }
};
const CombatSetups = {
    zerglings: {
        default: new ZerglingSetup(),
        healing: new ZerglingSetup({ healing: true }),
        boosted: {
            default: new ZerglingSetup({ boosted: true }),
            armored: new ZerglingSetup({ boosted: true, armored: true }),
            armoredHealing: new ZerglingSetup({ boosted: true, armored: true, healing: true }),
        },
        sourceKeeper: new CreepSetup(Roles.melee, {
            pattern: [MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, HEAL, MOVE],
            sizeLimit: Infinity,
        }),
    },
    hydralisks: {
        default: new HydraliskSetup(),
        noHeal: new HydraliskSetup({ healing: false }),
        boosted: {
            default: new HydraliskSetup({ boosted: true }),
            armored: new HydraliskSetup({ boosted: true, armored: true }),
            noHeal: new HydraliskSetup({ boosted: true, healing: false }),
        },
        sourceKeeper: new CreepSetup(Roles.ranged, {
            pattern: [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, HEAL, HEAL, MOVE],
            sizeLimit: Infinity,
        }),
    },
    transfusers: {
        default: new TransfuserSetup(),
        boosted: {
            default: new TransfuserSetup({ boosted: true }),
            armored: new TransfuserSetup({ boosted: true, armored: true }),
        }
    },
    broodlings: {
        early: new CreepSetup(Roles.guardMelee, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.guardMelee, {
            pattern: [ATTACK, ATTACK, MOVE, MOVE, ATTACK, ATTACK, MOVE, MOVE, MOVE, HEAL],
            sizeLimit: Infinity,
        }),
    },
    bunkerDefender: {
        default: new RavagerSetup(),
        boosted: new RavagerSetup({ boosted: true }),
    },
    dismantlers: {
        default: new CreepSetup(Roles.dismantler, {
            pattern: [WORK, MOVE],
            sizeLimit: Infinity,
        }),
        attackDismantlers: new CreepSetup(Roles.dismantler, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        armored: new CreepSetup(Roles.dismantler, {
            pattern: [TOUGH, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_armored_T3: new CreepSetup(Roles.dismantler, {
            pattern: [TOUGH, TOUGH, WORK, WORK, WORK, WORK, WORK, WORK, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
    distractors: {
        ranged: new CreepSetup(Roles.rangedDistractor, {
            pattern: [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, MOVE],
            sizeLimit: 1,
        }),
    },
    drill: {
        default: new CreepSetup(Roles.drill, {
            pattern: [MOVE, ATTACK, ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
    },
    coolant: {
        default: new CreepSetup(Roles.coolant, {
            pattern: [HEAL, MOVE],
            sizeLimit: Infinity,
        }),
        small: new CreepSetup(Roles.coolant, {
            pattern: [HEAL, MOVE],
            sizeLimit: 16,
        }),
    },
    strongholdKiller: {
        1: new CreepSetup(Roles.strongholdKiller, {
            pattern: [TOUGH, TOUGH,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                HEAL, HEAL, HEAL, HEAL,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: 1,
        }),
        2: new CreepSetup(Roles.strongholdKiller, {
            pattern: [TOUGH, TOUGH, TOUGH, TOUGH,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: 1,
        }),
        3: new CreepSetup(Roles.strongholdKiller, {
            pattern: [TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: 1,
        }),
        4: new CreepSetup(Roles.strongholdKiller, {
            pattern: [TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: 1,
        }),
    }
};

var Priority;
(function (Priority) {
    Priority[Priority["Critical"] = 0] = "Critical";
    Priority[Priority["High"] = 1] = "High";
    Priority[Priority["NormalHigh"] = 2] = "NormalHigh";
    Priority[Priority["Normal"] = 3] = "Normal";
    Priority[Priority["NormalLow"] = 4] = "NormalLow";
    Priority[Priority["Low"] = 5] = "Low";
})(Priority || (Priority = {}));
function blankPriorityQueue() {
    const queue = {};
    for (const priority in Priority) {
        queue[priority] = [];
    }
    return queue;
}

let TransportRequestGroup = class TransportRequestGroup {
    constructor() {
        this.refresh();
    }
    refresh() {
        this.supply = blankPriorityQueue();
        this.withdraw = blankPriorityQueue();
        this.supplyByID = {};
        this.withdrawByID = {};
    }
    needsSupplying(priorityThreshold) {
        for (const priority in this.supply) {
            if (priorityThreshold != undefined && parseInt(priority, 10) > priorityThreshold) {
                continue;
            }
            if (this.supply[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    needsWithdrawing(priorityThreshold) {
        for (const priority in this.withdraw) {
            if (priorityThreshold != undefined && parseInt(priority, 10) > priorityThreshold) {
                continue;
            }
            if (this.withdraw[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    getPrioritizedClosestRequest(pos, type, filter) {
        const requests = type == 'withdraw' ? this.withdraw : this.supply;
        for (const priority in requests) {
            const targets = _.map(requests[priority], request => request.target);
            const target = pos.findClosestByRangeThenPath(targets);
            if (target) {
                let searchRequests;
                if (filter) {
                    searchRequests = _.filter(requests[priority], req => filter(req));
                }
                else {
                    searchRequests = requests[priority];
                }
                return _.find(searchRequests, request => request.target.ref == target.ref);
            }
        }
    }
    requestInput(target, priority = Priority.Normal, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (opts.amount == undefined) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
        };
        if (opts.amount > 0) {
            this.supply[priority].push(req);
            if (!this.supplyByID[target.id])
                this.supplyByID[target.id] = [];
            this.supplyByID[target.id].push(req);
        }
    }
    requestOutput(target, priority = Priority.Normal, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (opts.amount == undefined) {
            opts.amount = this.getOutputAmount(target, opts.resourceType);
        }
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
        };
        if (opts.amount > 0) {
            this.withdraw[priority].push(req);
            if (!this.withdrawByID[target.id])
                this.withdrawByID[target.id] = [];
            this.withdrawByID[target.id].push(req);
        }
    }
    getInputAmount(target, resourceType) {
        return target.store.getFreeCapacity(resourceType) || 0;
    }
    getOutputAmount(target, resourceType) {
        return target.store.getUsedCapacity(resourceType) || 0;
    }
    summarize(ignoreEnergy = false) {
        console.log(`Supply requests ==========================`);
        for (const priority in this.supply) {
            if (this.supply[priority].length > 0) {
                console.log(`Priority: ${priority}`);
            }
            for (const request of this.supply[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY)
                    continue;
                console.log(`    targetID: ${request.target.ref}  amount: ${request.amount}  ` +
                    `resourceType: ${request.resourceType}`);
            }
        }
        console.log(`Withdraw requests ========================`);
        for (const priority in this.withdraw) {
            if (this.withdraw[priority].length > 0) {
                console.log(`Priority: ${priority}`);
            }
            for (const request of this.withdraw[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY)
                    continue;
                console.log(`    targetID: ${request.target.ref}  amount: ${request.amount}  ` +
                    `resourceType: ${request.resourceType}`);
            }
        }
    }
};
TransportRequestGroup = __decorate([
    profile
], TransportRequestGroup);

const LOG_STATS_INTERVAL = 8;
let Stats = class Stats {
    static clean() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            const protectedKeys = [
                'persistent',
            ];
            for (const key in Memory.stats) {
                if (!protectedKeys.includes(key)) {
                    delete Memory.stats[key];
                }
            }
        }
    }
    static log(key, value, truncateNumbers = true) {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            if (truncateNumbers && value != undefined) {
                const decimals = 5;
                if (typeof value == 'number') {
                    value = value.truncate(decimals);
                }
                else {
                    for (const i in value) {
                        value[i] = value[i].truncate(decimals);
                    }
                }
            }
            Mem.setDeep(Memory.stats, key, value);
        }
    }
    static run() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            Memory.stats['cpu.heapStatistics'] = Game.cpu.getHeapStatistics();
            this.log('gcl.progress', Game.gcl.progress);
            this.log('gcl.progressTotal', Game.gcl.progressTotal);
            this.log('gcl.level', Game.gcl.level);
            this.log('memory.used', RawMemory.get().length);
            this.log('cpu.limit', Game.cpu.limit);
            this.log('cpu.bucket', Game.cpu.bucket);
        }
        const used = Game.cpu.getUsed();
        this.log('cpu.getUsed', used);
        Memory.stats.persistent.avgCPU = ema(used, Memory.stats.persistent.avgCPU, 100);
        Memory.stats.persistent.empireAge = Memory.tick;
        Memory.stats.persistent.build = Memory.build;
    }
};
Stats = __decorate([
    profile
], Stats);

var Mem_1;
var Autonomy;
(function (Autonomy) {
    Autonomy[Autonomy["Manual"] = 0] = "Manual";
    Autonomy[Autonomy["SemiAutomatic"] = 1] = "SemiAutomatic";
    Autonomy[Autonomy["Automatic"] = 2] = "Automatic";
})(Autonomy || (Autonomy = {}));
function getAutonomyLevel() {
    switch (Memory.settings.operationMode) {
        case ('manual'):
            return Autonomy.Manual;
        case ('semiautomatic'):
            return Autonomy.SemiAutomatic;
        case ('automatic'):
            return Autonomy.Automatic;
        default:
            log.warning(`ERROR: ${Memory.settings.operationMode} is not a valid operation mode! ` +
                `Defaulting to ${DEFAULT_OPERATION_MODE}; use setMode() to change.`);
            Memory.settings.operationMode = DEFAULT_OPERATION_MODE;
            return getAutonomyLevel();
    }
}
let lastMemory;
let lastTime = 0;
const MAX_BUCKET = 2000;
const HEAP_CLEAN_FREQUENCY = 200;
const BUCKET_CLEAR_CACHE = 7000;
const BUCKET_CPU_HALT = 1000;
let Mem = Mem_1 = class Mem {
    static shouldRun() {
        let shouldRun = true;
        if (!isIVM()) {
            log.warning(`Overmind requires isolated-VM to run. Change settings at screeps.com/a/#!/account/runtime`);
            shouldRun = false;
        }
        if (USE_SCREEPS_PROFILER && Game.time % 10 == 0) {
            log.warning(`Profiling is currently enabled; only ${PROFILER_COLONY_LIMIT} colonies will be run!`);
        }
        if (Game.cpu.bucket < 500 && Game.shard.name == "shard3") {
            if (_.keys(Game.spawns).length > 1 && !Memory.resetBucket && !Memory.haltTick) {
                log.warning(`CPU bucket is critically low (${Game.cpu.bucket})! Starting CPU reset routine.`);
                Memory.resetBucket = true;
                Memory.haltTick = Game.time + 1;
            }
            else {
                log.info(`CPU bucket is too low (${Game.cpu.bucket}). Postponing operation until bucket reaches 500.`);
            }
            shouldRun = false;
        }
        if (Memory.resetBucket) {
            if (Game.cpu.bucket < MAX_BUCKET - Game.cpu.limit) {
                log.info(`Operation suspended until bucket recovery. Bucket: ${Game.cpu.bucket}/${MAX_BUCKET}`);
                shouldRun = false;
            }
            else {
                delete Memory.resetBucket;
            }
        }
        if (Memory.haltTick) {
            if (Memory.haltTick == Game.time) {
                if (Game.cpu.halt) {
                    Memory.build--;
                    Game.cpu.halt();
                }
                shouldRun = false;
            }
            else if (Memory.haltTick < Game.time) {
                delete Memory.haltTick;
            }
        }
        return shouldRun;
    }
    static load() {
        if (lastTime && lastMemory && Game.time == lastTime + 1) {
            delete global.Memory;
            global.Memory = lastMemory;
            RawMemory._parsed = lastMemory;
        }
        else {
            Memory.rooms;
            lastMemory = RawMemory._parsed;
            Memory.stats.persistent.lastMemoryReset = Game.time;
        }
        lastTime = Game.time;
        if (!global.GLOBAL_AGE) {
            global.GLOBAL_AGE = 0;
        }
        global.GLOBAL_AGE++;
        Memory.stats.persistent.globalAge = global.GLOBAL_AGE;
    }
    static garbageCollect(quick) {
        if (!global.gc) {
            return;
        }
        const start = Game.cpu.getUsed();
        global.gc(quick);
        log.debug(`Running ${quick ? 'quick' : 'FULL'} garbage collection. ` +
            `Elapsed time: ${Game.cpu.getUsed() - start}.`);
    }
    static wrap(memory, memName, getDefaults = () => ({})) {
        if (memory[memName] === undefined) {
            memory[memName] = getDefaults();
        }
        else if (Game.time == LATEST_GLOBAL_RESET_TICK) {
            _.defaultsDeep(memory[memName], getDefaults());
        }
        return memory[memName];
    }
    static _setDeep(object, keys, value) {
        const key = _.first(keys);
        keys = _.drop(keys);
        if (keys.length == 0) {
            object[key] = value;
            return;
        }
        else {
            if (!object[key]) {
                object[key] = {};
            }
            return Mem_1._setDeep(object[key], keys, value);
        }
    }
    static setDeep(object, keyString, value) {
        const keys = keyString.split('.');
        return Mem_1._setDeep(object, keys, value);
    }
    static getDefaultMemory() {
        return {
            tick: Game.time,
            build: 0,
            Overmind: {},
            combatPlanner: {},
            profiler: {},
            overseer: {},
            roomIntel: {},
            colonies: {},
            rooms: {},
            creeps: {},
            powerCreeps: {},
            flags: {},
            spawns: {},
            pathing: { distances: {} },
            constructionSites: {},
            stats: {
                persistent: {},
            },
            playerCreepTracker: {},
            settings: {
                signature: DEFAULT_OVERMIND_SIGNATURE,
                operationMode: DEFAULT_OPERATION_MODE,
                log: {},
                enableVisuals: true,
                resourceCollectionMode: 0,
                allies: ALLIES,
                powerCollection: {
                    enabled: true,
                    maxRange: 5,
                    minPower: 5000,
                    minEnergy: 100000,
                },
                autoPoison: {
                    enabled: false,
                    maxRange: 4,
                    maxConcurrent: 1,
                },
            },
        };
    }
    static format() {
        _.defaultsDeep(Memory, Mem_1.getDefaultMemory());
        Memory.build++;
        this.initGlobalMemory();
    }
    static initGlobalMemory() {
        const defaultGlobalCache = {
            accessed: {},
            expiration: {},
            structures: {},
            numbers: {},
            lists: {},
            costMatrices: {},
            roomPositions: {},
            things: {},
        };
        global._cache = defaultGlobalCache;
    }
    static clean() {
        this.cleanHeap();
        this.cleanCreeps();
        this.cleanFlags();
        this.cleanColonies();
        this.cleanPathingMemory();
        this.cleanConstructionSites();
        Stats.clean();
    }
    static cleanHeap() {
        if (Game.time % HEAP_CLEAN_FREQUENCY == HEAP_CLEAN_FREQUENCY - 3) {
            if (Game.cpu.bucket < BUCKET_CPU_HALT && Game.cpu.halt !== undefined) {
                Memory.build--;
                Game.cpu.halt();
            }
            else if (Game.cpu.bucket < BUCKET_CLEAR_CACHE) {
                delete global._cache;
                this.initGlobalMemory();
            }
        }
    }
    static cleanCreeps() {
        for (const name in Memory.creeps) {
            if (!Game.creeps[name]) {
                delete Memory.creeps[name];
                delete global[name];
            }
        }
    }
    static cleanFlags() {
        for (const name in Memory.flags) {
            if (!Game.flags[name]) {
                delete Memory.flags[name];
                delete global[name];
            }
        }
    }
    static cleanColonies() {
        for (const name in Memory.colonies) {
            const room = Game.rooms[name];
            if (!(room && room.my)) {
                if (!Memory.colonies[name].persistent) {
                    delete Memory.colonies[name];
                    delete global[name];
                }
            }
        }
    }
    static cleanConstructionSites() {
        if (Game.time % 20 == 0) {
            const CONSTRUCTION_SITE_TIMEOUT = 100000;
            const UNBUILT_CONSTRUCTION_SITE_TIMEOUT = 1000;
            for (const id in Game.constructionSites) {
                const site = Game.constructionSites[id];
                if (!Memory.constructionSites[id]) {
                    Memory.constructionSites[id] = Game.time;
                }
                else if (Game.time - Memory.constructionSites[id] >= CONSTRUCTION_SITE_TIMEOUT) {
                    site.remove();
                }
                else if (site.progress == 0 &&
                    Game.time - Memory.constructionSites[id] >= UNBUILT_CONSTRUCTION_SITE_TIMEOUT) {
                    site.remove();
                }
                if (site && site.pos.isVisible && site.pos.lookForStructure(site.structureType)) {
                    site.remove();
                }
            }
            for (const id in Memory.constructionSites) {
                if (!Game.constructionSites[id]) {
                    delete Memory.constructionSites[id];
                }
            }
        }
    }
    static cleanPathingMemory() {
        const CLEAN_FREQUENCY = 5;
        if (Game.time % CLEAN_FREQUENCY == 0) {
            const distanceCleanProbability = 0.001 * CLEAN_FREQUENCY;
            const weightedDistanceCleanProbability = 0.01 * CLEAN_FREQUENCY;
            for (const pos1Name in Memory.pathing.distances) {
                if (_.isEmpty(Memory.pathing.distances[pos1Name])) {
                    delete Memory.pathing.distances[pos1Name];
                }
                else {
                    for (const pos2Name in Memory.pathing.distances[pos1Name]) {
                        if (Math.random() < distanceCleanProbability) {
                            delete Memory.pathing.distances[pos1Name][pos2Name];
                        }
                    }
                }
            }
        }
    }
};
Mem = Mem_1 = __decorate([
    profile
], Mem);

class Energetics {
    static lowPowerMode(colony) {
        if (colony.stage == ColonyStage.Adult) {
            if (_.sum(colony.storage.store) > this.settings.storage.total.cap &&
                colony.terminal && _.sum(colony.terminal.store) > this.settings.terminal.total.cap) {
                return true;
            }
        }
        return false;
    }
}
Energetics.settings = {
    storage: {
        total: {
            cap: STORAGE_CAPACITY - 100000,
            tolerance: 5000,
        },
        energy: {
            destroyTerminalThreshold: 200000
        }
    },
    terminal: {
        total: {
            cap: TERMINAL_CAPACITY - 50000
        },
        energy: {
            sendSize: 25000,
            inThreshold: 25000,
            outThreshold: 100000,
            equilibrium: 50000,
            tolerance: 5000,
            tradeAmount: 10000,
        },
    },
};

let OverlordPriority = {
    emergency: {
        bootstrap: 1
    },
    core: {
        queen: 100,
        manager: 101,
    },
    powerCreeps: {
        default: 150,
    },
    defense: {
        meleeDefense: 200,
        rangedDefense: 201,
    },
    outpostDefense: {
        outpostDefense: 250,
        guard: 251,
    },
    warSpawnCutoff: 299,
    offense: {
        destroy: 300,
        healPoint: 301,
        siege: 302,
        controllerAttack: 305,
    },
    colonization: {
        claim: 400,
        pioneer: 450,
        remoteUpgrading: 610,
    },
    priorityOwnedRoom: {
        priorityUpgrade: 450,
        priorityTransport: 451,
    },
    ownedRoom: {
        firstTransport: 400,
        mine: 401,
        work: 503,
        mineralRCL8: 503,
        transport: 402,
        mineral: 505,
    },
    outpostOffense: {
        harass: 560,
        roomPoisoner: 561,
    },
    upgrading: {
        upgrade: 600,
    },
    collectionUrgent: {
        haul: 700
    },
    throttleThreshold: 799,
    scouting: {
        stationary: 400,
        randomWalker: 400
    },
    remoteRoom: {
        reserve: 402,
        mine: 403,
        roomIncrement: 5,
    },
    remoteSKRoom: {
        sourceReaper: 1000,
        mineral: 1001,
        mine: 1002,
        roomIncrement: 5,
    },
    powerMine: {
        cool: 1050,
        drill: 1051,
        roomIncrement: 5
    },
    tasks: {
        haul: 1100,
        dismantle: 1101
    },
    default: 99999
};

var TraderJoe_1;
const getDefaultTraderMemory = () => ({
    cache: {
        sell: {},
        buy: {},
        energyPrice: {
            sell: 0.1,
            buy: 0.1,
        },
        history: {},
        tick: 0,
    },
    canceledOrders: []
});
const getDefaultTraderStats = () => ({
    credits: 0,
    bought: {},
    sold: {},
});
const maxMarketPrices = {
    default: 5.0,
    [RESOURCE_HYDROGEN]: 0.3,
    [RESOURCE_OXYGEN]: 0.25,
    [RESOURCE_UTRIUM]: 0.3,
    [RESOURCE_LEMERGIUM]: 0.25,
    [RESOURCE_KEANIUM]: 0.25,
    [RESOURCE_ZYNTHIUM]: 0.25,
    [RESOURCE_CATALYST]: 0.5,
    [RESOURCE_ENERGY]: 0.05,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: 1.2,
};
const ERR_NO_ORDER_TO_BUY_FROM = -101;
const ERR_NO_ORDER_TO_SELL_TO = -102;
const ERR_INSUFFICIENT_ENERGY_IN_TERMINAL = -103;
const ERR_NOT_ENOUGH_MARKET_DATA = -104;
const ERR_TOO_MANY_ORDERS_OF_TYPE = -105;
const ERR_SELL_DIRECT_PRICE_TOO_LOW = -106;
const ERR_BUY_DIRECT_PRICE_TOO_HIGH = -107;
const ERR_CREDIT_THRESHOLDS = -108;
const ERR_DONT_BUY_REACTION_INTERMEDIATES = -109;
const ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS = -110;
const defaultTradeOpts = {
    preferDirect: false,
    flexibleAmount: true,
    ignoreMinAmounts: false,
    ignorePriceChecksForDirect: false,
    dryRun: false,
};
let TraderJoe = TraderJoe_1 = class TraderJoe {
    constructor() {
        this.name = 'TradeNetwork';
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(Memory.Overmind, 'trader', getDefaultTraderMemory);
        this.stats = Mem.wrap(Memory.stats.persistent, 'trader', getDefaultTraderStats);
        this.notifications = [];
        this.ordersPlacedThisTick = 0;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert('TradeNetwork:', args);
        }
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    priceOf(mineralType) {
        if (this.memory.cache.history[mineralType]) {
            return this.memory.cache.history[mineralType].avg;
        }
        else {
            return Infinity;
        }
    }
    buildMarketCache(verbose = false, orderThreshold = 1000) {
        this.debug('Building market cache');
        this.invalidateMarketCache();
        const myActiveOrderIDs = _.map(_.filter(Game.market.orders, order => order.active), order => order.id);
        const allOrders = Game.market.getAllOrders(order => !myActiveOrderIDs.includes(order.id) &&
            order.amount >= orderThreshold);
        const groupedBuyOrders = _.groupBy(_.filter(allOrders, o => o.type == ORDER_BUY), o => o.resourceType);
        const groupedSellOrders = _.groupBy(_.filter(allOrders, o => o.type == ORDER_SELL), o => o.resourceType);
        for (const resourceType in groupedBuyOrders) {
            const prices = _.map(groupedBuyOrders[resourceType], o => o.price);
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose)
                console.log(`${resourceType} BUY: high: ${high}  low: ${low}`);
            this.memory.cache.buy[resourceType] = { high: high, low: low };
        }
        for (const resourceType in groupedSellOrders) {
            const prices = _.map(groupedSellOrders[resourceType], o => o.price);
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose)
                console.log(`${resourceType} SELL: high: ${high}  low: ${low}`);
            this.memory.cache.sell[resourceType] = { high: high, low: low };
        }
        this.memory.cache.tick = Game.time;
    }
    buildMarketHistoryCache() {
        this.debug('Building market history cache');
        const history = Game.market.getHistory();
        const historyByResource = _.groupBy(history, hist => hist.resourceType);
        for (const resource in historyByResource) {
            const resourceHistory = _.sortBy(historyByResource[resource], hist => hist.date);
            const prices = _.map(resourceHistory, hist => hist.avgPrice);
            const avg = _.last(resourceHistory).avgPrice;
            const std = _.last(resourceHistory).stddevPrice;
            const avg14 = _.sum(resourceHistory, hist => hist.avgPrice * hist.volume) /
                _.sum(resourceHistory, hist => hist.volume);
            const std14 = Math.sqrt(_.sum(resourceHistory, h => h.volume * (h.avgPrice - avg14) ** 2 + h.stddevPrice ** 2) /
                _.sum(resourceHistory, h => h.volume));
            this.memory.cache.history[resource] = {
                avg, std, avg14, std14
            };
        }
    }
    computeEffectiveEnergyPrices() {
        const energyOrders = _(Game.market.getAllOrders({ resourceType: RESOURCE_ENERGY }))
            .filter(order => order.amount >= 5000)
            .groupBy(order => order.type).value();
        const sellOrders = energyOrders[ORDER_SELL];
        const buyOrders = energyOrders[ORDER_BUY];
        for (const colony of _.sample(getAllColonies(), 5)) {
            const room = colony.room.name;
            const sellDirectPrice = maxBy(buyOrders, order => order.price - this.marginalTransactionPrice(order, room));
            const buyDirectPrice = minBy(sellOrders, order => order.price + this.marginalTransactionPrice(order, room));
            const sellOrderPrice = this.computeCompetitivePrice(ORDER_SELL, RESOURCE_ENERGY, room);
            const buyOrderPrice = this.computeCompetitivePrice(ORDER_BUY, RESOURCE_ENERGY, room);
        }
    }
    invalidateMarketCache() {
        this.memory.cache = getDefaultTraderMemory().cache;
    }
    getExistingOrders(type, resource, roomName) {
        let orders;
        if (roomName) {
            orders = _.filter(Game.market.orders, order => order.type == type &&
                (order.resourceType == resource || resource == 'any') &&
                order.roomName == roomName);
            if (orders.length > 1 && resource != 'any') {
                log.error(`Multiple orders for ${resource} detected in ${printRoomName(roomName)}!`);
            }
        }
        else {
            orders = _.filter(Game.market.orders, order => order.type == type &&
                (order.resourceType == resource || resource == 'any'));
        }
        return orders;
    }
    isOrderMine(order) {
        return Game.rooms[order.roomName] && Game.rooms[order.roomName].my;
    }
    marginalTransactionPrice(order, dealerRoomName) {
        if (order.roomName) {
            const transferCost = Game.market.calcTransactionCost(10000, order.roomName, dealerRoomName) / 10000;
            const energyPriceGuess = 0.55 * this.memory.cache.history.energy.avg14;
            const energyToCreditMultiplier = Math.min(energyPriceGuess, 0.1);
            return transferCost * energyToCreditMultiplier;
        }
        else {
            log.error(`order.roomName is unspecified!`);
            return Infinity;
        }
    }
    getPriceForBaseIngredients(resource) {
        const ingredients = Abathur.enumerateReactionBaseIngredients(resource);
        if (ingredients.length > 0) {
            return _.sum(ingredients, res => this.memory.cache.history[res] ? this.memory.cache.history[res].avg14 || Infinity : Infinity);
        }
        else {
            if (this.memory.cache.history[resource]) {
                return this.memory.cache.history[resource].avg14;
            }
            else {
                return Infinity;
            }
        }
    }
    computeCompetitivePrice(type, resource, room) {
        const priceForBaseResources = this.getPriceForBaseIngredients(resource);
        if (priceForBaseResources == 0 || priceForBaseResources == Infinity) {
            log.error(`Cannot get base ingredient price for ${resource}!`);
            return Infinity;
        }
        const allOrdersOfResource = _.groupBy(Game.market.getAllOrders({ resourceType: resource }), 'type');
        const allBuyOrders = allOrdersOfResource[ORDER_BUY];
        const allSellOrders = allOrdersOfResource[ORDER_SELL];
        const highestBuyOrder = maxBy(allBuyOrders, o => o.amount < 100 || this.isOrderMine(o) ? false : o.price - this.marginalTransactionPrice(o, room));
        const lowestSellOrder = minBy(allSellOrders, o => o.amount < 100 || this.isOrderMine(o) ? false : o.price + this.marginalTransactionPrice(o, room));
        if (!highestBuyOrder || !lowestSellOrder) {
            log.error(`No buy orders or no sell orders for ${resource}!`);
            return Infinity;
        }
        const adjustMagnitude = 0.1;
        let adjustment = 1;
        const existingOrder = _.first(this.getExistingOrders(ORDER_SELL, resource, room));
        if (existingOrder) {
            const timeOnMarket = Game.time - existingOrder.created;
            const orderDiscountTimescale = 50000;
            adjustment = (adjustment + timeOnMarket / orderDiscountTimescale) / 2;
        }
        if (type == ORDER_SELL) {
            const discountFactor = 1 - adjustment * adjustMagnitude;
            const marketRate = Math.max(lowestSellOrder.price, highestBuyOrder.price);
            const price = marketRate * discountFactor;
            this.debug(`Candidate price to ${type} ${resource} in ${printRoomName(room)}: ${price}`);
            if (price > lowestSellOrder.price) {
            }
            if ((!Abathur.isBaseMineral(resource) && price < priceForBaseResources) ||
                (Abathur.isBaseMineral(resource) && price < priceForBaseResources / 2) ||
                price < 0) {
                return Infinity;
            }
            else {
                return price;
            }
        }
        else {
            const outbidFactor = 1 + adjustment * adjustMagnitude;
            const marketRate = Math.min(highestBuyOrder.price, lowestSellOrder.price);
            const price = marketRate * outbidFactor;
            this.debug(`Candidate price to ${type} ${resource} in ${printRoomName(room)}: ${price}`);
            if (price < highestBuyOrder.price) {
            }
            const maxMarkupWillingToBuyFrom = 3;
            if (price > priceForBaseResources * maxMarkupWillingToBuyFrom) {
                return Infinity;
            }
            else {
                return price;
            }
        }
    }
    ordersProcessedThisTick() {
        return Game.time % 10 == 5;
    }
    maintainOrder(terminal, type, resource, amount, opts) {
        this.debug(`maintain ${type} order for ${terminal.room.print}: ${amount} ${resource}`);
        if (!this.ordersProcessedThisTick()) {
            return OK;
        }
        if (type == ORDER_SELL) {
            amount = Math.min(amount, TraderJoe_1.settings.market.orders.maxBuyOrderAmount);
        }
        else {
            amount = Math.min(amount, TraderJoe_1.settings.market.orders.maxSellOrderAmount);
        }
        const minAmount = type == ORDER_BUY ? TraderJoe_1.settings.market.orders.minBuyOrderAmount
            : TraderJoe_1.settings.market.orders.minSellOrderAmount;
        if (amount < minAmount && !opts.ignoreMinAmounts) {
            this.debug(`amount ${amount} less than min amount ${minAmount}; no action taken`);
            return NO_ACTION;
        }
        const existingOrder = _.first(this.getExistingOrders(type, resource, terminal.room.name));
        if (existingOrder) {
            const price = +this.computeCompetitivePrice(type, resource, terminal.room.name)
                .toFixed(3);
            if (price == Infinity || price == 0) {
                log.warning(`TradeNetwork: sanity checks not passed to handle existing ${type} order ${resource} ` +
                    `in ${printRoomName(terminal.room.name)}!`);
                return ERR_NOT_ENOUGH_MARKET_DATA;
            }
            const ratio = existingOrder.price / price;
            const tolerance = 0.03;
            const normalFluctuation = (1 + tolerance > ratio && ratio > 1 - tolerance);
            if (amount > existingOrder.remainingAmount && normalFluctuation) {
                const addAmount = amount - existingOrder.remainingAmount;
                const ret = Game.market.extendOrder(existingOrder.id, addAmount);
                this.notify(`${terminal.room.print}: extending ${type} order for ${resource} by ${addAmount}.` +
                    ` Response: ${ret}`);
                return ret;
            }
            if (!normalFluctuation && Math.random() < 1 / 2000) {
                const ret = Game.market.changeOrderPrice(existingOrder.id, price);
                this.notify(`${terminal.room.print}: changing ${type} order price for ${resource} from ` +
                    `${existingOrder.price} to ${price}. Response: ${ret}`);
                return ret;
            }
            return OK;
        }
        else {
            if (this.ordersPlacedThisTick > TraderJoe_1.settings.market.orders.maxOrdersPlacedPerTick) {
                return NO_ACTION;
            }
            const existingOrdersForThis = this.getExistingOrders(type, resource);
            if (existingOrdersForThis.length > TraderJoe_1.settings.market.orders.maxOrdersForResource) {
                this.notify(`${printRoomName(terminal.room.name, true)}: could not create ${type} order for ` +
                    `${Math.round(amount)} ${resource} - too many existing!`);
                return ERR_TOO_MANY_ORDERS_OF_TYPE;
            }
            const price = +this.computeCompetitivePrice(type, resource, terminal.room.name)
                .toFixed(3);
            if (price == Infinity || price == 0) {
                log.warning(`TradeNetwork: sanity checks not passed to create ${type} order ${resource} in ` +
                    `${printRoomName(terminal.room.name)}!`);
                return ERR_NOT_ENOUGH_MARKET_DATA;
            }
            const brokersFee = price * amount * MARKET_FEE;
            if (Game.market.credits < brokersFee) {
                amount = amount * Game.market.credits / brokersFee * 0.9;
            }
            const params = {
                type: type,
                resourceType: resource,
                price: price,
                totalAmount: amount,
                roomName: terminal.room.name
            };
            const ret = Game.market.createOrder(params);
            let msg = '';
            if (type == ORDER_BUY) {
                msg += `${printRoomName(terminal.room.name, true)} creating buy order:  ` +
                    `${Math.round(amount)} ${resource} at price ${price.toFixed(4)}`;
            }
            else {
                msg += `${printRoomName(terminal.room.name, true)} creating sell order: ` +
                    `${Math.round(amount)} ${resource} at price ${price.toFixed(4)}`;
            }
            if (ret == OK) {
                this.ordersPlacedThisTick++;
            }
            else {
                msg += ` ERROR: ${ret}`;
            }
            this.debug(msg);
            this.notify(msg);
            return ret;
        }
    }
    cleanOrders() {
        const ordersToClean = _.filter(Game.market.orders, order => {
            if (order.active == false && order.remainingAmount == 0) {
                return true;
            }
            if (Game.time - order.created > TraderJoe_1.settings.market.orders.timeout
                && order.remainingAmount < TraderJoe_1.settings.market.orders.cleanupAmount) {
                return true;
            }
            if (order.roomName && !Overmind.colonies[order.roomName]) {
                return true;
            }
        });
        for (const order of ordersToClean) {
            const ret = Game.market.cancelOrder(order.id);
            if (ret == OK) {
                this.notify(`Cleaning ${order.type} order for ${order.totalAmount} ${order.resourceType}. ` +
                    `Order lifetime: ${Game.time - order.created}`);
                order.lifetime = Game.time - order.created;
                this.memory.canceledOrders.push(order);
                if (this.memory.canceledOrders.length > 300) {
                    this.memory.canceledOrders.shift();
                }
            }
        }
    }
    buyDirect(terminal, resource, amount, opts) {
        this.debug(`buyDirect for ${terminal.room.print}: ${amount} ${resource}`);
        if (!terminal.isReady && !opts.dryRun) {
            return NO_ACTION;
        }
        if (amount < TraderJoe_1.settings.market.orders.minBuyDirectAmount && !opts.ignoreMinAmounts && !opts.dryRun) {
            return NO_ACTION;
        }
        amount = Math.min(amount, terminal.store.getFreeCapacity(), TraderJoe_1.settings.market.orders.maxBuyDirectAmount);
        const minAmount = opts.flexibleAmount ? Math.min(TraderJoe_1.settings.market.orders.minBuyDirectAmount, amount)
            : amount;
        const validOrders = _.filter(Game.market.getAllOrders({ resourceType: resource, type: ORDER_SELL }), order => order.amount >= minAmount);
        const order = minBy(validOrders, order => order.price
            + this.marginalTransactionPrice(order, terminal.room.name)
            - order.amount / 1000000000);
        if (!order) {
            if (!opts.dryRun) {
                this.notify(`No valid market order to buy from! Buy request: ${amount} ${resource} to ` +
                    `${printRoomName(terminal.room.name)}`);
            }
            return ERR_NO_ORDER_TO_BUY_FROM;
        }
        const adjustedPrice = order.price + this.marginalTransactionPrice(order, terminal.room.name);
        const priceForBaseIngredients = this.getPriceForBaseIngredients(resource);
        const maxPriceWillingToPay = priceForBaseIngredients * (1.5 + Game.market.credits / 2e6);
        this.debug(`Price: ${order.price}, Adjusted: ${adjustedPrice}, BaseCost: ${priceForBaseIngredients}, ` +
            `Max: ${maxPriceWillingToPay}`);
        if (priceForBaseIngredients == Infinity
            || (adjustedPrice > maxPriceWillingToPay && !opts.ignorePriceChecksForDirect)
            || adjustedPrice > 100) {
            if (!opts.dryRun) {
                this.notify(`Buy direct call is too expenisive! Buy request: ${amount} ${resource} to ` +
                    `${printRoomName(terminal.room.name)}, adjusted price of best order: ` +
                    `${adjustedPrice.toFixed(4)}`);
            }
            return ERR_BUY_DIRECT_PRICE_TOO_HIGH;
        }
        const buyAmount = Math.min(order.amount, amount);
        const transactionCost = Game.market.calcTransactionCost(buyAmount, terminal.room.name, order.roomName);
        if (terminal.store[RESOURCE_ENERGY] >= transactionCost) {
            if (opts.dryRun) {
                const haveEnoughCredits = Game.market.credits >= buyAmount * order.price;
                return haveEnoughCredits ? OK : ERR_NOT_ENOUGH_RESOURCES;
            }
            const response = Game.market.deal(order.id, buyAmount, terminal.room.name);
            this.debug(`buyDirect executed for ${terminal.room.print}: ${buyAmount} ${resource} (${response})`);
            return response;
        }
        else {
            return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
        }
    }
    sellDirect(terminal, resource, amount, opts) {
        this.debug(`sellDirect for ${terminal.room.print}: ${amount} ${resource}`);
        if (!terminal.isReady && !opts.dryRun) {
            return NO_ACTION;
        }
        if (amount < TraderJoe_1.settings.market.orders.minSellDirectAmount && !opts.ignoreMinAmounts && !opts.dryRun) {
            return NO_ACTION;
        }
        amount = Math.min(amount, terminal.store[resource], TraderJoe_1.settings.market.orders.maxSellDirectAmount);
        const minAmount = opts.flexibleAmount ? Math.min(amount, TraderJoe_1.settings.market.orders.minSellDirectAmount)
            : amount;
        const validOrders = _.filter(Game.market.getAllOrders({ resourceType: resource, type: ORDER_BUY }), order => order.amount >= minAmount);
        const order = maxBy(validOrders, order => order.price
            - this.marginalTransactionPrice(order, terminal.room.name)
            + order.amount / 1000000000);
        if (!order) {
            if (!opts.dryRun) {
                this.notify(`No valid market order to sell to! Sell request: ${amount} ${resource} from ` +
                    `${printRoomName(terminal.room.name)}`);
            }
            return ERR_NO_ORDER_TO_SELL_TO;
        }
        const adjustedPrice = order.price - this.marginalTransactionPrice(order, terminal.room.name);
        const priceForBaseIngredients = this.getPriceForBaseIngredients(resource);
        const minPriceWillingToSell = .5 * priceForBaseIngredients;
        this.debug(`Price: ${order.price}, Adjusted: ${adjustedPrice}, BaseCost: ${priceForBaseIngredients}, ` +
            `Min: ${minPriceWillingToSell}`);
        if (priceForBaseIngredients == Infinity
            || (adjustedPrice < minPriceWillingToSell && !opts.ignorePriceChecksForDirect)
            || adjustedPrice < 0) {
            if (!opts.dryRun) {
                this.notify(`Sell direct call is too cheap! Sell request: ${amount} ${resource} from ` +
                    `${printRoomName(terminal.room.name)}, adjusted price of best order: ` +
                    `${adjustedPrice}`);
            }
            return ERR_SELL_DIRECT_PRICE_TOO_LOW;
        }
        let sellAmount = Math.min(order.amount, amount);
        const transactionCost = Game.market.calcTransactionCost(sellAmount, terminal.room.name, order.roomName);
        if (resource == RESOURCE_ENERGY) {
            if (amount + transactionCost > terminal.store[RESOURCE_ENERGY]) {
                sellAmount -= transactionCost;
                if (sellAmount <= 0) {
                    return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
                }
            }
        }
        if (terminal.store[RESOURCE_ENERGY] >= transactionCost) {
            if (opts.dryRun) {
                return OK;
            }
            const response = Game.market.deal(order.id, sellAmount, terminal.room.name);
            this.debug(`sellDirect executed for ${terminal.room.print}: ${sellAmount} ${resource} (${response})`);
            return response;
        }
        else {
            return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
        }
    }
    buy(terminal, resource, amount, opts = {}) {
        _.defaults(opts, defaultTradeOpts);
        if (Game.market.credits < TraderJoe_1.settings.market.credits.canBuyAbove) {
            log.error(`Credits insufficient to buy resource ${amount} ${resource} to ${terminal.room.print}; ` +
                `shouldn't be making this TradeNetwork.buy() request!`);
            return ERR_CREDIT_THRESHOLDS;
        }
        if (Game.market.credits < TraderJoe_1.settings.market.credits.canBuyBoostsAbove && Abathur.isBoost(resource)) {
            log.error(`Credits insufficient to buy boost ${amount} ${resource} to ${terminal.room.print}; ` +
                `shouldn't be making this TradeNetwork.buy() request!`);
            return ERR_CREDIT_THRESHOLDS;
        }
        if (Game.market.credits < TraderJoe_1.settings.market.credits.canBuyEnergyAbove && resource == RESOURCE_ENERGY) {
            log.error(`Credits insufficient to buy ${amount} energy to ${terminal.room.print}; ` +
                `shouldn't be making this TradeNetwork.buy() request!`);
            return ERR_CREDIT_THRESHOLDS;
        }
        if (Abathur.isIntermediateReactant(resource) || resource == RESOURCE_GHODIUM) {
            log.error(`Shouldn't request reaction intermediate ${amount} ${resource} to ${terminal.room.print}!`);
            return ERR_DONT_BUY_REACTION_INTERMEDIATES;
        }
        if (opts.preferDirect && this.getExistingOrders(ORDER_BUY, resource, terminal.room.name).length == 0) {
            const result = this.buyDirect(terminal, resource, amount, opts);
            if (result != ERR_NO_ORDER_TO_BUY_FROM && result != ERR_BUY_DIRECT_PRICE_TOO_HIGH) {
                return result;
            }
            this.notify(`Buy direct request: ${amount} ${resource} to ${printRoomName(terminal.room.name)} ` +
                `was unsuccessful; allowing fallthrough to TradeNetwork.maintainOrder()`);
        }
        if (opts.dryRun) {
            return ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS;
        }
        const result = this.maintainOrder(terminal, ORDER_BUY, resource, amount, opts);
        return result;
    }
    sell(terminal, resource, amount, opts = {}) {
        _.defaults(opts, defaultTradeOpts);
        if (opts.preferDirect || Game.market.credits < TraderJoe_1.settings.market.credits.mustSellDirectBelow) {
            if (this.getExistingOrders(ORDER_SELL, resource, terminal.room.name).length == 0) {
                const result = this.sellDirect(terminal, resource, amount, opts);
                if (result != ERR_NO_ORDER_TO_SELL_TO && result != ERR_SELL_DIRECT_PRICE_TOO_LOW) {
                    return result;
                }
                this.notify(`Sell direct request: ${amount} ${resource} from ${printRoomName(terminal.room.name)} ` +
                    `was unsuccessful; allowing fallthrough to TradeNetwork.maintainOrder()`);
            }
        }
        if (opts.dryRun) {
            return ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS;
        }
        if (Game.market.credits >= TraderJoe_1.settings.market.credits.canPlaceSellOrdersAbove) {
            const result = this.maintainOrder(terminal, ORDER_SELL, resource, amount, opts);
            return result;
        }
        else {
            return ERR_CREDIT_THRESHOLDS;
        }
    }
    init() {
        if (Game.time - (this.memory.cache.tick || 0) > TraderJoe_1.settings.cache.timeout) {
            this.buildMarketCache();
            this.buildMarketHistoryCache();
        }
    }
    run() {
        if (!onPublicServer())
            return;
        if (Game.time % 10 == 0) {
            this.cleanOrders();
        }
        this.notifyLastTickTransactions();
        if (Game.time % 10 == 0) {
            if (this.notifications.length > 0) {
                this.notifications.sort();
                log.info(`Trade network activity: ` + alignedNewline + this.notifications.join(alignedNewline));
            }
        }
        this.recordStats();
    }
    notifyLastTickTransactions() {
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < Game.time - 1)
                break;
            if (transaction.order) {
                let msg;
                const cost = (transaction.amount * transaction.order.price).toFixed(2);
                if (transaction.order.type == ORDER_BUY) {
                    const coststr = `[+${cost}c]`.padRight('[-10000.00c]'.length);
                    msg = coststr + ` sell direct: ${printRoomName(transaction.to, true)} ${leftArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${leftArrow} ` +
                        `${printRoomName(transaction.from, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const recipient = transaction.recipient.username;
                        msg += `(sold to: ${recipient})`;
                    }
                    else {
                        msg += `(sold to: ???)`;
                    }
                }
                else {
                    const coststr = `[+${cost}c]`.padRight('[-10000.00c]'.length);
                    msg = coststr + ` sell order: ${printRoomName(transaction.from, true)} ${rightArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${rightArrow} ` +
                        `${printRoomName(transaction.to, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const recipient = transaction.recipient.username;
                        msg += `(buyer: ${recipient})`;
                    }
                    else {
                        msg += `(buyer: ???)`;
                    }
                }
                this.notify(msg);
            }
        }
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < Game.time - 1)
                break;
            if (transaction.order) {
                let msg;
                const cost = (transaction.amount * transaction.order.price).toFixed(2);
                if (transaction.order.type == ORDER_SELL) {
                    const coststr = `[-${cost}c]`.padRight('[-10000.00c]'.length);
                    msg = coststr + ` buy direct: ${printRoomName(transaction.to, true)} ${leftArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${leftArrow} ` +
                        `${printRoomName(transaction.from, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const sender = transaction.sender.username;
                        msg += `(bought from: ${sender})`;
                    }
                    else {
                        msg += `(bought from: ???)`;
                    }
                }
                else {
                    const coststr = `[-${cost}c]`.padRight('[-10000.00c]'.length);
                    msg = coststr + ` buy order: ${printRoomName(transaction.from, true)} ${rightArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${rightArrow} ` +
                        `${printRoomName(transaction.to, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const sender = transaction.sender.username;
                        msg += `(seller: ${sender})`;
                    }
                    else {
                        msg += `(seller: ???)`;
                    }
                }
                this.notify(msg);
            }
        }
    }
    recordStats() {
        this.stats.credits = Game.market.credits;
        const lastTick = Game.time - 1;
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < lastTick) {
                break;
            }
            else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    this.stats.bought[resourceType] = this.stats.bought[resourceType] || { amount: 0, credits: 0 };
                    this.stats.bought[resourceType].amount += amount;
                    this.stats.bought[resourceType].credits += amount * price;
                }
            }
        }
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < lastTick) {
                break;
            }
            else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    this.stats.sold[resourceType] = this.stats.sold[resourceType] || { amount: 0, credits: 0 };
                    this.stats.sold[resourceType].amount += amount;
                    this.stats.sold[resourceType].credits += amount * price;
                }
            }
        }
    }
};
TraderJoe.settings = {
    cache: {
        timeout: 250,
    },
    market: {
        resources: {
            allowBuyT1T2boosts: false,
        },
        credits: {
            mustSellDirectBelow: 5000,
            canPlaceSellOrdersAbove: 2000,
            canBuyAbove: 1000000,
            canBuyPassivelyAbove: 3000000,
            canBuyBoostsAbove: 5 * Math.max(RESERVE_CREDITS, 1e5),
            canBuyEnergyAbove: 10 * Math.max(RESERVE_CREDITS, 1e5),
        },
        orders: {
            timeout: 500000,
            cleanupAmount: 100,
            maxEnergySellOrders: 5,
            maxEnergyBuyOrders: 5,
            maxOrdersPlacedPerTick: 7,
            maxOrdersForResource: 20,
            minSellOrderAmount: 1000,
            maxSellOrderAmount: 25000,
            minSellDirectAmount: 250,
            maxSellDirectAmount: 10000,
            minBuyOrderAmount: 250,
            maxBuyOrderAmount: 25000,
            minBuyDirectAmount: 500,
            maxBuyDirectAmount: 10000,
        }
    },
};
TraderJoe = TraderJoe_1 = __decorate([
    profile
], TraderJoe);

var Abathur_1;
const REACTION_PRIORITIES = [
    BOOST_TIERS.attack.T1,
    BOOST_TIERS.heal.T1,
    BOOST_TIERS.ranged.T1,
    BOOST_TIERS.move.T1,
    BOOST_TIERS.construct.T1,
    BOOST_TIERS.dismantle.T1,
    BOOST_TIERS.tough.T1,
    RESOURCE_GHODIUM,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_HYDROXIDE,
    BOOST_TIERS.attack.T2,
    BOOST_TIERS.heal.T2,
    BOOST_TIERS.ranged.T2,
    BOOST_TIERS.move.T2,
    BOOST_TIERS.dismantle.T2,
    BOOST_TIERS.tough.T2,
    BOOST_TIERS.attack.T3,
    BOOST_TIERS.heal.T3,
    BOOST_TIERS.ranged.T3,
    BOOST_TIERS.move.T3,
    BOOST_TIERS.dismantle.T3,
    BOOST_TIERS.tough.T3,
    BOOST_TIERS.construct.T2,
    BOOST_TIERS.construct.T3,
    BOOST_TIERS.carry.T1,
    BOOST_TIERS.carry.T2,
    BOOST_TIERS.carry.T3,
    BOOST_TIERS.upgrade.T1,
    BOOST_TIERS.upgrade.T2,
    BOOST_TIERS.upgrade.T3,
];
const priorityStockAmounts = {
    XGHO2: 1000,
    XLHO2: 1000,
    XZHO2: 1000,
    XZH2O: 1000,
    XKHO2: 1000,
    XUH2O: 1000,
    GHO2: 8000,
    LHO2: 8000,
    ZHO2: 8000,
    ZH2O: 8000,
    UH2O: 8000,
    KHO2: 8000,
    GO: 1000,
    LO: 1000,
    ZO: 1000,
    ZH: 1000,
    UH: 1000,
    KO: 1000,
    G: 2000,
};
const wantedStockAmounts = {
    UH: 3000,
    KO: 3000,
    XGHO2: 10000,
    XLHO2: 20000,
    XZHO2: 6000,
    XZH2O: 6000,
    XKHO2: 20000,
    XUH2O: 20000,
    G: 5000,
    XLH2O: 8000,
    LH: 3000,
    XUHO2: 3000,
    XKH2O: 3000,
    ZK: 800,
    UL: 800,
    GH: 800,
    KH: 800,
    OH: 800,
    GH2O: 800,
    LH2O: 800,
    KH2O: 800,
    XGH2O: 12000,
};
const baseStockAmounts = {
    [RESOURCE_CATALYST]: 5000,
    [RESOURCE_ZYNTHIUM]: 5000,
    [RESOURCE_LEMERGIUM]: 5000,
    [RESOURCE_KEANIUM]: 5000,
    [RESOURCE_UTRIUM]: 5000,
    [RESOURCE_OXYGEN]: 5000,
    [RESOURCE_HYDROGEN]: 5000
};
let Abathur = Abathur_1 = class Abathur {
    static isMineralOrCompound(resource) {
        return !!_mineralCompoundsAllLookup[resource];
    }
    static isBaseMineral(resource) {
        return !!_baseResourcesLookup[resource];
    }
    static isIntermediateReactant(resource) {
        return INTERMEDIATE_REACTANTS.includes(resource);
    }
    static isBoost(resource) {
        return !!BOOST_PARTS[resource];
    }
    static isAttackBoost(resource) {
        return !!_boostTypesTierLookup.attack[resource];
    }
    static isRangedBoost(resource) {
        return !!_boostTypesTierLookup.ranged[resource];
    }
    static isHealBoost(resource) {
        return !!_boostTypesTierLookup.heal[resource];
    }
    static isToughBoost(resource) {
        return !!_boostTypesTierLookup.tough[resource];
    }
    static isMoveBoost(resource) {
        return !!_boostTypesTierLookup.move[resource];
    }
    static isDismantleBoost(resource) {
        return !!_boostTypesTierLookup.dismantle[resource];
    }
    static isConstructBoost(resource) {
        return !!_boostTypesTierLookup.construct[resource];
    }
    static isUpgradeBoost(resource) {
        return !!_boostTypesTierLookup.upgrade[resource];
    }
    static isHarvestBoost(resource) {
        return !!_boostTypesTierLookup.harvest[resource];
    }
    static isCarryBoost(resource) {
        return !!_boostTypesTierLookup.carry[resource];
    }
    static isDepositResource(resource) {
        return DEPOSITS_ALL.includes(resource);
    }
    static isCommodity(resource) {
        return !!_commoditiesLookup[resource];
    }
    static getBoostTier(boost) {
        return _boostTierLookupAllTypes[boost] || 'notaboost';
    }
    static enumerateReactionBaseIngredients(mineral) {
        if (BASE_RESOURCES.includes(mineral)) {
            return [mineral];
        }
        else if (REAGENTS[mineral]) {
            return Abathur_1.enumerateReactionBaseIngredients(REAGENTS[mineral][0])
                .concat(Abathur_1.enumerateReactionBaseIngredients(REAGENTS[mineral][1]));
        }
        else {
            return [];
        }
    }
    static getNextReaction(colony) {
        const BATCH_SIZE = Abathur_1.settings.batchSize;
        const globalAssets = Overmind.terminalNetwork.getAssets();
        const numColonies = _.filter(getAllColonies(), colony => !!colony.terminal).length;
        let possibleReactions = REACTION_PRIORITIES;
        if (colony.labs.length < 10) {
            possibleReactions = _.filter(possibleReactions, resource => (REACTION_TIME[resource] || Infinity) <= 30);
        }
        let nextTargetResource;
        const ingredientsUnavailable = {};
        const maxAmountOfEachBoostPerColony = 50000;
        const maxBatches = Math.ceil(maxAmountOfEachBoostPerColony / BATCH_SIZE);
        for (const batchNum of _.range(1, maxBatches)) {
            nextTargetResource = _.find(possibleReactions, resource => {
                if (ingredientsUnavailable[resource])
                    return false;
                const tier = Abathur_1.getBoostTier(resource);
                if (tier == 'T2' && batchNum * BATCH_SIZE < 2 * LAB_MINERAL_CAPACITY)
                    return false;
                if (tier == 'T3' && batchNum * BATCH_SIZE < 3 * LAB_MINERAL_CAPACITY)
                    return false;
                if (resource == RESOURCE_GHODIUM || Abathur_1.isIntermediateReactant(resource)) {
                    if (colony.assets[resource] > Overmind.terminalNetwork.thresholds(colony, resource).target) {
                        return false;
                    }
                }
                const globalShortage = globalAssets[resource] / numColonies < (batchNum - 3) * BATCH_SIZE;
                const localShortage = colony.assets[resource] < batchNum * BATCH_SIZE;
                if (globalShortage || localShortage) {
                    const [reagent1, reagent2] = REAGENTS[resource];
                    const reagent1Available = colony.assets[reagent1] >= BATCH_SIZE ||
                        Overmind.terminalNetwork.canObtainResource(colony, reagent1, BATCH_SIZE);
                    const reagent2Available = colony.assets[reagent2] >= BATCH_SIZE ||
                        Overmind.terminalNetwork.canObtainResource(colony, reagent2, BATCH_SIZE);
                    if (reagent1Available && reagent2Available) {
                        return true;
                    }
                    else {
                        ingredientsUnavailable[resource] = true;
                    }
                }
                return false;
            });
            if (nextTargetResource)
                break;
        }
        if (nextTargetResource) {
            return { mineralType: nextTargetResource, amount: BATCH_SIZE };
        }
    }
    static canReceiveBasicMineralsForReaction(mineralQuantities, amount) {
        for (const mineral in mineralQuantities) {
            if (!Abathur_1.someColonyHasExcess(mineral, mineralQuantities[mineral])) {
                return false;
            }
        }
        return true;
    }
    static canBuyBasicMineralsForReaction(mineralQuantities) {
        if (Game.market.credits < TraderJoe.settings.market.credits.canBuyAbove) {
            return false;
        }
        for (const mineral in mineralQuantities) {
            let maxPrice = maxMarketPrices[mineral] || maxMarketPrices.default;
            if (!onPublicServer()) {
                maxPrice = Infinity;
            }
            if (Overmind.tradeNetwork.priceOf(mineral) > maxPrice) {
                return false;
            }
        }
        return true;
    }
    static stockAmount(resource) {
        return 0;
    }
    static hasExcess(colony, mineralType, excessAmount = 0) {
        return colony.assets[mineralType] - excessAmount > Abathur_1.stockAmount(mineralType);
    }
    static someColonyHasExcess(mineralType, excessAmount = 0) {
        return _.any(getAllColonies(), colony => Abathur_1.hasExcess(colony, mineralType, excessAmount));
    }
    static getReactionQueue(colony, verbose = false) {
        const stocksToCheck = [priorityStockAmounts, wantedStockAmounts];
        for (const stocks of stocksToCheck) {
            for (const resourceType in stocks) {
                const amountOwned = colony.assets[resourceType];
                const amountNeeded = stocks[resourceType];
                if (amountOwned < amountNeeded) {
                    const reactionQueue = Abathur_1.buildReactionQueue(colony, resourceType, amountNeeded - amountOwned, verbose);
                    const missingBaseMinerals = Abathur_1.getMissingBasicMinerals(colony, reactionQueue);
                    if (!_.any(missingBaseMinerals)
                        || this.canReceiveBasicMineralsForReaction(missingBaseMinerals, amountNeeded + 1000)
                        || this.canBuyBasicMineralsForReaction(missingBaseMinerals)) {
                        return reactionQueue;
                    }
                    else {
                        if (verbose)
                            console.log(`Missing minerals for ${resourceType}: ${JSON.stringify(missingBaseMinerals)}`);
                    }
                }
            }
        }
        return [];
    }
    static buildReactionQueue(colony, mineral, amount, verbose = false) {
        amount = Abathur_1.settings.batchSize;
        if (verbose)
            console.log(`Abathur@${colony.room.print}: building reaction queue for ${amount} ${mineral}`);
        let reactionQueue = [];
        for (const ingredient of Abathur_1.enumerateReactionProducts(mineral)) {
            let productionAmount = amount;
            if (ingredient != mineral) {
                if (verbose) {
                    console.log(`productionAmount: ${productionAmount}, assets: ${colony.assets[ingredient]}`);
                }
                productionAmount = Math.max(productionAmount - (colony.assets[ingredient]), 0);
            }
            productionAmount = Math.min(productionAmount, Abathur_1.settings.batchSize);
            reactionQueue.push({ mineralType: ingredient, amount: productionAmount });
        }
        if (verbose)
            console.log(`Pre-trim queue: ${JSON.stringify(reactionQueue)}`);
        reactionQueue = Abathur_1.trimReactionQueue(reactionQueue);
        if (verbose)
            console.log(`Post-trim queue: ${JSON.stringify(reactionQueue)}`);
        reactionQueue = _.filter(reactionQueue, rxn => rxn.amount > 0);
        if (verbose)
            console.log(`Final queue: ${JSON.stringify(reactionQueue)}`);
        return reactionQueue;
    }
    static trimReactionQueue(reactionQueue) {
        reactionQueue.reverse();
        for (const reaction of reactionQueue) {
            const [ing1, ing2] = REAGENTS[reaction.mineralType];
            const precursor1 = _.findIndex(reactionQueue, rxn => rxn.mineralType == ing1);
            const precursor2 = _.findIndex(reactionQueue, rxn => rxn.mineralType == ing2);
            for (const index of [precursor1, precursor2]) {
                if (index != -1) {
                    if (reactionQueue[index].amount == 0) {
                        reactionQueue[index].amount = 0;
                    }
                    else {
                        reactionQueue[index].amount = Math.min(reaction.amount, reactionQueue[index].amount);
                    }
                }
            }
        }
        reactionQueue.reverse();
        return reactionQueue;
    }
    static getMissingBasicMinerals(colony, reactionQueue, verbose = false) {
        const requiredBasicMinerals = Abathur_1.getRequiredBasicMinerals(reactionQueue);
        if (verbose)
            console.log(`Required basic minerals: ${JSON.stringify(requiredBasicMinerals)}`);
        if (verbose)
            console.log(`assets: ${JSON.stringify(colony.assets)}`);
        const missingBasicMinerals = {};
        for (const mineralType in requiredBasicMinerals) {
            const amountMissing = requiredBasicMinerals[mineralType] - colony.assets[mineralType];
            if (amountMissing > 0) {
                missingBasicMinerals[mineralType] = amountMissing;
            }
        }
        if (verbose)
            console.log(`Missing basic minerals: ${JSON.stringify(missingBasicMinerals)}`);
        return missingBasicMinerals;
    }
    static getRequiredBasicMinerals(reactionQueue) {
        const requiredBasicMinerals = {
            [RESOURCE_HYDROGEN]: 0,
            [RESOURCE_OXYGEN]: 0,
            [RESOURCE_UTRIUM]: 0,
            [RESOURCE_KEANIUM]: 0,
            [RESOURCE_LEMERGIUM]: 0,
            [RESOURCE_ZYNTHIUM]: 0,
            [RESOURCE_CATALYST]: 0,
        };
        for (const reaction of reactionQueue) {
            const ingredients = REAGENTS[reaction.mineralType];
            for (const ingredient of ingredients) {
                if (!REAGENTS[ingredient]) {
                    requiredBasicMinerals[ingredient] += reaction.amount;
                }
            }
        }
        return requiredBasicMinerals;
    }
    static enumerateReactionProducts(mineral) {
        if (!REAGENTS[mineral] || _.isEmpty(mineral)) {
            return [];
        }
        else {
            return Abathur_1.enumerateReactionProducts(REAGENTS[mineral][0])
                .concat(Abathur_1.enumerateReactionProducts(REAGENTS[mineral][1]), mineral);
        }
    }
};
Abathur.settings = {
    batchSize: 1600,
};
Abathur = Abathur_1 = __decorate([
    profile
], Abathur);
global.Abathur = Abathur;

const repairTaskName = 'repair';
let TaskRepair = class TaskRepair extends Task {
    constructor(target, options = {}) {
        super(repairTaskName, target, options);
        this.settings.timeout = 100;
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        return !!this.target && this.target.hits < this.target.hitsMax;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        const result = this.creep.repair(this.target);
        if (this.target.structureType == STRUCTURE_ROAD) {
            const newHits = this.target.hits + this.creep.getActiveBodyparts(WORK) * REPAIR_POWER;
            if (newHits > this.target.hitsMax) {
                this.finish();
            }
        }
        return result;
    }
};
TaskRepair = __decorate([
    profile
], TaskRepair);

const reserveTaskName = 'colony';
let TaskReserve = class TaskReserve extends Task {
    constructor(target, options = {}) {
        super(reserveTaskName, target, options);
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(CLAIM) > 0);
    }
    isValidTarget() {
        const target = this.target;
        return !!target && (!target.reservation || target.reservation.ticksToEnd < 4999);
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        let ret = this.creep.reserveController(this.target);
        if (ret == ERR_INVALID_TARGET) {
            ret = this.creep.attackController(this.target);
        }
        return ret;
    }
};
TaskReserve = __decorate([
    profile
], TaskReserve);

const signControllerTaskName = 'signController';
let TaskSignController = class TaskSignController extends Task {
    constructor(target, options = {}) {
        super(signControllerTaskName, target, options);
    }
    isValidTask() {
        return true;
    }
    isValidTarget() {
        const controller = this.target;
        return !!controller &&
            (!controller.sign || controller.sign.text != Memory.settings.signature) &&
            !controller.signedByScreeps;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.signController(this.target, Memory.settings.signature);
    }
};
TaskSignController = __decorate([
    profile
], TaskSignController);

const transferTaskName = 'transfer';
let TaskTransfer = class TaskTransfer extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(transferTaskName, target, options);
        this.settings.oneShot = true;
        this.settings.blind = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.carry[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        const amount = this.data.amount || 1;
        return !!this.target && this.target.store.getFreeCapacity(this.data.resourceType) >= amount;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.transfer(this.target, this.data.resourceType, this.data.amount);
    }
};
TaskTransfer = __decorate([
    profile
], TaskTransfer);

const transferAllTaskName = 'transferAll';
let TaskTransferAll = class TaskTransferAll extends Task {
    constructor(target, skipEnergy = false, options = {}) {
        super(transferAllTaskName, target, options);
        this.data.skipEnergy = skipEnergy;
        this.settings.blind = false;
    }
    isValidTask() {
        for (const [resourceType, amount] of this.creep.carry.contents) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                return true;
            }
        }
        return false;
    }
    isValidTarget() {
        return !!this.target && _.sum(this.target.store) < this.target.store.getCapacity();
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        for (const [resourceType, amount] of this.creep.carry.contents) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                return this.creep.transfer(this.target, resourceType);
            }
        }
        return -1;
    }
};
TaskTransferAll = __decorate([
    profile
], TaskTransferAll);

const upgradeTaskName = 'upgrade';
let TaskUpgrade = class TaskUpgrade extends Task {
    constructor(target, options = {}) {
        super(upgradeTaskName, target, options);
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return (this.creep.carry.energy > 0);
    }
    isValidTarget() {
        return !!this.target && !!this.target.my;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.upgradeController(this.target);
    }
};
TaskUpgrade = __decorate([
    profile
], TaskUpgrade);

const withdrawTaskName = 'withdraw';
let TaskWithdraw = class TaskWithdraw extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(withdrawTaskName, target, options);
        this.settings.oneShot = true;
        this.settings.blind = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        return (_.sum(this.creep.carry) <= this.creep.carryCapacity - amount);
    }
    isValidTarget() {
        const amount = this.data.amount || 1;
        return !!this.target && this.target.store.getUsedCapacity(this.data.resourceType) >= amount;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        return this.creep.withdraw(this.target, this.data.resourceType, this.data.amount);
    }
};
TaskWithdraw = __decorate([
    profile
], TaskWithdraw);

const withdrawAllTaskName = 'withdrawAll';
let TaskWithdrawAll = class TaskWithdrawAll extends Task {
    constructor(target, options = {}) {
        super(withdrawAllTaskName, target, options);
        this.settings.blind = true;
    }
    isValidTask() {
        return (_.sum(this.creep.carry) < this.creep.carryCapacity);
    }
    isValidTarget() {
        return !!this.target && _.sum(this.target.store) > 0;
    }
    work() {
        if (!this.target)
            return ERR_INVALID_TARGET;
        let resourceTransferType;
        for (const [resourceType, amountInStore] of this.target.store.contents) {
            if (amountInStore > 0) {
                resourceTransferType = resourceType;
                if (resourceType != RESOURCE_ENERGY) {
                    break;
                }
            }
        }
        if (!!resourceTransferType) {
            return this.creep.withdraw(this.target, resourceTransferType);
        }
        return -1;
    }
};
TaskWithdrawAll = __decorate([
    profile
], TaskWithdrawAll);

let Tasks = class Tasks {
    static chain(tasks, setNextPos = true) {
        if (tasks.length == 0) {
            return null;
        }
        if (setNextPos) {
            for (let i = 0; i < tasks.length - 1; i++) {
                tasks[i].options.nextPos = tasks[i + 1].targetPos;
            }
        }
        let task = _.last(tasks);
        tasks = _.dropRight(tasks);
        for (let i = (tasks.length - 1); i >= 0; i--) {
            task = task.fork(tasks[i]);
        }
        return task;
    }
    static attack(target, options = {}) {
        return new TaskAttack(target, options);
    }
    static build(target, options = {}) {
        return new TaskBuild(target, options);
    }
    static claim(target, options = {}) {
        return new TaskClaim(target, options);
    }
    static dismantle(target, options = {}) {
        return new TaskDismantle(target, options);
    }
    static drop(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskDrop(target, resourceType, amount, options);
    }
    static fortify(target, hitsMax, options = {}) {
        return new TaskFortify(target, hitsMax, options);
    }
    static getBoosted(target, boostType, amount, options = {}) {
        return new TaskGetBoosted(target, boostType, amount, options);
    }
    static getRenewed(target, options = {}) {
        return new TaskGetRenewed(target, options);
    }
    static goTo(target, options = {}) {
        return new TaskGoTo(target, options);
    }
    static goToRoom(roomName, options = {}) {
        const fakeTargetPos = { ref: '', pos: new RoomPosition(25, 25, roomName) };
        return new TaskGoToRoom(fakeTargetPos, options);
    }
    static harvest(target, options = {}) {
        return new TaskHarvest(target, options);
    }
    static heal(target, options = {}) {
        return new TaskHeal(target, options);
    }
    static meleeAttack(target, options = {}) {
        return new TaskMeleeAttack(target, options);
    }
    static pickup(target, options = {}) {
        return new TaskPickup(target, options);
    }
    static rangedAttack(target, options = {}) {
        return new TaskRangedAttack(target, options);
    }
    static recharge(minEnergy = 0, options = {}) {
        return new TaskRecharge(minEnergy, options);
    }
    static repair(target, options = {}) {
        return new TaskRepair(target, options);
    }
    static reserve(target, options = {}) {
        return new TaskReserve(target, options);
    }
    static signController(target, options = {}) {
        return new TaskSignController(target, options);
    }
    static transfer(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskTransfer(target, resourceType, amount, options);
    }
    static transferAll(target, skipEnergy = false, options = {}) {
        return new TaskTransferAll(target, skipEnergy, options);
    }
    static upgrade(target, options = {}) {
        return new TaskUpgrade(target, options);
    }
    static withdraw(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskWithdraw(target, resourceType, amount, options);
    }
    static withdrawAll(target, options = {}) {
        return new TaskWithdrawAll(target, options);
    }
    static generateSafeMode(target, options = {}) {
        return new TaskGenerateSafeMode(target, options);
    }
};
Tasks = __decorate([
    profile
], Tasks);

function applyDistanceTransform(foregroundPixels, oob = 255) {
    const dist = foregroundPixels;
    let UL, U, UR;
    let L, mid, R;
    let BL, B, BR;
    let x, y, value;
    for (y = 0; y < 50; ++y) {
        for (x = 0; x < 50; ++x) {
            if (foregroundPixels.get(x, y) !== 0) {
                UL = dist.get(x - 1, y - 1);
                U = dist.get(x, y - 1);
                UR = dist.get(x + 1, y - 1);
                L = dist.get(x - 1, y);
                if (y == 0) {
                    UL = oob;
                    U = oob;
                    UR = oob;
                }
                if (x == 0) {
                    UL = oob;
                    L = oob;
                }
                if (x == 49) {
                    UR = oob;
                }
                dist.set(x, y, Math.min(UL, U, UR, L, 254) + 1);
            }
        }
    }
    for (y = 49; y >= 0; --y) {
        for (x = 49; x >= 0; --x) {
            mid = dist.get(x, y);
            R = dist.get(x + 1, y);
            BL = dist.get(x - 1, y + 1);
            B = dist.get(x, y + 1);
            BR = dist.get(x + 1, y + 1);
            if (y == 49) {
                BL = oob;
                B = oob;
                BR = oob;
            }
            if (x == 49) {
                R = oob;
                BR = oob;
            }
            if (x == 0) {
                BL = oob;
            }
            value = Math.min(mid, R + 1, BL + 1, B + 1, BR + 1);
            dist.set(x, y, value);
        }
    }
    return dist;
}
function walkablePixelsForRoom(roomName) {
    const costMatrix = new PathFinder.CostMatrix();
    const terrain = Game.map.getRoomTerrain(roomName);
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                costMatrix.set(x, y, 1);
            }
        }
    }
    return costMatrix;
}
function wallOrAdjacentToExit(x, y, roomName) {
    const terrain = Game.map.getRoomTerrain(roomName);
    if (1 < x && x < 48 && 1 < y && y < 48) {
        return terrain.get(x, y) == TERRAIN_MASK_WALL;
    }
    if (0 == x || 0 == y || 49 == x || 49 == y) {
        return true;
    }
    if (terrain.get(x, y) == TERRAIN_MASK_WALL) {
        return true;
    }
    let A, B, C;
    if (x == 1) {
        A = terrain.get(0, y - 1);
        B = terrain.get(0, y);
        C = terrain.get(0, y + 1);
    }
    else if (x == 48) {
        A = terrain.get(49, y - 1);
        B = terrain.get(49, y);
        C = terrain.get(49, y + 1);
    }
    if (y == 1) {
        A = terrain.get(x - 1, 0);
        B = terrain.get(x, 0);
        C = terrain.get(x + 1, 0);
    }
    else if (y == 48) {
        A = terrain.get(x - 1, 49);
        B = terrain.get(x, 49);
        C = terrain.get(x + 1, 49);
    }
    return !(A == TERRAIN_MASK_WALL && B == TERRAIN_MASK_WALL && C == TERRAIN_MASK_WALL);
}
function blockablePixelsForRoom(roomName) {
    const costMatrix = new PathFinder.CostMatrix();
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            if (!wallOrAdjacentToExit(x, y, roomName)) {
                costMatrix.set(x, y, 1);
            }
        }
    }
    return costMatrix;
}
function displayCostMatrix(costMatrix, color = '#ff0000') {
    const vis = new RoomVisual();
    let max = 1;
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            max = Math.max(max, costMatrix.get(x, y));
        }
    }
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            const value = costMatrix.get(x, y);
            if (value > 0) {
                vis.circle(x, y, { radius: costMatrix.get(x, y) / max / 2, fill: color });
            }
        }
    }
}
function testDistanceTransform(roomName = 'sim') {
    const dt = applyDistanceTransform(walkablePixelsForRoom(roomName));
    displayCostMatrix(dt);
}
function distanceTransform(roomName) {
    return applyDistanceTransform(walkablePixelsForRoom(roomName));
}

function hexToUint16Array(hex) {
    const len = Math.ceil(hex.length / 4);
    const array = new Uint16Array(len);
    for (let i = 0; i < hex.length; i += 4) {
        array[i >>> 2] = parseInt(hex.substr(i, 4), 16);
    }
    return array;
}
function uint16ArrayToHex(array) {
    const hex = [];
    let current;
    for (let i = 0; i < array.length; ++i) {
        current = array[i];
        hex.push((current >>> 8).toString(16));
        hex.push((current & 0xFF).toString(16));
    }
    return hex.join('');
}
function packId(id) {
    return String.fromCharCode(parseInt(id.substr(0, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(4, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(8, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(12, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(16, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(20, 4), 16));
}
function unpackId(packedId) {
    let id = '';
    let current;
    for (let i = 0; i < 6; ++i) {
        current = packedId.charCodeAt(i);
        id += (current >>> 8).toString(16).padStart(2, '0');
        id += (current & 0xFF).toString(16).padStart(2, '0');
    }
    return id;
}
function packIdList(ids) {
    let str = '';
    for (let i = 0; i < ids.length; ++i) {
        str += packId(ids[i]);
    }
    return str;
}
function unpackIdList(packedIds) {
    const ids = [];
    for (let i = 0; i < packedIds.length; i += 6) {
        ids.push(unpackId(packedIds.substr(i, 6)));
    }
    return ids;
}
function packCoord(coord) {
    return String.fromCharCode(((coord.x << 6) | coord.y) + 65);
}
function unpackCoord(char) {
    const xShiftedSixOrY = char.charCodeAt(0) - 65;
    return {
        x: (xShiftedSixOrY & 0b111111000000) >>> 6,
        y: (xShiftedSixOrY & 0b000000111111),
    };
}
function unpackCoordAsPos(packedCoord, roomName) {
    const coord = unpackCoord(packedCoord);
    return new RoomPosition(coord.x, coord.y, roomName);
}
function packCoordList(coords) {
    let str = '';
    for (let i = 0; i < coords.length; ++i) {
        str += String.fromCharCode(((coords[i].x << 6) | coords[i].y) + 65);
    }
    return str;
}
function unpackCoordList(chars) {
    const coords = [];
    let xShiftedSixOrY;
    for (let i = 0; i < chars.length; ++i) {
        xShiftedSixOrY = chars.charCodeAt(i) - 65;
        coords.push({
            x: (xShiftedSixOrY & 0b111111000000) >>> 6,
            y: (xShiftedSixOrY & 0b000000111111),
        });
    }
    return coords;
}
function unpackCoordListAsPosList(packedCoords, roomName) {
    const positions = [];
    let coord;
    for (let i = 0; i < packedCoords.length; ++i) {
        coord = unpackCoord(packedCoords[i]);
        positions.push(new RoomPosition(coord.x, coord.y, roomName));
    }
    return positions;
}
PERMACACHE._packedRoomNames = PERMACACHE._packedRoomNames || {};
PERMACACHE._unpackedRoomNames = PERMACACHE._unpackedRoomNames || {};
function packRoomName(roomName) {
    if (PERMACACHE._packedRoomNames[roomName] === undefined) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = Number(match[2]);
        const yDir = match[3];
        const y = Number(match[4]);
        let quadrant;
        if (xDir == 'W') {
            if (yDir == 'N') {
                quadrant = 0;
            }
            else {
                quadrant = 1;
            }
        }
        else {
            if (yDir == 'N') {
                quadrant = 2;
            }
            else {
                quadrant = 3;
            }
        }
        const num = (quadrant << 12 | (x << 6) | y) + 65;
        const char = String.fromCharCode(num);
        PERMACACHE._packedRoomNames[roomName] = char;
        PERMACACHE._unpackedRoomNames[char] = roomName;
    }
    return PERMACACHE._packedRoomNames[roomName];
}
function unpackRoomName(char) {
    if (PERMACACHE._unpackedRoomNames[char] === undefined) {
        const num = char.charCodeAt(0) - 65;
        const { q, x, y } = {
            q: (num & 0b11000000111111) >>> 12,
            x: (num & 0b00111111000000) >>> 6,
            y: (num & 0b00000000111111),
        };
        let roomName;
        switch (q) {
            case 0:
                roomName = 'W' + x + 'N' + y;
                break;
            case 1:
                roomName = 'W' + x + 'S' + y;
                break;
            case 2:
                roomName = 'E' + x + 'N' + y;
                break;
            case 3:
                roomName = 'E' + x + 'S' + y;
                break;
            default:
                roomName = 'ERROR';
        }
        PERMACACHE._packedRoomNames[roomName] = char;
        PERMACACHE._unpackedRoomNames[char] = roomName;
    }
    return PERMACACHE._unpackedRoomNames[char];
}
function packPos(pos) {
    return packCoord(pos) + packRoomName(pos.roomName);
}
function unpackPos(chars) {
    const { x, y } = unpackCoord(chars[0]);
    return new RoomPosition(x, y, unpackRoomName(chars[1]));
}
function packPosList(posList) {
    let str = '';
    for (let i = 0; i < posList.length; ++i) {
        str += packPos(posList[i]);
    }
    return str;
}
function unpackPosList(chars) {
    const posList = [];
    for (let i = 0; i < chars.length; i += 2) {
        posList.push(unpackPos(chars.substr(i, 2)));
    }
    return posList;
}
global.packId = packId;
global.unpackId = unpackId;
global.packIdList = packIdList;
global.unpackIdList = unpackIdList;
global.packCoord = packCoord;
global.unpackCoord = unpackCoord;
global.unpackCoordAsPos = unpackCoordAsPos;
global.packCoordList = packCoordList;
global.unpackCoordList = unpackCoordList;
global.unpackCoordListAsPosList = unpackCoordListAsPosList;
global.packPos = packPos;
global.unpackPos = unpackPos;
global.packPosList = packPosList;
global.unpackPosList = unpackPosList;
class PackratTests {
    static testIdPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting ids...`);
        start = Game.cpu.getUsed();
        const allIds = [];
        for (const name in Game.creeps) {
            const id = Game.creeps[name].id;
            if (!id) {
                console.log(`Game.creeps.${name} has no id: ${id}! wtf`);
            }
            else {
                allIds.push();
            }
        }
        for (const id in Game.structures) {
            if (!id) {
                console.log(`Game.structures has an undefined id: ${id}! wtf`);
            }
            else {
                allIds.push(id);
            }
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing id encoding...`);
        start = Game.cpu.getUsed();
        const idsPacked = [];
        for (let i = 0, len = allIds.length; i < len; ++i) {
            idsPacked.push(packId(allIds[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / idsPacked.length}`);
        console.log(`Unpacked len: ${JSON.stringify(allIds).length} | Packed len: ${JSON.stringify(idsPacked).length}`);
        console.log(`Testing listId encoding...`);
        start = Game.cpu.getUsed();
        const idsListPacked = packIdList(allIds);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / (idsListPacked.length / 6)}`);
        console.log(`List-packed len: ${JSON.stringify(idsListPacked).length}`);
        console.log(`Testing id decoding...`);
        start = Game.cpu.getUsed();
        const idsUnpacked = [];
        for (let i = 0, len = idsPacked.length; i < len; ++i) {
            idsUnpacked.push(unpackId(idsPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / idsUnpacked.length}`);
        console.log(`Testing id list-decoding...`);
        start = Game.cpu.getUsed();
        const idsListUnpacked = unpackIdList(idsListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / idsListUnpacked.length}`);
        console.log(`Verifying equality...`);
        let idsEqual = true;
        for (let i = 0; i < allIds.length; i++) {
            if (idsUnpacked[i] != allIds[i]) {
                console.log(`Unpacked id not equal! orig: ${allIds[i]}; unpacked: ${idsUnpacked[i]}`);
                idsEqual = false;
                break;
            }
            if (idsListUnpacked[i] != allIds[i]) {
                console.log(`Unpacked id not equal! orig: ${allIds[i]}; listUnpacked: ${idsListUnpacked[i]}`);
                idsEqual = false;
                break;
            }
        }
        console.log(`Retrieved ids are equal: ${idsEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static testCoordPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting positions...`);
        start = Game.cpu.getUsed();
        const allCoord = [];
        for (const name in Game.creeps) {
            const pos = Game.creeps[name].pos;
            allCoord.push({ x: pos.x, y: pos.y });
        }
        for (const id in Game.structures) {
            const pos = Game.structures[id].pos;
            allCoord.push({ x: pos.x, y: pos.y });
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing coord encoding...`);
        start = Game.cpu.getUsed();
        const coordPacked = [];
        for (let i = 0, len = allCoord.length; i < len; ++i) {
            coordPacked.push(packCoord(allCoord[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordPacked.length}`);
        console.log(`Unpacked len: ${JSON.stringify(allCoord).length}`);
        console.log(`Packed len: ${JSON.stringify(coordPacked).length}`);
        console.log(`Testing listCoord encoding...`);
        start = Game.cpu.getUsed();
        const coordListPacked = packCoordList(allCoord);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordListPacked.length}`);
        console.log(`List-packed len: ${JSON.stringify(coordListPacked).length}`);
        console.log(`Testing coord decoding...`);
        start = Game.cpu.getUsed();
        const coordUnpacked = [];
        for (let i = 0, len = coordPacked.length; i < len; ++i) {
            coordUnpacked.push(unpackCoord(coordPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordUnpacked.length}`);
        console.log(`Testing listCoord decoding...`);
        start = Game.cpu.getUsed();
        const coordListUnpacked = unpackCoordList(coordListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordListUnpacked.length}`);
        console.log(`Testing coord to pos decoding...`);
        start = Game.cpu.getUsed();
        const coordAsPosUnpacked = [];
        for (let i = 0, len = coordPacked.length; i < len; ++i) {
            coordAsPosUnpacked.push(unpackCoordAsPos(coordPacked[i], 'W10N10'));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordAsPosUnpacked.length}`);
        console.log(`Testing listCoord to posList decoding...`);
        start = Game.cpu.getUsed();
        const coordListAsPosListUnpacked = unpackCoordListAsPosList(coordListPacked, 'W10N10');
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordListAsPosListUnpacked.length}`);
        let posEqual = true;
        for (let i = 0; i < allCoord.length; i++) {
            if (!(allCoord[i].x == coordAsPosUnpacked[i].x && allCoord[i].y == coordAsPosUnpacked[i].y)) {
                console.log(`Unpacked pos not equal! orig: ${JSON.stringify(allCoord[i])}; ` +
                    `unpacked: ${JSON.stringify(coordAsPosUnpacked[i])}`);
                posEqual = false;
                break;
            }
            if (!(allCoord[i].x == coordListAsPosListUnpacked[i].x && allCoord[i].y == coordListAsPosListUnpacked[i].y)) {
                console.log(`Unpacked pos not equal! orig: ${JSON.stringify(allCoord[i])}; ` +
                    `unpacked: ${JSON.stringify(coordListAsPosListUnpacked[i])}`);
                posEqual = false;
                break;
            }
        }
        console.log(`Retrieved coords are equal: ${posEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static testPosPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting positions...`);
        start = Game.cpu.getUsed();
        const allPos = [];
        for (const name in Game.creeps) {
            allPos.push(Game.creeps[name].pos);
        }
        for (const id in Game.structures) {
            allPos.push(Game.structures[id].pos);
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing pos encoding...`);
        start = Game.cpu.getUsed();
        const posPacked = [];
        for (let i = 0, len = allPos.length; i < len; ++i) {
            posPacked.push(packPos(allPos[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / posPacked.length}`);
        console.log(`Unpacked len: ${JSON.stringify(allPos).length}`);
        console.log(`Packed len: ${JSON.stringify(posPacked).length}`);
        console.log(`Testing listPos encoding...`);
        start = Game.cpu.getUsed();
        const posListPacked = packPosList(allPos);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / (posListPacked.length / 2)}`);
        console.log(`List-packed len: ${JSON.stringify(posListPacked).length}`);
        console.log(`Testing pos decoding...`);
        start = Game.cpu.getUsed();
        const posUnpacked = [];
        for (let i = 0, len = posPacked.length; i < len; ++i) {
            posUnpacked.push(unpackPos(posPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / posUnpacked.length}`);
        console.log(`Testing listPos decoding...`);
        start = Game.cpu.getUsed();
        const posListUnpacked = unpackPosList(posListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / posListUnpacked.length}`);
        let posEqual = true;
        for (let i = 0; i < allPos.length; i++) {
            if (!allPos[i].isEqualTo(posUnpacked[i])) {
                console.log(`Unpacked pos not equal! orig: ${allPos[i]}; unpacked: ${posUnpacked[i]}`);
                posEqual = false;
                break;
            }
            if (!allPos[i].isEqualTo(posListUnpacked[i])) {
                console.log(`Unpacked pos not equal! orig: ${allPos[i]}; unpacked: ${posListUnpacked[i]}`);
                posEqual = false;
                break;
            }
        }
        console.log(`Retrieved pos are equal: ${posEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static run() {
        PackratTests.testIdPacker();
        PackratTests.testCoordPacker();
        PackratTests.testPosPacker();
    }
}
global.PackratTests = PackratTests;

function randint(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
}
function p(probability) {
    return Math.random() < probability;
}
function pBucket(maxProbability) {
    return Math.random() < maxProbability * (Game.cpu.bucket || 1) / 10000;
}
function normal() {
    let x = 0;
    let y = 0;
    while (x === 0)
        x = Math.random();
    while (y === 0)
        y = Math.random();
    return Math.sqrt(-2.0 * Math.log(x)) * Math.cos(2.0 * Math.PI * y);
}

function normalizePos(destination) {
    return destination.pos || destination;
}
function isExit(pos) {
    return pos.x == 0 || pos.y == 0 || pos.x == 49 || pos.y == 49;
}
function sameCoord(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y;
}
function getCreepWeightInfo(creep, analyzeCarry = true) {
    const unweightedParts = analyzeCarry ? [MOVE, CARRY] : [MOVE];
    const bodyParts = _.countBy(creep.body, p => _.contains(unweightedParts, p.type) ? p.type : 'weighted');
    bodyParts.move = bodyParts.move || 0;
    bodyParts.weighted = bodyParts.weighted || 0;
    if (analyzeCarry && bodyParts[CARRY]) {
        bodyParts.weighted += Math.ceil(bodyParts[CARRY] * creep.store.getUsedCapacity() / creep.store.getCapacity());
    }
    for (const part of creep.body) {
        if (part.type == MOVE && part.boost) {
            bodyParts.move += (BOOSTS.move[part.boost].fatigue - 1);
        }
    }
    return bodyParts;
}
function getTerrainCosts(creep) {
    const data = getCreepWeightInfo(creep);
    const fatigueRatio = data.weighted / data.move;
    return {
        plainCost: Math.max(Math.ceil(fatigueRatio), 1),
        swampCost: Math.max(Math.ceil(5 * fatigueRatio), 1),
    };
}

var MatrixLib_1;
const getDefaultMatrixOptions = () => ({
    roomName: 'none',
    roomVisibile: false,
    explicitTerrainCosts: false,
    terrainCosts: {
        plainCost: 1,
        swampCost: 5,
    },
    roadCost: 'auto',
    blockExits: false,
    avoidSK: true,
    allowPortals: false,
    ignoreStructures: false,
    obstacles: '',
    swarmWidth: 1,
    swarmHeight: 1,
});
PERMACACHE.terrainMatrices = PERMACACHE.terrainMatrices || {};
const MatrixCache = {};
let MatrixLib = MatrixLib_1 = class MatrixLib {
    static getMatrix(roomName, opts, volatileOpts = {}) {
        opts = _.defaults(_.cloneDeep(opts), getDefaultMatrixOptions());
        volatileOpts = _.cloneDeep(volatileOpts);
        const room = Game.rooms[roomName];
        opts.roomName = roomName;
        opts.roomVisibile = !!room;
        const hash = MatrixLib_1.generateMatrixOptionsHash(opts);
        const volatileHash = _.isEmpty(volatileOpts) ? '' : MatrixLib_1.generateMatrixOptionsHash(volatileOpts);
        if (MatrixCache[hash + volatileHash]) {
            const expiration = MatrixCache[hash + volatileHash].expiration || Infinity;
            const invalidateCondition = MatrixCache[hash + volatileHash].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[hash + volatileHash];
            }
            else {
                return MatrixCache[hash + volatileHash].matrix;
            }
        }
        let matrix;
        let expiration;
        let invalidateCondition;
        if (MatrixCache[hash]) {
            expiration = MatrixCache[hash].expiration || Infinity;
            invalidateCondition = MatrixCache[hash].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[hash];
                matrix = undefined;
            }
            else {
                matrix = MatrixCache[hash].matrix;
            }
        }
        if (matrix === undefined) {
            if (room) {
                matrix = MatrixLib_1.generateCostMatrixForRoom(room, opts);
                const roomOwner = RoomIntel.roomOwnedBy(roomName);
                if (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
                    expiration = Game.time + 10;
                }
                else if (roomOwner && !isAlly(roomOwner)) {
                    expiration = Game.time + 25;
                }
                else {
                    expiration = Game.time + 100;
                }
                if (opts.ignoreStructures) {
                    invalidateCondition = () => false;
                }
                else {
                    const numStructures = room.structures.length;
                    invalidateCondition =
                        () => Game.rooms[roomName] && Game.rooms[roomName].structures.length != numStructures;
                }
            }
            else {
                matrix = MatrixLib_1.generateCostMatrixForInvisibleRoom(roomName, opts);
                const roomOwner = RoomIntel.roomOwnedBy(roomName);
                if (roomOwner && !isAlly(roomOwner)) {
                    expiration = Game.time + 100;
                }
                else {
                    expiration = Game.time + 1000;
                }
                invalidateCondition = () => false;
            }
            MatrixCache[hash] = {
                matrix: matrix,
                generated: Game.time,
                expiration: expiration,
                invalidateCondition: invalidateCondition,
            };
        }
        if (_.isEmpty(volatileOpts)) {
            return MatrixCache[hash].matrix;
        }
        const clonedMatrix = matrix.clone();
        MatrixLib_1.applyVolatileModifications(clonedMatrix, opts, volatileOpts);
        MatrixCache[hash + volatileHash] = {
            matrix: clonedMatrix,
            generated: Game.time,
            expiration: Game.time + 1,
            invalidateCondition: () => false,
        };
        return MatrixCache[hash + volatileHash].matrix;
    }
    static generateMatrixOptionsHash(opts) {
        return JSON.stringify(opts, Object.keys(opts).sort());
    }
    static applyVolatileModifications(clonedMatrix, opts, volatileOpts) {
        const room = Game.rooms[opts.roomName];
        if (volatileOpts.blockCreeps) {
            if (room) {
                if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
                    MatrixLib_1.blockAfterMaxPooling(clonedMatrix, room.find(FIND_CREEPS), opts.swarmWidth, opts.swarmHeight);
                }
                else {
                    MatrixLib_1.softBlock(clonedMatrix, room.find(FIND_CREEPS), opts.roomName, 100);
                }
            }
            else {
            }
        }
        return clonedMatrix;
    }
    static generateCostMatrixForRoom(room, opts) {
        const matrix = new PathFinder.CostMatrix();
        if (opts.explicitTerrainCosts) {
            MatrixLib_1.addTerrainCosts(matrix, room.name, opts.terrainCosts);
        }
        if (opts.roadCost != 'ignore') {
            if (opts.roadCost == 'auto') {
                opts.roadCost = Math.ceil(opts.terrainCosts.plainCost / 2);
            }
            for (const road of room.roads) {
                matrix.set(road.pos.x, road.pos.y, opts.roadCost);
            }
        }
        if (opts.blockExits) {
            MatrixLib_1.blockExits(matrix);
        }
        if (opts.avoidSK && Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER) {
            const skDirective = _.find(Overmind.overseer.getDirectivesInRoom(room.name), dir => dir.directiveName == 'outpostSK');
            if (!(skDirective && skDirective.age > 2500)) {
                const keeperLairInfo = RoomIntel.getKeeperLairInfo(room.name);
                const chillPositions = _.compact(_.map(keeperLairInfo || [], info => info.chillPos));
                const blockPositions = [
                    ..._.map(room.sourceKeepers, keeper => keeper.pos),
                    ..._.map(room.keeperLairs.filter(lair => (lair.ticksToSpawn || Infinity) < 100), lair => lair.pos),
                    ...chillPositions
                ];
                MatrixLib_1.blockWithinRange(matrix, blockPositions, 3);
            }
        }
        if (opts.allowPortals) {
            MatrixLib_1.softBlock(matrix, room.portals, room.name, MatrixLib_1.settings.portalCost);
        }
        else {
            MatrixLib_1.block(matrix, room.portals);
        }
        if (!opts.ignoreStructures) {
            const impassibleStructures = _.filter(room.structures, s => !s.isWalkable);
            const impassibleConstructionSites = _.filter(room.constructionSites, c => !c.isWalkable);
            const alliedConstructionSites = _.filter(room.hostileConstructionSites, c => isAlly(c.owner.username));
            const blockPositions = _.map([...impassibleStructures,
                ...impassibleConstructionSites,
                ...alliedConstructionSites], s => s.pos);
            MatrixLib_1.block(matrix, blockPositions);
        }
        if (opts.obstacles.length > 0) {
            const obstacles = _.filter(unpackPosList(opts.obstacles), pos => pos.roomName == room.name);
            MatrixLib_1.block(matrix, obstacles);
        }
        if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
            if (!opts.explicitTerrainCosts) {
                log.error(`Swarm matrix generation requires opts.explicitTerrainCosts! opts: ${JSON.stringify(opts)}`);
            }
            MatrixLib_1.applyMovingMaxPool(matrix, opts.swarmWidth, opts.swarmHeight);
        }
        return matrix;
    }
    static generateCostMatrixForInvisibleRoom(roomName, opts) {
        const matrix = new PathFinder.CostMatrix();
        if (opts.explicitTerrainCosts) {
            MatrixLib_1.addTerrainCosts(matrix, roomName, opts.terrainCosts);
        }
        if (opts.roadCost !== undefined) {
        }
        if (opts.blockExits) {
            MatrixLib_1.blockExits(matrix);
        }
        if (opts.avoidSK && Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
            const skDirective = _.find(Overmind.overseer.getDirectivesInRoom(roomName), dir => dir.directiveName == 'outpostSK');
            if (!(skDirective && skDirective.age > 2500)) {
                const keeperLairInfo = RoomIntel.getKeeperLairInfo(roomName);
                const chillPositions = _.compact(_.map(keeperLairInfo || [], info => info.chillPos));
                MatrixLib_1.blockWithinRange(matrix, chillPositions, 3);
            }
        }
        const portalPositions = _.map(RoomIntel.getPortalInfo(roomName), portalInfo => portalInfo.pos);
        if (opts.allowPortals) {
            MatrixLib_1.softBlock(matrix, portalPositions, roomName, MatrixLib_1.settings.portalCost);
        }
        else {
            MatrixLib_1.block(matrix, portalPositions);
        }
        if (!opts.ignoreStructures) {
            const owner = RoomIntel.roomOwnedBy(roomName) || '_noOwner_';
            const info = RoomIntel.getImportantStructureInfo(roomName);
            if (info) {
                if (!isAlly(owner))
                    MatrixLib_1.block(matrix, info.rampartPositions);
                MatrixLib_1.block(matrix, info.wallPositions);
                MatrixLib_1.block(matrix, info.towerPositions);
                MatrixLib_1.block(matrix, info.spawnPositions);
                if (info.storagePos)
                    MatrixLib_1.block(matrix, [info.storagePos]);
                if (info.terminalPos)
                    MatrixLib_1.block(matrix, [info.terminalPos]);
            }
        }
        if (opts.obstacles.length > 0) {
            const obstacles = _.filter(unpackPosList(opts.obstacles), pos => pos.roomName == roomName);
            MatrixLib_1.block(matrix, obstacles);
        }
        if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
            if (!opts.explicitTerrainCosts) {
                log.error(`Swarm matrix generation requires opts.explicitTerrainCosts! opts: ${JSON.stringify(opts)}`);
            }
            MatrixLib_1.applyMovingMaxPool(matrix, opts.swarmWidth, opts.swarmHeight);
        }
        return matrix;
    }
    static addMatrices(matrixToModify, addCosts) {
        for (let i = 0; i < 2500; i++) {
            matrixToModify._bits[i] = Math.min(Math.max(0, matrixToModify._bits[i] + addCosts._bits[i]), 255);
        }
        return matrixToModify;
    }
    static fillMatrix(matrixToModify, value) {
        value = Math.min(Math.max(0, value), 255);
        matrixToModify._bits.fill(value);
        return matrixToModify;
    }
    static block(matrix, positions) {
        let pos;
        for (let i = 0; i < positions.length; i++) {
            pos = normalizePos(positions[i]);
            matrix.set(pos.x, pos.y, 0xff);
        }
        return matrix;
    }
    static softBlock(matrix, positions, roomName, cost) {
        let pos;
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let i = 0; i < positions.length; i++) {
            pos = normalizePos(positions[i]);
            if (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL)
                continue;
            matrix.set(pos.x, pos.y, Math.max(cost, matrix.get(pos.x, pos.y)));
        }
        return matrix;
    }
    static blockWithinRange(matrix, positions, range) {
        let x, y;
        let pos;
        for (let i = 0; i < positions.length; i++) {
            pos = positions[i];
            for (let dx = -range; dx <= range; dx++) {
                x = pos.x + dx;
                if (x < 0 || x > 49)
                    continue;
                for (let dy = -range; dy <= range; dy++) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49)
                        continue;
                    matrix.set(x, y, 0xff);
                }
            }
        }
        return matrix;
    }
    static blockImpassibleStructures(matrix, room) {
        const impassibleStuctures = _.filter(room.find(FIND_STRUCTURES), (s) => !s.isWalkable);
        const blockPositions = _.map(impassibleStuctures, s => s.pos);
        MatrixLib_1.block(matrix, blockPositions);
        return matrix;
    }
    static addPyramidPotential(matrix, pos, range, maxCost, includeTerrain = true, terrainCosts = { plainCost: 1, swampCost: 5 }) {
        if (Math.floor(maxCost / range) != maxCost / range) {
            log.error(`MatrixLib.addPyramidPotential: maxCost must be divisible by (range+1)!`);
            return matrix;
        }
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        const slope = maxCost / (range + 1);
        let x, y, dx, dy, r, cost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49)
                continue;
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49)
                    continue;
                cost = matrix.get(x, y);
                if (includeTerrain) {
                    if (cost === 0) {
                        if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                            cost += terrainCosts.swampCost;
                        }
                        else {
                            cost += terrainCosts.plainCost;
                        }
                    }
                }
                r = Math.max(Math.abs(dx), Math.abs(dy));
                cost += slope * (range + 1 - r);
                matrix.set(x, y, cost);
            }
        }
        return matrix;
    }
    static addSquarePotential(matrix, pos, range, addCost, includeTerrain = true, terrainCosts = { plainCost: 1, swampCost: 5 }) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        let x, y, dx, dy, cost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49)
                continue;
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49)
                    continue;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL)
                    continue;
                cost = matrix.get(x, y);
                if (includeTerrain) {
                    if (cost === 0) {
                        if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                            cost += terrainCosts.swampCost;
                        }
                        else {
                            cost += terrainCosts.plainCost;
                        }
                    }
                }
                matrix.set(x, y, addCost + cost);
            }
        }
        return matrix;
    }
    static applyMovingMaxPool(matrix, width, height) {
        let x, y, dx, dy;
        let maxCost, cost;
        for (x = 0; x <= 50 - width; x++) {
            for (y = 0; y <= 50 - height; y++) {
                maxCost = matrix.get(x, y);
                for (dx = 0; dx < width; dx++) {
                    for (dy = 0; dy < height; dy++) {
                        cost = matrix.get(x + dx, y + dy);
                        if (cost > maxCost)
                            maxCost = cost;
                    }
                }
                matrix.set(x, y, maxCost);
            }
        }
        return matrix;
    }
    static blockAfterMaxPooling(matrix, positions, width, height) {
        let pos;
        let x, y, dx, dy;
        for (let i = 0; i < positions.length; ++i) {
            pos = normalizePos(positions[i]);
            for (dx = 0; dx > -width; dx--) {
                x = pos.x + dx;
                if (x < 0 || x > 49)
                    continue;
                for (dy = 0; dy > -height; dy--) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49)
                        continue;
                    matrix.set(x, y, 0xff);
                }
            }
        }
        return matrix;
    }
    static setToMaxCostAfterMaxPooling(matrix, positions, width, height, cost) {
        let pos;
        let x, y, dx, dy;
        for (let i = 0; i < positions.length; ++i) {
            pos = normalizePos(positions[i]);
            for (dx = 0; dx > -width; dx--) {
                x = pos.x + dx;
                if (x < 0 || x > 49)
                    continue;
                for (dy = 0; dy > -height; dy--) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49)
                        continue;
                    if (matrix.get(x, y) < cost) {
                        matrix.set(x, y, cost);
                    }
                }
            }
        }
        return matrix;
    }
    static addCostAfterMaxPooling(matrix, positions, width, height, cost) {
        const addMatrix = new PathFinder.CostMatrix();
        MatrixLib_1.setToMaxCostAfterMaxPooling(addMatrix, positions, width, height, cost);
        MatrixLib_1.addMatrices(matrix, addMatrix);
        return matrix;
    }
    static setInRange(matrix, pos, range, cost, addDefaultTerrainCosts = false) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        let x, y, dx, dy, currentCost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49)
                continue;
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49)
                    continue;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL)
                    continue;
                currentCost = matrix.get(x, y);
                if (currentCost === 0) {
                    if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                        currentCost += 10;
                    }
                    else {
                        currentCost += 2;
                    }
                }
                matrix.set(x, y, addDefaultTerrainCosts ? cost + currentCost : cost);
            }
        }
        return matrix;
    }
    static getTerrainMatrix(roomName, terrainCosts, skipClone = false) {
        const key = `${roomName}_${terrainCosts.plainCost}_${terrainCosts.swampCost}`;
        if (PERMACACHE.terrainMatrices[key] === undefined) {
            const matrix = new PathFinder.CostMatrix();
            const terrain = Game.map.getRoomTerrain(roomName);
            for (let y = 0; y < 50; ++y) {
                for (let x = 0; x < 50; ++x) {
                    switch (terrain.get(x, y)) {
                        case TERRAIN_MASK_SWAMP:
                            matrix.set(x, y, terrainCosts.swampCost);
                            break;
                        case TERRAIN_MASK_WALL:
                            matrix.set(x, y, 0xff);
                            break;
                        default:
                            matrix.set(x, y, terrainCosts.plainCost);
                            break;
                    }
                }
            }
            PERMACACHE.terrainMatrices[key] = matrix;
        }
        if (skipClone) {
            return PERMACACHE.terrainMatrices[key];
        }
        return PERMACACHE.terrainMatrices[key].clone();
    }
    static getSwarmTerrainMatrix(roomName, terrainCosts, width, height, exitCost = 10, skipClone = false) {
        const key = `s_${roomName}_${terrainCosts.plainCost}_${terrainCosts.swampCost}_${width}_${height}_${exitCost}`;
        if (PERMACACHE.terrainMatrices[key] === undefined) {
            const terrainMatrix = MatrixLib_1.getTerrainMatrix(roomName, terrainCosts);
            MatrixLib_1.setExitCosts(terrainMatrix, roomName, exitCost);
            MatrixLib_1.applyMovingMaxPool(terrainMatrix, width, height);
            PERMACACHE.terrainMatrices[key] = terrainMatrix;
        }
        if (skipClone) {
            return PERMACACHE.terrainMatrices[key];
        }
        return PERMACACHE.terrainMatrices[key].clone();
    }
    static addTerrainCosts(matrix, roomName, terrainCosts) {
        const terrainMatrix = MatrixLib_1.getTerrainMatrix(roomName, terrainCosts, true);
        MatrixLib_1.addMatrices(matrix, terrainMatrix);
        return matrix;
    }
    static blockExits(matrix, rangeToEdge = 0) {
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                matrix.set(x, y, 0xff);
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
                matrix.set(x, y, 0xff);
            }
        }
        return matrix;
    }
    static setExitCosts(matrix, roomName, cost, rangeToEdge = 0) {
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, cost);
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, cost);
            }
        }
        return matrix;
    }
    static blockMyCreeps(matrix, room) {
        _.forEach(room.creeps, creep => {
            matrix.set(creep.pos.x, creep.pos.y, 0xff);
        });
    }
    static blockHostileCreeps(matrix, room) {
        _.forEach(room.hostiles, hostile => {
            matrix.set(hostile.pos.x, hostile.pos.y, 0xff);
        });
    }
    static blockAlliedCreeps(matrix, room) {
        _.forEach(room.friendlies, hostile => {
            matrix.set(hostile.pos.x, hostile.pos.y, 0xff);
        });
    }
    static blockAllCreeps(matrix, room) {
        _.forEach(room.find(FIND_CREEPS), creep => {
            matrix.set(creep.pos.x, creep.pos.y, 0xff);
        });
    }
    static preferRoads(matrix, room) {
        _.forEach(room.roads, road => {
            if (matrix.get(road.pos.x, road.pos.y) < 0xfe) {
                matrix.set(road.pos.x, road.pos.y, 1);
            }
        });
    }
    static getRampartMask(room, onlyMy = true, value = 0xff) {
        const key = `rampartMask_${room.name}_onlymy_${onlyMy}`;
        let matrix;
        let expiration;
        let invalidateCondition;
        if (MatrixCache[key]) {
            expiration = MatrixCache[key].expiration || Infinity;
            invalidateCondition = MatrixCache[key].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[key];
                matrix = undefined;
            }
            else {
                matrix = MatrixCache[key].matrix;
            }
        }
        if (!matrix) {
            matrix = new PathFinder.CostMatrix();
            MatrixLib_1.fillMatrix(matrix, 0xff);
            const ramparts = onlyMy ? _.filter(room.ramparts, rampart => rampart.my) : room.ramparts;
            for (const rampart of ramparts) {
                matrix.set(rampart.pos.x, rampart.pos.y, 0);
            }
        }
        const numRamparts = room.ramparts.length;
        MatrixCache[key] = {
            matrix: matrix,
            generated: Game.time,
            expiration: Game.time + 100,
            invalidateCondition: () => Game.rooms[room.name] && Game.rooms[room.name].ramparts.length != numRamparts,
        };
        return MatrixCache[key].matrix;
    }
    static setWalkableRampartCostToOne(matrix, room) {
        _.forEach(room.walkableRamparts, rampart => {
            if (matrix.get(rampart.pos.x, rampart.pos.y) < 0xfe) {
                matrix.set(rampart.pos.x, rampart.pos.y, 1);
            }
        });
    }
    static blockNonRamparts(matrix, room, onlyMy = true) {
        const mask = MatrixLib_1.getRampartMask(room, onlyMy);
        MatrixLib_1.addMatrices(matrix, mask);
    }
    static getRows(matrix) {
        const rows = [];
        for (let y = 0; y < 50; ++y) {
            rows.push(new Uint8Array(50));
            for (let x = 0; x < 50; ++x) {
                rows[y][x] = matrix.get(x, y);
            }
        }
        return rows;
    }
    static getColumns(matrix) {
        const columns = [];
        for (let x = 0; x < 50; ++x) {
            columns.push(new Uint8Array(50));
            for (let y = 0; y < 50; ++y) {
                columns[x][y] = matrix.get(x, y);
            }
        }
        return columns;
    }
    static getMaxValue(matrix) {
        return _.max(matrix._bits);
    }
    static print(matrix, opts = { equalSpacing: true, useColorMap: true }) {
        const longestNumPerColumn = _.map(MatrixLib_1.getColumns(matrix), column => _.max(_.map(column, n => n.toString().length)));
        if (opts.equalSpacing) {
            const longestNum = _.max(longestNumPerColumn);
            for (let i = 0; i < longestNumPerColumn.length; ++i) {
                longestNumPerColumn[i] = longestNum;
            }
        }
        const maxVal = MatrixLib_1.getMaxValue(matrix);
        let msg = '';
        let num, percentOfMax, numAsStr;
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                num = matrix.get(x, y);
                numAsStr = matrix.get(x, y).toString().padEnd(longestNumPerColumn[x] + 1);
                if (opts.useColorMap && maxVal > 0) {
                    percentOfMax = Math.round(255 * num / maxVal);
                    msg += color(numAsStr, rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax));
                }
                else {
                    msg += numAsStr;
                }
            }
            msg += '\n';
        }
        console.log(msg);
    }
    static visualize(matrix, roomName) {
        Visualizer.displayCostMatrix(matrix, roomName);
    }
};
MatrixLib.settings = {
    portalCost: 20,
};
MatrixLib.testMatrices = {
    checkerboard: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, (x + y) % 2);
            }
        }
        return matrix;
    },
    checkerboard2: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, (x + y + 1) % 2);
            }
        }
        return matrix;
    },
    xIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, x);
            }
        }
        return matrix;
    },
    yIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, y);
            }
        }
        return matrix;
    },
    diagonalIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, x + y);
            }
        }
        return matrix;
    }
};
MatrixLib = MatrixLib_1 = __decorate([
    profile
], MatrixLib);
global.MatrixCache = MatrixCache;
global.MatrixLib = MatrixLib;

const asciiLogo = ['___________________________________________________________',
    '',
    ' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/',
    '',
    '_______________________ Screeps AI ________________________'];
const asciiLogoSmall = [' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/'];
const asciiLogoRL = [' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/',
    '....... R E I N F O R C E M E N T   L E A R N I N G .......'];
const _logoComponents = {
    black: {
        style: { fill: '#000000', stroke: '#000000', strokeWidth: 0 },
        points: [[-4.4, -0.34], [-3.44, -1.04], [-3.08, -1.04], [-2.78, -0.82], [-2.7, -0.6], [-2.92, -0.24], [-3.36, -0.24], [-3.58, -0.5], [-3.8, -0.28], [-4.14, 0.42], [-4.22, 1.24], [-3.6, 0.42], [-2.98, 0.46], [-2.84, 0.72], [-2.9, 1.02], [-3.26, 1.22], [-3.68, 1.12], [-3.72, 1.22], [-3.76, 2.18], [-3.58, 2.9], [-3.22, 1.8], [-2.72, 1.66], [-2.4, 2.08], [-2.64, 2.44], [-3.1, 2.42], [-3.1, 2.86], [-2.86, 3.4], [-2.52, 3.74], [-2.58, 3.08], [-2.34, 2.86], [-1.98, 2.82], [-1.48, 3.12], [-1.34, 3.72], [-1.64, 4.16], [-2.08, 4.32], [-2.78, 4.24], [-3.4, 3.84], [-3.02, 4.34], [-2.56, 4.6], [-0.94, 4.78], [4.0e-2, 4.5], [0.86, 3.9], [-0.44, 3.18], [-0.46, 2.86], [0.88, 2.84], [2.02, 3.2], [3.1, 2.22], [4.18, 0.6], [4.54, -1], [3.84, 0], [3.5, 0.12], [3.18, 2.0e-2], [3.14, -0.46], [3.38, -0.6], [3.82, -0.5], [4, -0.94], [4.08, -1.88], [3.96, -2.6], [3.56, -1.54], [3.16, -1.22], [2.78, -1.28], [2.6, -1.6], [2.7, -1.88], [2.96, -2.02], [3.4, -1.92], [3.46, -2.12], [3.38, -2.98], [2.9, -3.98], [2.52, -4.32], [2.7, -3.58], [2.54, -2.82], [2.22, -2.38], [1.7, -2.36], [1.48, -2.64], [1.56, -3.1], [2.18, -3.24], [1.94, -3.9], [1.2, -4.62], [0.14, -5.14], [0.88, -4.18], [0.9, -3.54], [0.66, -3.04], [0.3, -2.82], [-0.14, -2.9], [-0.2, -3.42], [0.28, -3.66], [-0.38, -4.16], [-1.26, -4.32], [-2.4, -4.22], [-1.64, -4.02], [-1.08, -3.64], [-0.82, -3.04], [-0.88, -2.56], [-1.12, -2.4], [-1.5, -2.44], [-1.68, -2.7], [-1.56, -3.12], [-1.84, -3.2], [-2.72, -3.16], [-3.44, -2.84], [-3.98, -2.34], [-3.38, -2.5], [-2.48, -2.36], [-2.12, -2.12], [-2.06, -1.7], [-2.18, -1.52], [-2.56, -1.44], [-2.82, -1.6], [-2.84, -2.06], [-3.38, -1.84], [-4.06, -1.18], [-4.4, -0.36]],
    },
    blue: {
        style: { fill: '#6482B0', stroke: '#6482B0', strokeWidth: 0 },
        points: [[-2.48, -0.72], [-1.5, -0.34], [-1.18, -0.88], [-0.74, -1.24], [-6.0e-2, -1.46], [0.54, -1.44], [0.94, -1.34], [1.82, -0.46], [2.74, -0.9], [2.92, -0.42], [3.02, 0.32], [2.9, 1.02], [2.52, 1.86], [1.94, 2.5], [1.2, 2.94], [0.82, 2.02], [1.32, 1.72], [1.56, 1.48], [1.8, 1.1], [1.98, 0.44], [1.94, 0], [1.8, -0.46], [0.94, -1.36], [1.34, -2.3], [0.5, -2.54], [-0.12, -2.54], [-0.86, -2.36], [-1.38, -2.1], [-1.82, -1.76], [-2.26, -1.22], [-2.48, -0.74]],
    },
    red: {
        style: { fill: '#EA3747', stroke: '#EA3747', strokeWidth: 0 },
        points: [[0.94, -1.3], [1.28, -1.08], [1.58, -0.78], [1.78, -0.46], [2.7, -0.92], [2.72, -1], [2.44, -1.46], [2.02, -1.9], [1.42, -2.28], [0.94, -1.32]],
    },
    pink: {
        style: { fill: '#FF0080', stroke: '#FF0080', strokeWidth: 0 },
        points: [[-1.4, 0.32], [-0.92, 0.2], [-0.46, -6.0e-2], [-8.0e-2, -0.5], [0.12, -0.98], [0.14, -1.18], [0.2, -1.18], [0.22, -0.98], [0.4, -0.54], [0.8, -6.0e-2], [1.26, 0.2], [1.74, 0.32], [1.62, 0.3], [1.62, 0.36], [1.26, 0.44], [0.78, 0.72], [0.38, 1.22], [0.18, 1.84], [-6.0e-2, 1.18], [-0.46, 0.7], [-0.92, 0.44], [-1.38, 0.34]],
    },
    lgray: {
        style: { fill: '#ABB7C5', stroke: '#ABB7C5', strokeWidth: 0 },
        points: [[-2.64, 1.04], [-2.34, 1.78], [-2.06, 2.18], [-1.56, 2.64], [-0.98, 2.96], [-0.62, 3.08], [-0.52, 3.06], [-0.28, 2.06], [-0.72, 1.88], [-1.06, 1.62], [-1.36, 1.26], [-1.58, 0.76], [-2.56, 0.94], [-2.64, 1.02]],
    },
    purple: {
        style: { fill: '#2F0092', stroke: '#2F0092', strokeWidth: 0 },
        points: [[-1.48, 0.4], [-1.38, -0.24], [-1.04, -0.8], [-0.46, -1.2], [0.22, -1.32], [0.14, -1.24], [0.1, -0.94], [-8.0e-2, -0.52], [-0.42, -0.1], [-0.84, 0.16], [-1.4, 0.3], [-0.94, 0.44], [-0.34, 0.82], [4.0e-2, 1.4], [0.18, 1.88], [0.32, 1.36], [0.72, 0.78], [1.28, 0.44], [1.74, 0.34], [1.06, 0.1], [0.6, -0.26], [0.24, -0.94], [0.2, -1.24], [0.28, -1.32], [0.74, -1.22], [1.18, -0.98], [1.46, -0.7], [1.72, -0.24], [1.82, 0.26], [1.78, 0.68], [1.6, 1.14], [1.28, 1.54], [0.84, 1.82], [0.46, 1.94], [0.18, 1.98], [-0.46, 1.84], [-0.82, 1.64], [-1.22, 1.2], [-1.4, 0.82], [-1.46, 0.4]]
    },
    dgray: {
        style: { fill: '#303030', stroke: '#303030', strokeWidth: 0 },
        points: [[-2.42, 0.52], [-2.4, -8.0e-2], [-2.28, -0.56], [-1.52, -0.3], [-1.62, 0.24], [-1.58, 0.7], [-0.2, 2.06], [0.34, 2.1], [0.8, 2.02], [1.06, 2.7], [1.04, 2.78], [0.54, 2.92], [6.0e-2, 2.94], [-0.42, 2.86], [-0.22, 2.06], [-0.26, 2.08], [-1.6, 0.7], [-2.36, 0.86], [-2.4, 0.52]]
    },
};
const _logoText = {
    V: {
        coords: [75, 500],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-3.94, -3.7], [-3.72, -3.86], [-3.58, -3.68], [-1, 2.54], [-0.62, 2.9], [-0.16, 2.96], [0.46, 2.6], [3.1, -3.72], [3.38, -3.82], [3.4, -3.56], [0.86, 2.52], [0.48, 3.04], [0, 3.26], [-0.66, 3.22], [-1.26, 2.72], [-3.92, -3.68]]
    },
    E: {
        coords: [500, 880],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.28, 0.52], [-4.1, 1.3], [-3.7, 2.04], [-3.12, 2.64], [-2.4, 3.06], [-1.64, 3.26], [1.4, 3.2], [1.4, 3], [1.16, 2.9], [-1.5, 2.92], [-2.2, 2.76], [-3.14, 2.16], [-3.76, 1.2], [-3.92, 0.52], [-3.84, -0.12], [0.84, -0.12], [0.96, -0.24], [0.78, -0.48], [-3.9, -0.48], [-3.92, -1.12], [-3.7, -1.94], [-3.26, -2.62], [-2.6, -3.16], [-1.46, -3.52], [1.38, -3.56], [1.4, -3.8], [1.2, -3.88], [-1.42, -3.88], [-2.82, -3.44], [-3.88, -2.36], [-4.28, -1.12], [-4.26, 0.52]]
    },
    R1: {
        coords: [850, 1000],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.36, 3.1], [-4.36, -2.56], [-4.26, -2.96], [-3.82, -3.56], [-3.38, -3.8], [-1.88, -3.88], [-1.78, -3.5], [-3.2, -3.48], [-3.58, -3.3], [-3.88, -2.94], [-4, -2.54], [-4, 0.3], [-1.78, 0.36], [-1.9, 0.38], [-1.96, 0.72], [-1.78, 0.74], [-3.98, 0.74], [-3.98, 3.06], [-4.1, 3.26], [-4.3, 3.24], [-4.34, 3.1]]
    },
    R2: {
        coords: [1000, 1200],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.78, 0.74], [-4.78, 0.36], [-3.1, 0.36], [-2.22, -2.0e-2], [-1.62, -0.78], [-1.46, -1.78], [-1.74, -2.58], [-2.38, -3.22], [-3.28, -3.52], [-4.78, -3.5], [-4.7, -3.86], [-4.78, -3.88], [-3.12, -3.86], [-2.12, -3.48], [-1.62, -3.02], [-1.26, -2.42], [-1.1, -1.78], [-1.2, -0.88], [-1.56, -0.18], [-2.04, 0.3], [-2.64, 0.62], [-3.4, 0.8], [-1.22, 2.96], [-1.22, 3.24], [-1.44, 3.26], [-3.94, 0.74], [-4.76, 0.72]]
    },
    M: {
        coords: [1200, 1799],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-3.82, 3.14], [-3.6, 3.28], [-3.48, 3.08], [-2.52, -3.48], [-2.26, -3.52], [-2.1, -3.34], [0.28, 3.04], [0.56, 3.26], [0.9, 3.28], [1.3, 2.92], [3.62, -3.34], [3.88, -3.54], [4.14, -3.3], [5.02, 3.16], [5.28, 3.26], [4.44, -3.4], [4.28, -3.7], [3.98, -3.84], [3.56, -3.76], [3.34, -3.48], [1.02, 2.78], [0.78, 2.98], [0.52, 2.82], [-1.88, -3.6], [-2.24, -3.84], [-2.78, -3.68], [-3.8, 3.12]]
    },
    I: {
        coords: [1750, 1850],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.58, 3.1], [-4.32, 3.26], [-4.2, 3.06], [-4.2, -3.66], [-4.46, -3.86], [-4.58, -3.7], [-4.56, 3.1]]
    },
    N: {
        coords: [1850, 2250],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.46, 3.16], [-4.46, -3.4], [-4.34, -3.66], [-3.88, -3.88], [-3.4, -3.64], [1.52, 2.74], [1.84, 2.96], [2.12, 2.64], [2.12, -3.76], [2.36, -3.82], [2.42, 2.8], [2.28, 3.08], [1.66, 3.26], [1.38, 3.08], [-3.62, -3.4], [-3.96, -3.54], [-4.16, -3.28], [-4.16, 3.16], [-4.44, 3.18]]
    },
    D: {
        coords: [2250, 2700],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.12, 1.82], [-3.76, 2.78], [-2.8, 3.28], [-0.36, 3.24], [0.3, 3.04], [1.14, 2.5], [1.78, 1.68], [2.08, 0.84], [2.04, -1.6], [1.68, -2.44], [1.06, -3.16], [0.28, -3.64], [-0.56, -3.86], [-2.88, -3.86], [-3, -3.82], [-2.92, -3.48], [-0.32, -3.46], [0.52, -3.12], [1.2, -2.52], [1.6, -1.84], [1.78, -1.1], [1.78, 0.54], [1.38, 1.68], [0.68, 2.42], [-0.38, 2.88], [-2.78, 2.92], [-3.5, 2.54], [-3.74, 1.98], [-3.74, -2.58], [-3.46, -3.18], [-2.94, -3.48], [-3.06, -3.82], [-3.72, -3.42], [-4.08, -2.72], [-4.1, 1.8]]
    },
};
const logoX = 2.5;
const logoY = 3.0;
const logoScale = 0.6;
const logoComponents = _.mapValues(_logoComponents, c => ({
    style: c.style,
    points: _.map(c.points, xy => [logoX + logoScale * xy[0],
        logoY + logoScale * xy[1]])
}));
const textX = logoX + 5.6 * logoScale;
const textY = logoY + .5 * logoScale;
const textScale = 0.6 * logoScale;
const charScale = 0.052 * textScale;
let offset = 0;
const logoText = _.mapValues(_logoText, function (c) {
    const ret = {
        style: c.style,
        points: _.map(c.points, xy => [textX + textScale * (offset + xy[0]),
            textY + textScale * xy[1]])
    };
    offset += charScale * (c.coords[1] - c.coords[0]);
    return ret;
});

var Visualizer_1;
const TEXT_COLOR = '#c9c9c9';
const TEXT_SIZE = .8;
const CHAR_WIDTH = TEXT_SIZE * 0.4;
const CHAR_HEIGHT = TEXT_SIZE * 0.9;
let Visualizer = Visualizer_1 = class Visualizer {
    static get enabled() {
        return Memory.settings.enableVisuals;
    }
    static textStyle(size = 1, style = {}) {
        return _.defaults(style, {
            color: TEXT_COLOR,
            align: 'left',
            font: `${size * TEXT_SIZE} Trebuchet MS`,
            opacity: 0.8,
        });
    }
    static circle(pos, color = 'red', opts = {}) {
        _.defaults(opts, {
            fill: color,
            radius: 0.35,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).circle(pos.x, pos.y, opts);
    }
    static rect(pos, color = 'red', opts = {}) {
        _.defaults(opts, {
            fill: color,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).rect(pos.x, pos.y, 1, 1, opts);
    }
    static marker(pos, opts = {}) {
        return new RoomVisual(pos.roomName).animatedPosition(pos.x, pos.y, opts);
    }
    static drawStructureMap(structureMap) {
        if (!this.enabled)
            return;
        const vis = {};
        for (const structureType in structureMap) {
            for (const pos of structureMap[structureType]) {
                if (!vis[pos.roomName]) {
                    vis[pos.roomName] = new RoomVisual(pos.roomName);
                }
                vis[pos.roomName].structure(pos.x, pos.y, structureType);
            }
        }
        for (const roomName in vis) {
            vis[roomName].connectRoads();
        }
    }
    static drawLayout(layout, anchor, opts = {}) {
        if (!this.enabled)
            return;
        _.defaults(opts, { opacity: 0.5 });
        const vis = new RoomVisual(anchor.roomName);
        for (const structureType in layout[8].buildings) {
            for (const pos of layout[8].buildings[structureType].pos) {
                const dx = pos.x - layout.data.anchor.x;
                const dy = pos.y - layout.data.anchor.y;
                vis.structure(anchor.x + dx, anchor.y + dy, structureType, opts);
            }
        }
        vis.connectRoads(opts);
    }
    static drawRoads(positoins) {
        const pointsByRoom = _.groupBy(positoins, pos => pos.roomName);
        for (const roomName in pointsByRoom) {
            const vis = new RoomVisual(roomName);
            for (const pos of pointsByRoom[roomName]) {
                vis.structure(pos.x, pos.y, STRUCTURE_ROAD);
            }
            vis.connectRoads({ color: "red", opacity: 0.3, });
        }
    }
    static drawPath(path, style) {
        const pointsByRoom = _.groupBy(path, pos => pos.roomName);
        for (const roomName in pointsByRoom) {
            new RoomVisual(roomName).poly(pointsByRoom[roomName], style);
        }
    }
    static displayCostMatrix(matrix, roomName, opts = { dots: true, displayZero: true }) {
        opts = _.defaults(opts, { dots: true, displayZero: true });
        const vis = new RoomVisual(roomName);
        let x, y, cost, percentOfMax;
        let color;
        const maxVal = MatrixLib.getMaxValue(matrix) + 1;
        if (opts.dots) {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = matrix.get(x, y);
                    if (cost > 0) {
                        percentOfMax = Math.round(255 * cost / maxVal);
                        color = rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax);
                        vis.circle(x, y, { radius: matrix.get(x, y) / maxVal / 2, fill: color });
                    }
                }
            }
        }
        else {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = matrix.get(x, y);
                    if (opts.displayZero || cost != 0) {
                        percentOfMax = Math.round(255 * cost / maxVal);
                        color = rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax);
                        vis.text(matrix.get(x, y).toString(), x, y, { color: color });
                    }
                }
            }
        }
    }
    static showInfo(info, calledFrom, opts = {}) {
        if (calledFrom.room) {
            return calledFrom.room.visual.infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);
        }
        else {
            return new RoomVisual(calledFrom.pos.roomName).infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);
        }
    }
    static section(title, pos, width, height) {
        const vis = new RoomVisual(pos.roomName);
        vis.rect(pos.x, pos.y - CHAR_HEIGHT, width, 1.1 * CHAR_HEIGHT, { opacity: 0.15 });
        vis.box(pos.x, pos.y - CHAR_HEIGHT, width, height + (1.1 + .25) * CHAR_HEIGHT, { color: TEXT_COLOR });
        vis.text(title, pos.x + .25, pos.y - .05, this.textStyle());
        return { x: pos.x + 0.25, y: pos.y + 1.1 * CHAR_HEIGHT };
    }
    static infoBox(header, content, pos, width) {
        const height = CHAR_HEIGHT * (content.length || 1);
        const { x, y } = this.section(header, pos, width, height);
        if (content.length > 0) {
            if (_.isArray(content[0])) {
                this.table(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName
                });
            }
            else {
                this.multitext(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName
                });
            }
        }
        const spaceBuffer = 0.5;
        return y + height + spaceBuffer;
    }
    static text(text, pos, size = 1, style = {}) {
        new RoomVisual(pos.roomName).text(text, pos.x, pos.y, this.textStyle(size, style));
    }
    static barGraph(progress, pos, width = 7, scale = 1) {
        const vis = new RoomVisual(pos.roomName);
        let percent;
        let mode;
        if (typeof progress === 'number') {
            percent = progress;
            mode = 'percent';
        }
        else {
            percent = progress[0] / progress[1];
            mode = 'fraction';
        }
        vis.box(pos.x, pos.y - CHAR_HEIGHT * scale, width, 1.1 * scale * CHAR_HEIGHT, { color: TEXT_COLOR });
        vis.rect(pos.x, pos.y - CHAR_HEIGHT * scale, percent * width, 1.1 * scale * CHAR_HEIGHT, {
            fill: TEXT_COLOR,
            opacity: 0.4,
            strokeWidth: 0
        });
        if (mode == 'percent') {
            vis.text(`${Math.round(100 * percent)}%`, pos.x + width / 2, pos.y - .1 * CHAR_HEIGHT, this.textStyle(1, { align: 'center' }));
        }
        else {
            const [num, den] = progress;
            vis.text(`${num}/${den}`, pos.x + width / 2, pos.y - .1 * CHAR_HEIGHT, this.textStyle(1, { align: 'center' }));
        }
    }
    static table(data, pos) {
        if (data.length == 0) {
            return;
        }
        const colPadding = 4;
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        const columns = Array(_.first(data).length).fill(0);
        for (const entries of data) {
            for (let i = 0; i < entries.length - 1; i++) {
                columns[i] = Math.max(columns[i], entries[i].length);
            }
        }
        let dy = 0;
        for (const entries of data) {
            let dx = 0;
            for (const i in entries) {
                vis.text(entries[i], pos.x + dx, pos.y + dy, style);
                dx += CHAR_WIDTH * (columns[i] + colPadding);
            }
            dy += CHAR_HEIGHT;
        }
    }
    static multitext(lines, pos) {
        if (lines.length == 0) {
            return;
        }
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        let dy = 0;
        for (const line of lines) {
            vis.text(line, pos.x, pos.y + dy, style);
            dy += CHAR_HEIGHT;
        }
    }
    static drawHUD() {
        new RoomVisual().multitext(asciiLogo, 0, 0, { textfont: 'monospace' });
    }
    static drawLogo() {
        new RoomVisual().poly(logoComponents.black.points, logoComponents.black.style)
            .poly(logoComponents.dgray.points, logoComponents.dgray.style)
            .poly(logoComponents.lgray.points, logoComponents.lgray.style)
            .poly(logoComponents.blue.points, logoComponents.blue.style)
            .poly(logoComponents.red.points, logoComponents.red.style)
            .poly(logoComponents.purple.points, logoComponents.purple.style)
            .poly(logoComponents.pink.points, logoComponents.pink.style)
            .poly(logoText.V.points, logoText.V.style)
            .poly(logoText.E.points, logoText.E.style)
            .poly(logoText.R1.points, logoText.R1.style)
            .poly(logoText.R2.points, logoText.R2.style)
            .poly(logoText.M.points, logoText.M.style)
            .poly(logoText.I.points, logoText.I.style)
            .poly(logoText.N.points, logoText.N.style)
            .poly(logoText.D.points, logoText.D.style);
        Visualizer_1.text(`Colonies: ${_.keys(Overmind.colonies).length} | Creeps: ${_.keys(Game.creeps).length}`, { x: 1, y: 10 }, .93);
    }
    static drawNotifications(notificationMessages) {
        const x = 10.5;
        const y = 7;
        if (notificationMessages.length == 0) {
            notificationMessages = ['No notifications'];
        }
        const maxStringLength = _.max(_.map(notificationMessages, msg => msg.length));
        const width = Math.max(16, 1.2 * CHAR_WIDTH * maxStringLength);
        this.infoBox('Notifications', notificationMessages, { x, y }, width);
    }
    static drawGraphs() {
        this.text(`CPU`, { x: 1, y: 7 });
        this.barGraph(Memory.stats.persistent.avgCPU / Game.cpu.limit, { x: 2.75, y: 7 });
        this.text(`BKT`, { x: 1, y: 8 });
        this.barGraph((Game.cpu.bucket || 1) / 10000, { x: 2.75, y: 8 });
        this.text(`GCL`, { x: 1, y: 9 });
        this.barGraph(Game.gcl.progress / Game.gcl.progressTotal, { x: 2.75, y: 9 });
    }
    static visuals() {
        this.drawGraphs();
    }
};
Visualizer = Visualizer_1 = __decorate([
    profile
], Visualizer);

var NotifierPriority;
(function (NotifierPriority) {
    NotifierPriority[NotifierPriority["SystemUpdate"] = -1] = "SystemUpdate";
    NotifierPriority[NotifierPriority["Critical"] = 0] = "Critical";
    NotifierPriority[NotifierPriority["High"] = 1] = "High";
    NotifierPriority[NotifierPriority["Normal"] = 2] = "Normal";
    NotifierPriority[NotifierPriority["Low"] = 3] = "Low";
})(NotifierPriority || (NotifierPriority = {}));
class Notifier {
    constructor() {
        this.alerts = [];
        this.notifications = [];
    }
    clear() {
        this.alerts = [];
    }
    alert(message, roomName, priority = NotifierPriority.Normal) {
        const alert = { message, roomName, priority };
        this.alerts.push(alert);
    }
    email(message, roomName, duration = 100, email = false) {
        log.alert(printRoomName(roomName) + ': ' + message);
    }
    generateNotificationsList(links = false) {
        const sortedAlerts = _.sortBy(this.alerts, alert => alert.priority);
        return _.map(sortedAlerts, alert => {
            if (alert.roomName) {
                return (links ? printRoomName(alert.roomName) : alert.roomName) + ': ' + alert.message;
            }
            else {
                return alert.message;
            }
        });
    }
    visuals() {
        const notificationMessages = this.generateNotificationsList();
        Visualizer.drawNotifications(notificationMessages);
    }
}

const DEFAULT_MAX_PATH_LENGTH = 800;
const DEFAULT_MAX_LINEAR_RANGE = 15;
const DIRECTIVE_PATH_TIMEOUT = 30000;
let Directive = class Directive {
    constructor(flag, colonyFilter) {
        this.memory = flag.memory;
        this.name = flag.name;
        this.ref = flag.ref;
        if (!this.memory["T"]) {
            this.memory["T"] = Game.time;
        }
        if (this.memory.setPos) {
            const setPosition = derefRoomPosition(this.memory.setPos);
            if (!this.flag.pos.isEqualTo(setPosition)) {
                this.flag.setPosition(setPosition);
            }
            else {
                delete this.memory.setPos;
            }
            this.pos = setPosition;
            this.room = Game.rooms[setPosition.roomName];
        }
        else {
            this.pos = flag.pos;
            this.room = flag.room;
        }
        if (this.memory["X"] && !this.memory.persistent && Game.time > this.memory["X"]) {
            log.alert(`Removing expired directive ${this.print}!`);
            flag.remove();
            return;
        }
        const forceRecalc = !!this.memory.recalcColonyOnTick && Game.time >= this.memory.recalcColonyOnTick;
        const colony = this.getColony(colonyFilter, forceRecalc);
        if (!colony) {
            if (Overmind.exceptions.length == 0) {
                log.alert(`Could not get colony for directive ${this.print}; removing flag!`);
                flag.remove();
            }
            else {
                log.alert(`Could not get colony for directive ${this.print}; ` +
                    `exceptions present this tick, so won't remove`);
            }
            return;
        }
        this.colony = colony;
        this.colony.flags.push(flag);
        this.overlords = {};
        if (this.age == 0) {
            this.onCreation();
        }
        global[this.name] = this;
        Overmind.overseer.registerDirective(this);
        Overmind.directives[this.name] = this;
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.name + ']</a>';
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    get age() {
        return Game.time - this.memory["T"];
    }
    info() {
        let msg = `Info for ${this.print}: —————————————————————————————————————————————————————————————————————————`;
        const info1 = {
            'Type:': this.directiveName,
            'Name:': this.name,
            'Pos:': this.pos.print,
            'Colony:': this.colony.print,
        };
        msg += toColumns(info1).join('\n');
        msg += `Overlords: \n`;
        const tab = `  `;
        for (const overlordName in this.overlords) {
            msg += tab + `${overlordName}:\n`;
            const olInfo = {};
            const overlord = this.overlords[overlordName];
            olInfo[tab + tab + 'Creep usage:'] = JSON.stringify(overlord.creepUsageReport);
            olInfo[tab + tab + 'Zerg:'] = _.mapValues(overlord._zerg, zergOfRole => _.map(zergOfRole, (zerg) => zerg.print));
            olInfo[tab + tab + 'CombatZerg:'] = _.mapValues(overlord._combatZerg, zergOfRole => _.map(zergOfRole, (zerg) => zerg.print));
            msg += toColumns(olInfo).join('\n');
        }
        msg += 'Memory:\n' + print(this.memory);
        return msg;
    }
    static getPos(flag) {
        if (flag.memory && flag.memory.setPos) {
            const pos = derefRoomPosition(flag.memory.setPos);
            return pos;
        }
        return flag.pos;
    }
    get flag() {
        return Game.flags[this.name];
    }
    get directiveName() {
        return this.constructor.directiveName;
    }
    refresh() {
        const flag = this.flag;
        if (!flag) {
            log.warning(`Missing flag for directive ${this.print}! Removing directive.`);
            this.remove();
            return;
        }
        this.memory = flag.memory;
        this.pos = flag.pos;
        this.room = flag.room;
    }
    alert(message, priority = NotifierPriority.Normal) {
        Overmind.overseer.notifier.alert(message, this.pos.roomName, priority);
    }
    get distanceFromColony() {
        if (!this.memory["D"] || Game.time >= this.memory["D"]["X"]) {
            const ret = Pathing.findPath(this.colony.pos, this.pos, { maxOps: DIRECTIVE_PATH_TIMEOUT });
            const terrainCache = {};
            const terrainWeighted = _.sum(ret.path, pos => {
                let terrain;
                if (!terrainCache[pos.roomName]) {
                    terrainCache[pos.roomName] = Game.map.getRoomTerrain(pos.roomName);
                }
                terrain = terrainCache[pos.roomName];
                return terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP ? 5 : 1;
            });
            this.memory["D"] = {
                ["u"]: ret.path.length,
                ["w"]: terrainWeighted,
                ["X"]: Game.time + 10000 + randint(0, 100),
            };
            if (ret.incomplete) {
                this.memory["D"].incomplete = true;
            }
        }
        const memDistance = this.memory["D"];
        if (memDistance.incomplete) {
            log.warning(`${this.print}: distanceFromColony() info incomplete!`);
        }
        return {
            unweighted: memDistance["u"],
            terrainWeighted: memDistance["w"],
        };
    }
    handleRelocation() {
        if (this.memory.setPos) {
            const pos = derefRoomPosition(this.memory.setPos);
            if (!this.flag.pos.isEqualTo(pos)) {
                const result = this.flag.setPosition(pos);
                if (result == OK) {
                    log.debug(`Moving ${this.name} from ${this.flag.pos.print} to ${pos.print}.`);
                }
                else {
                    log.warning(`Could not set room position to ${JSON.stringify(this.memory.setPos)}!`);
                }
            }
            else {
                delete this.memory.setPos;
            }
            this.pos = pos;
            this.room = Game.rooms[pos.roomName];
            return true;
        }
        return false;
    }
    getColony(colonyFilter, forceRecalc = false) {
        if (this.memory["C"] && !forceRecalc) {
            return Overmind.colonies[this.memory["C"]];
        }
        else {
            const colonyNames = _.keys(Overmind.colonies);
            for (const name of colonyNames) {
                if (this.name.includes(name)) {
                    if (this.name.split(name)[1] != '')
                        continue;
                    this.memory["C"] = name;
                    return Overmind.colonies[name];
                }
            }
            const colony = Overmind.colonies[Overmind.colonyMap[this.pos.roomName]];
            if (colony) {
                if (!colonyFilter || colonyFilter(colony)) {
                    this.memory["C"] = colony.name;
                    return colony;
                }
            }
            const maxPathLength = this.memory.maxPathLength || DEFAULT_MAX_PATH_LENGTH;
            const maxLinearRange = this.memory.maxLinearRange || DEFAULT_MAX_LINEAR_RANGE;
            this.debug(`Recalculating colony association for ${this.name} in ${this.pos.roomName}`);
            let nearestColony;
            let minDistance = Infinity;
            for (const colony of getAllColonies()) {
                if (Game.map.getRoomLinearDistance(this.pos.roomName, colony.name) > maxLinearRange
                    && !this.memory.allowPortals) {
                    continue;
                }
                if (!colonyFilter || colonyFilter(colony)) {
                    const ret = Pathing.findPath((colony.hatchery || colony).pos, this.pos, { maxOps: DIRECTIVE_PATH_TIMEOUT });
                    if (!ret.incomplete) {
                        if (ret.path.length < maxPathLength && ret.path.length < minDistance) {
                            nearestColony = colony;
                            minDistance = ret.path.length;
                        }
                        if (ret.portalUsed && ret.portalUsed.expiration) {
                            this.memory.recalcColonyOnTick = ret.portalUsed.expiration + 1;
                        }
                        this.debug(`Path length to ${colony.room.print}: ${ret.path.length}`);
                    }
                    else {
                        this.debug(`Incomplete path from ${colony.room.print}`);
                    }
                }
            }
            if (nearestColony) {
                log.info(`Colony ${nearestColony.room.print} assigned to ${this.name}.`);
                this.memory["C"] = nearestColony.room.name;
                return nearestColony;
            }
            else {
                log.error(`Could not find colony match for ${this.name} in ${this.pos.roomName}! ` +
                    `Try setting memory.maxPathLength and memory.maxLinearRange.`);
            }
        }
    }
    remove(force = false) {
        if (!this.memory.persistent || force) {
            delete Overmind.directives[this.name];
            delete global[this];
            Overmind.overseer.removeDirective(this);
            if (this.colony) {
                _.remove(this.colony.flags, flag => flag.name == this.name);
            }
            if (this.flag) {
                return this.flag.remove();
            }
        }
    }
    setColor(color, secondaryColor) {
        if (secondaryColor) {
            return this.flag.setColor(color, secondaryColor);
        }
        else {
            return this.flag.setColor(color);
        }
    }
    setPosition(pos) {
        return this.flag.setPosition(pos);
    }
    static create(pos, opts = {}) {
        let flagName = opts.name || undefined;
        if (!flagName) {
            flagName = this.directiveName + ':' + randomHex(6);
            if (Game.flags[flagName]) {
                return ERR_NAME_EXISTS;
            }
        }
        if (!opts.quiet) {
            log.alert(`Creating ${this.directiveName} directive at ${pos.print}!`);
        }
        const result = pos.createFlag(flagName, this.color, this.secondaryColor);
        if (result == flagName && opts.memory) {
            Memory.flags[flagName] = opts.memory;
        }
        log.debug(`Result: ${result}, memory: ${JSON.stringify(Memory.flags[result])}`);
        return result;
    }
    static isPresent(posOrRoomName) {
        if (PHASE != 'run' && PHASE != 'init') {
            log.error(`Directive.isPresent() will only give correct results in init() and run() phases!`);
            return true;
        }
        if (typeof posOrRoomName === 'string') {
            const roomName = posOrRoomName;
            const directivesInRoom = Overmind.overseer.getDirectivesInRoom(roomName);
            return _.filter(directivesInRoom, directive => this.filter(directive.flag)).length > 0;
        }
        else {
            const pos = posOrRoomName;
            const directivesInRoom = Overmind.overseer.getDirectivesInRoom(pos.roomName);
            return _.filter(directivesInRoom, directive => this.filter(directive.flag) && equalXYR(pos, directive.pos)).length > 0;
        }
    }
    static createIfNotPresent(pos, scope, opts = {}) {
        if (PHASE != 'run') {
            log.error(`Directive.createIfNotPresent() can only be called during the run phase!`);
            return;
        }
        if (scope == 'pos') {
            if (this.isPresent(pos))
                return;
        }
        else {
            if (this.isPresent(pos.roomName))
                return;
        }
        const room = Game.rooms[pos.roomName];
        if (!room) {
            if (!opts.memory) {
                opts.memory = {};
            }
            opts.memory.setPos = pos;
        }
        switch (scope) {
            case 'room':
                if (room) {
                    return this.create(pos, opts);
                }
                else {
                    log.info(`Creating directive at ${pos.print}... ` +
                        `No visibility in room; directive will be relocated on next tick.`);
                    let createAtPos;
                    if (opts.memory && opts.memory["C"]) {
                        createAtPos = Pathing.findPathablePosition(opts.memory["C"]);
                    }
                    else {
                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);
                    }
                    return this.create(createAtPos, opts);
                }
            case 'pos':
                if (room) {
                    return this.create(pos, opts);
                }
                else {
                    log.info(`Creating directive at ${pos.print}... ` +
                        `No visibility in room; directive will be relocated on next tick.`);
                    let createAtPos;
                    if (opts.memory && opts.memory["C"]) {
                        createAtPos = Pathing.findPathablePosition(opts.memory["C"]);
                    }
                    else {
                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);
                    }
                    return this.create(createAtPos, opts);
                }
        }
    }
    static filter(flag) {
        return flag.color == this.color && flag.secondaryColor == this.secondaryColor;
    }
    static find(flags) {
        flags = _.filter(flags, flag => this.filter(flag));
        return _.compact(_.map(flags, flag => Overmind.directives[flag.name]));
    }
    static findInRoom(roomName) {
        const directivesInRoom = Overmind.overseer.getDirectivesInRoom(roomName);
        return _.filter(directivesInRoom, directive => this.filter(directive.flag));
    }
    static findInColony(colony) {
        const directivesInColony = Overmind.overseer.getDirectivesForColony(colony);
        return _.filter(directivesInColony, directive => this.filter(directive.flag));
    }
    onCreation() {
    }
    visuals() {
    }
};
Directive = __decorate([
    profile
], Directive);

const REBUILD_STATE_TIMEOUT = 25000;
let DirectiveTerminalRebuildState = class DirectiveTerminalRebuildState extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.isRebuilding = true;
    }
    spawnMoarOverlords() {
    }
    init() {
        if (this.colony && this.colony.terminal) {
            for (const resource of RESOURCES_ALL) {
                if (this.colony.assets[resource] > 0) {
                    if (resource == RESOURCE_ENERGY) {
                        Overmind.terminalNetwork.exportResource(this.colony, resource, {
                            target: 25000,
                            tolerance: 5000,
                            surplus: 35000,
                        });
                    }
                    else {
                        Overmind.terminalNetwork.exportResource(this.colony, resource);
                    }
                }
            }
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: rebuild terminal state active!`);
        }
        this.alert('Rebuild terminal state active!', NotifierPriority.High);
    }
    run() {
        if (!this.colony || !this.terminal || Game.time > (this.memory["T"] || 0) + REBUILD_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalRebuildState.directiveName = 'rebuildState';
DirectiveTerminalRebuildState.color = COLOR_BROWN;
DirectiveTerminalRebuildState.secondaryColor = COLOR_YELLOW;
DirectiveTerminalRebuildState = __decorate([
    profile
], DirectiveTerminalRebuildState);

const BuildPriorities = [
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_CONTAINER,
    STRUCTURE_LINK,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_WALL,
    STRUCTURE_RAMPART,
    STRUCTURE_ROAD,
];
const FortifyPriorities = [
    STRUCTURE_TERMINAL,
    STRUCTURE_STORAGE,
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
];
const AttackStructurePriorities = [
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_CONTAINER,
    STRUCTURE_ROAD,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
const AttackStructureScores = _.zipObject(_.map(AttackStructurePriorities, type => [type, AttackStructurePriorities.length - _.indexOf(AttackStructurePriorities, type)]));
const DemolishStructurePriorities = [
    { structureType: STRUCTURE_EXTENSION, maxRemoved: 15 },
    { structureType: STRUCTURE_SPAWN, maxRemoved: 1 },
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_TOWER, maxRemoved: 1 },
    { structureType: STRUCTURE_LINK },
    { structureType: STRUCTURE_LAB },
    { structureType: STRUCTURE_NUKER },
    { structureType: STRUCTURE_OBSERVER },
    { structureType: STRUCTURE_POWER_SPAWN },
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_STORAGE, maxRemoved: 1 },
    { structureType: STRUCTURE_TERMINAL, maxRemoved: 1 },
    { structureType: STRUCTURE_WALL },
    { structureType: STRUCTURE_RAMPART },
];

const UNWALKABLE = -10;
const RANGE_MODIFIER = 1;
const RANGE_PADDING = 3;
const NORMAL = 0;
const PROTECTED = 10;
const CANNOT_BUILD = 20;
const EXIT = 30;
class Graph {
    constructor(totalVertices) {
        this.totalVertices = totalVertices;
        this.level = Array(totalVertices);
        this.edges = Array(totalVertices).fill(0).map((x) => []);
    }
    newEdge(from, to, capacity) {
        this.edges[from].push({ to, resEdge: this.edges[to].length, capacity, flow: 0 });
        this.edges[to].push({ to: from, resEdge: this.edges[from].length - 1, capacity: 0, flow: 0 });
    }
    createLevelGraph(from, to) {
        if (to >= this.totalVertices) {
            return false;
        }
        this.level.fill(-1);
        this.level[from] = 0;
        const q = [];
        q.push(from);
        let u = 0;
        let edge = null;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (this.level[edge.to] < 0 && edge.flow < edge.capacity) {
                    this.level[edge.to] = this.level[u] + 1;
                    q.push(edge.to);
                }
            }
        }
        return this.level[to] >= 0;
    }
    calcFlow(start, end, targetFlow, count) {
        if (start === end) {
            return targetFlow;
        }
        let edge;
        let flowTillHere = 0;
        let flowToT = 0;
        while (count[start] < this.edges[start].length) {
            edge = this.edges[start][count[start]];
            if (this.level[edge.to] === this.level[start] + 1 && edge.flow < edge.capacity) {
                flowTillHere = Math.min(targetFlow, edge.capacity - edge.flow);
                flowToT = this.calcFlow(edge.to, end, flowTillHere, count);
                if (flowToT > 0) {
                    edge.flow += flowToT;
                    this.edges[edge.to][edge.resEdge].flow -= flowToT;
                    return flowToT;
                }
            }
            count[start]++;
        }
        return 0;
    }
    getMinCut(from) {
        const eInCut = [];
        this.level.fill(-1);
        this.level[from] = 1;
        const q = [];
        q.push(from);
        let u = 0;
        let edge;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (edge.flow < edge.capacity) {
                    if (this.level[edge.to] < 1) {
                        this.level[edge.to] = 1;
                        q.push(edge.to);
                    }
                }
                if (edge.flow === edge.capacity && edge.capacity > 0) {
                    eInCut.push({ to: edge.to, unreachable: u });
                }
            }
        }
        const minCut = [];
        let cutEdge;
        for (cutEdge of eInCut) {
            if (this.level[cutEdge.to] === -1) {
                minCut.push(cutEdge.unreachable);
            }
        }
        return minCut;
    }
    calcMinCut(source, sink) {
        if (source === sink) {
            return -1;
        }
        let ret = 0;
        let count = [];
        let flow = 0;
        while (this.createLevelGraph(source, sink)) {
            count = Array(this.totalVertices + 1).fill(0);
            do {
                flow = this.calcFlow(source, sink, Number.MAX_VALUE, count);
                if (flow > 0) {
                    ret += flow;
                }
            } while (flow);
        }
        return ret;
    }
}
function get2DArray(roomName, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const room2D = Array(50).fill(NORMAL).map((d) => Array(50).fill(NORMAL));
    let x;
    let y;
    const terrain = Game.map.getRoomTerrain(roomName);
    for (x = bounds.x1; x <= bounds.x2; x++) {
        for (y = bounds.y1; y <= bounds.y2; y++) {
            if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                room2D[x][y] = UNWALKABLE;
            }
            else if (x === bounds.x1 || y === bounds.y1 || x === bounds.x2 || y === bounds.y2) {
                room2D[x][y] = EXIT;
            }
        }
    }
    for (y = bounds.y1 + 1; y <= bounds.y2 - 1; y++) {
        if (room2D[bounds.x1][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x1 + 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x1 + 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[bounds.x2][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x2 - 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x2 - 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
    }
    for (x = bounds.x1 + 1; x <= bounds.x2 - 1; x++) {
        if (room2D[x][bounds.y1] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y1 + 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y1 + 1] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[x][bounds.y2] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y2 - 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y2 - 1] = CANNOT_BUILD;
                }
            }
        }
    }
    return room2D;
}
function createGraph(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const visual = new RoomVisual(roomName);
    const roomArray = get2DArray(roomName, bounds);
    let r;
    let x;
    let y;
    for (r of toProtect) {
        if (bounds.x1 >= bounds.x2 || bounds.y1 >= bounds.y2 ||
            bounds.x1 < 0 || bounds.y1 < 0 || bounds.x2 > 49 || bounds.y2 > 49) {
            return console.log('ERROR: Invalid bounds', JSON.stringify(bounds));
        }
        else if (r.x1 >= r.x2 || r.y1 >= r.y2) {
            return console.log('ERROR: Rectangle', JSON.stringify(r), 'invalid.');
        }
        else if (r.x1 < bounds.x1 || r.x2 > bounds.x2 || r.y1 < bounds.y1 || r.y2 > bounds.y2) {
            return console.log('ERROR: Rectangle', JSON.stringify(r), 'out of bounds:', JSON.stringify(bounds));
        }
        for (x = r.x1; x <= r.x2; x++) {
            for (y = r.y1; y <= r.y2; y++) {
                if (x === r.x1 || x === r.x2 || y === r.y1 || y === r.y2) {
                    if (roomArray[x][y] === NORMAL) {
                        roomArray[x][y] = PROTECTED;
                    }
                }
                else {
                    roomArray[x][y] = UNWALKABLE;
                }
            }
        }
    }
    if (preferCloserBarriers) {
        for (r of _.take(toProtect, preferCloserBarrierLimit)) {
            const [xmin, xmax] = [Math.max(r.x1 - RANGE_PADDING, 0), Math.min(r.x2 + RANGE_PADDING, 49)];
            const [ymin, ymax] = [Math.max(r.y1 - RANGE_PADDING, 0), Math.min(r.y2 + RANGE_PADDING, 49)];
            for (x = xmin; x <= xmax; x++) {
                for (y = ymin; y <= ymax; y++) {
                    if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {
                        const x1range = Math.max(r.x1 - x, 0);
                        const x2range = Math.max(x - r.x2, 0);
                        const y1range = Math.max(r.y1 - y, 0);
                        const y2range = Math.max(y - r.y2, 0);
                        const rangeToBorder = Math.max(x1range, x2range, y1range, y2range);
                        const modifiedWeight = NORMAL + RANGE_MODIFIER * (RANGE_PADDING - rangeToBorder);
                        roomArray[x][y] = Math.max(roomArray[x][y], modifiedWeight);
                        if (visualize) {
                            visual.text(`${roomArray[x][y]}`, x, y);
                        }
                    }
                }
            }
        }
    }
    if (visualize) {
        for (x = bounds.x1; x <= bounds.x2; x++) {
            for (y = bounds.y1; y <= bounds.y2; y++) {
                if (roomArray[x][y] === UNWALKABLE) {
                    visual.circle(x, y, { radius: 0.5, fill: '#1b1b9f', opacity: 0.3 });
                }
                else if (roomArray[x][y] > UNWALKABLE && roomArray[x][y] < NORMAL) {
                    visual.circle(x, y, { radius: 0.5, fill: '#42cce8', opacity: 0.3 });
                }
                else if (roomArray[x][y] === NORMAL) {
                    visual.circle(x, y, { radius: 0.5, fill: '#bdb8b8', opacity: 0.3 });
                }
                else if (roomArray[x][y] > NORMAL && roomArray[x][y] < PROTECTED) {
                    visual.circle(x, y, { radius: 0.5, fill: '#9929e8', opacity: 0.3 });
                }
                else if (roomArray[x][y] === PROTECTED) {
                    visual.circle(x, y, { radius: 0.5, fill: '#e800c6', opacity: 0.3 });
                }
                else if (roomArray[x][y] === CANNOT_BUILD) {
                    visual.circle(x, y, { radius: 0.5, fill: '#e8000f', opacity: 0.3 });
                }
                else if (roomArray[x][y] === EXIT) {
                    visual.circle(x, y, { radius: 0.5, fill: '#000000', opacity: 0.3 });
                }
            }
        }
    }
    const g = new Graph(2 * 50 * 50 + 2);
    const infini = Number.MAX_VALUE;
    const surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];
    const source = 2 * 50 * 50;
    const sink = 2 * 50 * 50 + 1;
    let top = 0;
    let bot = 0;
    let dx = 0;
    let dy = 0;
    const baseCapacity = 10;
    const modifyWeight = preferCloserBarriers ? 1 : 0;
    for (x = bounds.x1 + 1; x < bounds.x2; x++) {
        for (y = bounds.y1 + 1; y < bounds.y2; y++) {
            top = y * 50 + x;
            bot = top + 2500;
            if (roomArray[x][y] >= NORMAL && roomArray[x][y] <= PROTECTED) {
                if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {
                    g.newEdge(top, bot, baseCapacity - modifyWeight * roomArray[x][y]);
                }
                else if (roomArray[x][y] === PROTECTED) {
                    g.newEdge(source, top, infini);
                    g.newEdge(top, bot, baseCapacity - modifyWeight * RANGE_PADDING * RANGE_MODIFIER);
                }
                for (let i = 0; i < 8; i++) {
                    dx = x + surr[i][0];
                    dy = y + surr[i][1];
                    if ((roomArray[dx][dy] >= NORMAL && roomArray[dx][dy] < PROTECTED)
                        || roomArray[dx][dy] === CANNOT_BUILD) {
                        g.newEdge(bot, dy * 50 + dx, infini);
                    }
                }
            }
            else if (roomArray[x][y] === CANNOT_BUILD) {
                g.newEdge(top, sink, infini);
            }
        }
    }
    return g;
}
function getCutTiles(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const graph = createGraph(roomName, toProtect, preferCloserBarriers, preferCloserBarrierLimit, visualize, bounds);
    if (!graph) {
        return [];
    }
    let x;
    let y;
    const source = 2 * 50 * 50;
    const sink = 2 * 50 * 50 + 1;
    const count = graph.calcMinCut(source, sink);
    const positions = [];
    if (count > 0) {
        const cutVertices = graph.getMinCut(source);
        let v;
        for (v of cutVertices) {
            x = v % 50;
            y = Math.floor(v / 50);
            positions.push({ x, y });
        }
    }
    if (positions.length <= 0)
        return [];
    if (visualize) {
        const visual = new RoomVisual(roomName);
        for (let i = positions.length - 1; i >= 0; i--) {
            visual.circle(positions[i].x, positions[i].y, { radius: 0.5, fill: '#ff7722', opacity: 0.9 });
        }
    }
    const wholeRoom = bounds.x1 === 0 && bounds.y1 === 0 && bounds.x2 === 49 && bounds.y2 === 49;
    return wholeRoom ? positions : pruneDeadEnds(roomName, positions);
}
function pruneDeadEnds(roomName, cutTiles) {
    const roomArray = get2DArray(roomName);
    let tile;
    for (tile of cutTiles) {
        roomArray[tile.x][tile.y] = UNWALKABLE;
    }
    const unvisited = [];
    let y;
    let x;
    for (y = 0; y < 49; y++) {
        if (roomArray[0][y] === EXIT) {
            console.log('prune: toExit', 0, y);
            unvisited.push(50 * y);
        }
        if (roomArray[49][y] === EXIT) {
            console.log('prune: toExit', 49, y);
            unvisited.push(50 * y + 49);
        }
    }
    for (x = 0; x < 49; x++) {
        if (roomArray[x][0] === EXIT) {
            console.log('prune: toExit', x, 0);
            unvisited.push(x);
        }
        if (roomArray[x][49] === EXIT) {
            console.log('prune: toExit', x, 49);
            unvisited.push(2450 + x);
        }
    }
    const surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];
    let currPos;
    let dx;
    let dy;
    while (unvisited.length > 0) {
        currPos = unvisited.pop();
        x = currPos % 50;
        y = Math.floor(currPos / 50);
        for (let i = 0; i < 8; i++) {
            dx = x + surr[i][0];
            dy = y + surr[i][1];
            if (dx < 0 || dx > 49 || dy < 0 || dy > 49) {
                continue;
            }
            if ((roomArray[dx][dy] >= NORMAL && roomArray[dx][dy] < PROTECTED)
                || roomArray[dx][dy] === CANNOT_BUILD) {
                unvisited.push(50 * dy + dx);
                roomArray[dx][dy] = EXIT;
            }
        }
    }
    let leadsToExit;
    const validCut = [];
    for (tile of cutTiles) {
        leadsToExit = false;
        for (let j = 0; j < 8; j++) {
            dx = tile.x + surr[j][0];
            dy = tile.y + surr[j][1];
            if (roomArray[dx][dy] === EXIT) {
                leadsToExit = true;
            }
        }
        if (leadsToExit) {
            validCut.push(tile);
        }
    }
    return validCut;
}
function testMinCut(colonyName, preferCloserBarriers = true) {
    const colony = Overmind.colonies[colonyName];
    if (!colony) {
        return `No colony: ${colonyName}`;
    }
    let cpu = Game.cpu.getUsed();
    const rectArray = [];
    const padding = 3;
    if (colony.hatchery) {
        const { x, y } = colony.hatchery.pos;
        const [x1, y1] = [Math.max(x - 5 - padding, 0), Math.max(y - 4 - padding, 0)];
        const [x2, y2] = [Math.min(x + 5 + padding, 49), Math.min(y + 6 + padding, 49)];
        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
    }
    if (colony.commandCenter) {
        const { x, y } = colony.commandCenter.pos;
        const [x1, y1] = [Math.max(x - 3 - padding, 0), Math.max(y - 0 - padding, 0)];
        const [x2, y2] = [Math.min(x + 0 + padding, 49), Math.min(y + 5 + padding, 49)];
        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
    }
    if (colony.upgradeSite) {
        const { x, y } = colony.upgradeSite.pos;
        const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];
        const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];
        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
    }
    const positions = getCutTiles(colonyName, rectArray, preferCloserBarriers, 2);
    cpu = Game.cpu.getUsed() - cpu;
    log.info(`preferCloserBarriers = ${preferCloserBarriers}; positions returned: ${positions.length};` +
        ` CPU time: ${cpu}`);
    return 'Finished';
}
function testMinCutSubset(colonyName) {
    const colony = Overmind.colonies[colonyName];
    if (!colony) {
        return `No colony: ${colonyName}`;
    }
    let cpu = Game.cpu.getUsed();
    const rectArray = [];
    const padding = 3;
    if (colony.hatchery) {
        const { x, y } = colony.hatchery.pos;
        rectArray.push({ x1: x - 5 - padding, y1: y - 4 - padding, x2: x + 5 + padding, y2: y + 6 + padding });
    }
    if (colony.commandCenter) {
        const { x, y } = colony.commandCenter.pos;
        rectArray.push({ x1: x - 3 - padding, y1: y - 0 - padding, x2: x + 0 + padding, y2: y + 5 + padding });
    }
    const positions = getCutTiles(colonyName, rectArray, true, Infinity, true, { x1: 5, y1: 5, x2: 44, y2: 44 });
    console.log('Positions returned', positions.length);
    cpu = Game.cpu.getUsed() - cpu;
    console.log('Needed', cpu, ' cpu time');
    return 'Finished';
}

var BarrierPlanner_1;
const getDefaultBarrierPlannerMemory = () => ({
    barrierCoordsPacked: '',
});
let BarrierPlanner = BarrierPlanner_1 = class BarrierPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(this.colony.memory, 'barrierPlanner', getDefaultBarrierPlannerMemory);
        this.barrierPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'barrierPlanner', getDefaultBarrierPlannerMemory);
        this.barrierPositions = [];
    }
    computeBunkerBarrierPositions(bunkerPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (bunkerPos) {
            const { x, y } = bunkerPos;
            const r = BUNKER_RADIUS - 1;
            let [x1, y1] = [Math.max(x - r - padding, 0), Math.max(y - r - padding, 0)];
            let [x2, y2] = [Math.min(x + r + padding, 49), Math.min(y + r + padding, 49)];
            x1 = minMax(x1, 3, 50 - 3);
            x2 = minMax(x2, 3, 50 - 3);
            y1 = minMax(y1, 3, 50 - 3);
            y2 = minMax(y2, 3, 50 - 3);
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        const barrierCoords = getCutTiles(this.colony.name, rectArray, false, 2, false);
        let positions = _.map(barrierCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));
        positions = positions.concat(upgradeSitePos.availableNeighbors(true));
        return positions;
    }
    computeBarrierPositions(hatcheryPos, commandCenterPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (hatcheryPos) {
            const { x, y } = hatcheryPos;
            const [x1, y1] = [Math.max(x - 5 - padding, 0), Math.max(y - 4 - padding, 0)];
            const [x2, y2] = [Math.min(x + 5 + padding, 49), Math.min(y + 6 + padding, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (commandCenterPos) {
            const { x, y } = commandCenterPos;
            const [x1, y1] = [Math.max(x - 3 - padding, 0), Math.max(y - 0 - padding, 0)];
            const [x2, y2] = [Math.min(x + 0 + padding, 49), Math.min(y + 5 + padding, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (upgradeSitePos) {
            const { x, y } = upgradeSitePos;
            const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];
            const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        const barrierCoords = getCutTiles(this.colony.name, rectArray, true, 2, false);
        return _.map(barrierCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));
    }
    init() {
    }
    finalize() {
        if (this.barrierPositions.length == 0) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);
            }
            else if (this.roomPlanner.storagePos && this.roomPlanner.hatcheryPos) {
                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);
            }
            else {
                log.error(`${this.colony.print} BARRIER PLANNER: couldn't generate barrier plan!`);
                return;
            }
        }
        this.memory.barrierCoordsPacked = packCoordList(this.barrierPositions);
    }
    barrierShouldBeHere(pos) {
        if (this.colony.layout == 'bunker' && this.colony.level >= BarrierPlanner_1.settings.bunkerizeRCL) {
            return insideBunkerBounds(pos, this.colony) || pos.getRangeTo(this.colony.controller) == 1;
        }
        if (this._barrierLookup == undefined) {
            this._barrierLookup = _.memoize((p) => this.memory.barrierCoordsPacked.includes(packCoord(p)));
        }
        return this._barrierLookup(pos);
    }
    buildMissingRamparts() {
        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;
        const barrierPositions = unpackCoordListAsPosList(this.memory.barrierCoordsPacked, this.colony.room.name);
        const criticalStructures = _.compact([...this.colony.towers,
            ...this.colony.spawns,
            this.colony.storage,
            this.colony.terminal]);
        for (const structure of criticalStructures) {
            barrierPositions.push(structure.pos);
        }
        for (const pos of barrierPositions) {
            if (count > 0 && RoomPlanner.canBuild(STRUCTURE_RAMPART, pos) && this.barrierShouldBeHere(pos)) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create rampart site at ${pos.print}. Result: ${ret}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    buildMissingBunkerRamparts() {
        if (!this.roomPlanner.bunkerPos)
            return;
        const bunkerCoords = getAllStructureCoordsFromLayout(bunkerLayout, this.colony.level);
        bunkerCoords.push(bunkerLayout.data.anchor);
        let bunkerPositions = _.map(bunkerCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));
        bunkerPositions = translatePositions(bunkerPositions, bunkerLayout.data.anchor, this.roomPlanner.bunkerPos);
        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;
        for (const pos of bunkerPositions) {
            if (count > 0 && !pos.lookForStructure(STRUCTURE_RAMPART)
                && pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create bunker rampart at ${pos.print}. Result: ${ret}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    recomputeBarrierPositions() {
        this.barrierPositions = [];
        if (this.roomPlanner.bunkerPos) {
            this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);
        }
        else if (this.roomPlanner.storagePos && this.roomPlanner.hatcheryPos) {
            this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);
        }
        this.memory.barrierCoordsPacked = packCoordList(this.barrierPositions);
    }
    run() {
        if (this.roomPlanner.active) {
            this.recomputeBarrierPositions();
            this.visuals();
            return;
        }
        if (this.roomPlanner.bunkerPos && this.roomPlanner.shouldRecheck(3)) {
            this.recomputeBarrierPositions();
        }
        if (!this.roomPlanner.memory.relocating && this.colony.level >= BarrierPlanner_1.settings.buildBarriersAtRCL
            && this.roomPlanner.shouldRecheck(2)) {
            this.buildMissingRamparts();
            if (this.colony.layout == 'bunker' && this.colony.level >= 7) {
                this.buildMissingBunkerRamparts();
            }
        }
    }
    visuals() {
        for (const pos of this.barrierPositions) {
            this.colony.room.visual.structure(pos.x, pos.y, STRUCTURE_RAMPART);
        }
    }
};
BarrierPlanner.settings = {
    buildBarriersAtRCL: 3,
    padding: 3,
    bunkerizeRCL: 7
};
BarrierPlanner = BarrierPlanner_1 = __decorate([
    profile
], BarrierPlanner);

var commandCenterLayout = { data: { anchor: { 'x': 25, 'y': 25 } }, 3: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '3', 'buildings': { 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] } } }, 4: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '4', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] } } }, 5: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '5', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] } } }, 6: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '6', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'terminal': { 'pos': [{ 'x': 25, 'y': 26 }] }, 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] }, 'lab': { 'pos': [{ 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 24, 'y': 29 }] } } }, 7: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '7', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'terminal': { 'pos': [{ 'x': 25, 'y': 26 }] }, 'tower': { 'pos': [{ 'x': 23, 'y': 27 }, { 'x': 24, 'y': 27 }] }, 'lab': { 'pos': [{ 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 25, 'y': 29 }] } } }, 8: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '8', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'nuker': { 'pos': [{ 'x': 22, 'y': 25 }] }, 'powerSpawn': { 'pos': [{ 'x': 23, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'observer': { 'pos': [{ 'x': 22, 'y': 26 }] }, 'terminal': { 'pos': [{ 'x': 25, 'y': 26 }] }, 'tower': { 'pos': [{ 'x': 23, 'y': 27 }, { 'x': 24, 'y': 27 }] }, 'lab': { 'pos': [{ 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 25, 'y': 29 }, { 'x': 22, 'y': 30 }, { 'x': 23, 'y': 30 }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }] } } }, };

var hatcheryLayout = { data: { anchor: { 'x': 25, 'y': 24 }, }, 1: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '1', 'buildings': { 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] } } }, 2: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '2', 'buildings': { 'extension': { 'pos': [{ 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 27, 'y': 26 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] } } }, 3: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '3', 'buildings': { 'extension': { 'pos': [{ 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] } } }, 4: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '4', 'buildings': { 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'extension': { 'pos': [{ 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] } } }, 5: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '5', 'buildings': { 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'extension': { 'pos': [{ 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 27, 'y': 29 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 29, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, 6: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '6', 'buildings': { 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'extension': { 'pos': [{ 'x': 22, 'y': 21 }, { 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 21 }, { 'x': 21, 'y': 22 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 29, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 28, 'y': 29 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 29, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, 7: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '7', 'buildings': { 'extension': { 'pos': [{ 'x': 21, 'y': 20 }, { 'x': 22, 'y': 20 }, { 'x': 28, 'y': 20 }, { 'x': 29, 'y': 20 }, { 'x': 20, 'y': 21 }, { 'x': 22, 'y': 21 }, { 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 21 }, { 'x': 30, 'y': 21 }, { 'x': 20, 'y': 22 }, { 'x': 21, 'y': 22 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 29, 'y': 22 }, { 'x': 30, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 20, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 28, 'y': 29 }, { 'x': 30, 'y': 29 }] }, 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 24, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 29, 'y': 25 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, 8: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '8', 'buildings': { 'extension': { 'pos': [{ 'x': 20, 'y': 20 }, { 'x': 21, 'y': 20 }, { 'x': 22, 'y': 20 }, { 'x': 28, 'y': 20 }, { 'x': 29, 'y': 20 }, { 'x': 30, 'y': 20 }, { 'x': 20, 'y': 21 }, { 'x': 22, 'y': 21 }, { 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 21 }, { 'x': 30, 'y': 21 }, { 'x': 20, 'y': 22 }, { 'x': 21, 'y': 22 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 29, 'y': 22 }, { 'x': 30, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 20, 'y': 28 }, { 'x': 21, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 30, 'y': 28 }, { 'x': 20, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 28, 'y': 29 }, { 'x': 30, 'y': 29 }, { 'x': 20, 'y': 30 }, { 'x': 21, 'y': 30 }, { 'x': 22, 'y': 30 }, { 'x': 28, 'y': 30 }, { 'x': 29, 'y': 30 }, { 'x': 30, 'y': 30 }] }, 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'tower': { 'pos': [{ 'x': 25, 'y': 21 }, { 'x': 21, 'y': 25 }, { 'x': 29, 'y': 25 }, { 'x': 25, 'y': 29 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 24, 'y': 25 }, { 'x': 26, 'y': 25 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, };

var RoadPlanner_1;
const ROAD_PLANNER_PLAIN_COST = 3;
const ROAD_PLANNER_SWAMP_COST = 4;
const ROAD_PLANNER_TUNNEL_COST = 15 * ROAD_PLANNER_PLAIN_COST;
const EXISTING_PATH_COST = ROAD_PLANNER_PLAIN_COST - 1;
const getDefaultRoadPlannerMemory = () => ({
    roadCoordsPacked: {},
    roadCoverage: 0.0,
    roadCoverages: {}
});
let RoadPlanner = RoadPlanner_1 = class RoadPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(this.colony.memory, 'roadPlanner', getDefaultRoadPlannerMemory);
        this.costMatrices = {};
        this.roadPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'roadPlanner', getDefaultRoadPlannerMemory);
        this.costMatrices = {};
        this.roadPositions = [];
    }
    get roadCoverage() {
        return this.memory.roadCoverage;
    }
    recomputeRoadCoverages(storagePos, ignoreInactiveRooms = true) {
        for (const destination of this.colony.destinations) {
            const destName = destination.pos.readableName;
            if (!!this.memory.roadCoordsPacked[destination.pos.roomName]) {
                if (!this.memory.roadCoverages[destName] || Game.time > this.memory.roadCoverages[destName].exp) {
                    const roadCoverage = this.computeRoadCoverage(storagePos, destination.pos);
                    if (roadCoverage != undefined) {
                        const expiration = roadCoverage.roadCount / roadCoverage.length >= 0.75
                            ? getCacheExpiration(RoadPlanner_1.settings.recomputeCoverageInterval)
                            : getCacheExpiration(3 * RoadPlanner_1.settings.recomputeCoverageInterval);
                        this.memory.roadCoverages[destName] = {
                            roadCount: roadCoverage.roadCount,
                            length: roadCoverage.length,
                            exp: expiration
                        };
                    }
                    else {
                        if (this.memory.roadCoverages[destName]) {
                            const waitTime = onPublicServer() ? 500 : 200;
                            this.memory.roadCoverages[destName].exp += waitTime;
                        }
                        else {
                            const waitTime = onPublicServer() ? 300 : 100;
                            this.memory.roadCoverages[destName] = {
                                roadCount: 0,
                                length: 1,
                                exp: Game.time + waitTime
                            };
                        }
                    }
                    log.debug(`Recomputing road coverage from ${storagePos.print} to ${destination.pos.print}... ` +
                        `Coverage: ${JSON.stringify(roadCoverage)}`);
                }
            }
        }
        let totalRoadCount = 0;
        let totalPathLength = 0;
        for (const destName in this.memory.roadCoverages) {
            const destPos = posFromReadableName(destName);
            if (ignoreInactiveRooms && !this.colony.isRoomActive(destPos.roomName)) {
                continue;
            }
            const { roadCount, length, exp } = this.memory.roadCoverages[destName];
            totalRoadCount += roadCount;
            totalPathLength += length;
        }
        this.memory.roadCoverage = totalRoadCount / totalPathLength;
    }
    computeRoadCoverage(storagePos, destination) {
        const ret = Pathing.findPath(storagePos, destination, { terrainCosts: { plainCost: 2, swampCost: 10 } });
        const path = ret.path;
        const roomNames = _.unique(_.map(path, pos => pos.roomName));
        if (_.all(roomNames, roomName => Game.rooms[roomName] || $.costMatrixRecall(roomName, MatrixTypes.default))) {
            let roadCount = 0;
            for (const pos of path) {
                if (Game.rooms[pos.roomName]) {
                    if (pos.lookForStructure(STRUCTURE_ROAD)) {
                        roadCount++;
                    }
                }
                else {
                    const mat = $.costMatrixRecall(pos.roomName, MatrixTypes.default);
                    if (mat) {
                        if (mat.get(pos.x, pos.y) == 1) {
                            roadCount++;
                        }
                    }
                    else {
                        log.warning(`No vision or recalled cost matrix in room ${pos.roomName}! (Why?)`);
                    }
                }
            }
            return { roadCount: roadCount, length: path.length };
        }
    }
    recalculateRoadNetwork(storagePos, obstacles) {
        this.buildRoadNetwork(storagePos, obstacles);
        this.finalize();
    }
    buildRoadNetwork(storagePos, obstacles) {
        this.costMatrices = {};
        this.roadPositions = [];
        const destinations = _.sortBy(this.colony.destinations, destination => destination.order);
        for (const destination of destinations) {
            this.planRoad(storagePos, destination.pos, obstacles);
        }
        this.formatRoadPositions();
    }
    planRoad(pos1, pos2, obstacles) {
        const roadPath = this.generateRoadPath(pos1, pos2, obstacles);
        if (roadPath) {
            this.roadPositions = this.roadPositions.concat(roadPath);
        }
    }
    generateRoadPlanningCostMatrix(roomName, obstacles) {
        const matrix = new PathFinder.CostMatrix();
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                switch (terrain.get(x, y)) {
                    case TERRAIN_MASK_SWAMP:
                        matrix.set(x, y, ROAD_PLANNER_SWAMP_COST);
                        break;
                    case TERRAIN_MASK_WALL:
                        if (x != 0 && y != 0 && x != 49 && y != 49) {
                            matrix.set(x, y, ROAD_PLANNER_TUNNEL_COST);
                        }
                        break;
                    default:
                        matrix.set(x, y, ROAD_PLANNER_PLAIN_COST);
                        break;
                }
            }
        }
        for (const pos of obstacles) {
            if (pos.roomName == roomName) {
                matrix.set(pos.x, pos.y, 0xff);
            }
        }
        const room = Game.rooms[roomName];
        if (room) {
            const impassibleStructures = [];
            _.forEach(room.find(FIND_STRUCTURES), (s) => {
                if (!s.isWalkable) {
                    impassibleStructures.push(s);
                }
            });
            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
            _.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site) => {
                if (!site.isWalkable) {
                    matrix.set(site.pos.x, site.pos.y, 0xff);
                }
            });
        }
        return matrix;
    }
    generateRoadPath(origin, destination, obstacles) {
        const callback = (roomName) => {
            if (!this.colony.roomNames.includes(roomName)) {
                return false;
            }
            if (Pathing.shouldAvoid(roomName) && roomName != origin.roomName && roomName != destination.roomName) {
                return false;
            }
            if (!this.costMatrices[roomName]) {
                this.costMatrices[roomName] = this.generateRoadPlanningCostMatrix(roomName, obstacles);
            }
            return this.costMatrices[roomName];
        };
        const ret = PathFinder.search(origin, { pos: destination, range: 1 }, { roomCallback: callback, maxOps: 40000 });
        if (ret.incomplete) {
            log.warning(`Roadplanner for ${this.colony.print}: could not plan road path!`);
            return;
        }
        if (RoadPlanner_1.settings.encourageRoadMerging) {
            for (const i of _.range(ret.path.length)) {
                const pos = ret.path[i];
                if (i % 2 == 0 && this.costMatrices[pos.roomName] && !pos.isEdge) {
                    this.costMatrices[pos.roomName].set(pos.x, pos.y, EXISTING_PATH_COST);
                }
            }
        }
        return ret.path;
    }
    formatRoadPositions() {
        this.roadPositions = _.unique(this.roadPositions);
        _.remove(this.roadPositions, pos => pos.isEdge);
        const roomPlannerRoads = this.roomPlanner.plannedStructurePositions(STRUCTURE_ROAD);
        if (roomPlannerRoads != undefined) {
            _.remove(this.roadPositions, pos => roomPlannerRoads.includes(pos));
        }
    }
    finalize() {
        let roomPlannerRoads;
        if (_.keys(this.roomPlanner.map).length > 0) {
            roomPlannerRoads = this.roomPlanner.map[STRUCTURE_ROAD];
        }
        else {
            if (this.roomPlanner.memory.bunkerData && this.roomPlanner.memory.bunkerData.anchor) {
                const layout = this.roomPlanner.getStructureMapForBunkerAt(this.roomPlanner.memory.bunkerData.anchor, this.colony.controller.level);
                roomPlannerRoads = layout[STRUCTURE_ROAD];
            }
            else if (this.roomPlanner.memory.mapsByLevel) {
                roomPlannerRoads = _.map(this.roomPlanner.memory.mapsByLevel[this.colony.controller.level][STRUCTURE_ROAD], protoPos => derefRoomPosition(protoPos));
            }
            else {
                log.error(`RoadPlanner@${this.colony.room.print}: could not get road positions from room planner!`);
                roomPlannerRoads = [];
            }
        }
        const allRoadPos = _.compact(this.roadPositions.concat(roomPlannerRoads));
        const allRoadPosByRoomName = _.groupBy(allRoadPos, pos => pos.roomName);
        this.memory.roadCoordsPacked = {};
        for (const roomName in allRoadPosByRoomName) {
            this.memory.roadCoordsPacked[roomName] = packCoordList(allRoadPosByRoomName[roomName]);
        }
    }
    init() {
    }
    static shouldBuild(structureType, pos) {
        if (!pos.room)
            return false;
        const buildings = _.filter(pos.lookFor(LOOK_STRUCTURES), s => s && s.structureType == structureType);
        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);
        if (!buildings || buildings.length == 0) {
            if (!sites || sites.length == 0) {
                return true;
            }
        }
        return false;
    }
    buildMissing() {
        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;
        let roadPositions = [];
        for (const roomName in this.memory.roadCoordsPacked) {
            roadPositions = roadPositions.concat(unpackCoordListAsPosList(this.memory.roadCoordsPacked[roomName], roomName));
        }
        const origin = (this.colony.storage || this.colony.hatchery || this.colony).pos;
        roadPositions = _.sortBy(roadPositions, pos => pos.getMultiRoomRangeTo(origin));
        let needsRoad = false;
        for (const pos of roadPositions) {
            if (!pos.room) {
                continue;
            }
            const road = pos.lookForStructure(STRUCTURE_ROAD);
            if (!road && pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0) {
                needsRoad = true;
                if (count <= 0)
                    break;
                const ret = pos.createConstructionSite(STRUCTURE_ROAD);
                if (ret == OK) {
                    count--;
                    continue;
                }
                if (ret == ERR_NOT_OWNER) {
                    if (Game.time % 50 == 0) {
                        log.warning(`${this.colony.print}: couldn't create road site at ${pos.print}; room ` +
                            `is reserved/owned by hostile forces!`);
                    }
                }
                else if (ret == ERR_FULL) {
                    log.warning(`${this.colony.print}: couldn't create road site at ${pos.print}, too many ` +
                        `construction sites!`);
                    break;
                }
                else {
                    log.warning(`${this.colony.print}: couldn't create road site at ${pos.print} (${ret})`);
                }
            }
        }
        if (needsRoad) {
            this.roomPlanner.requestRecheck(100);
        }
    }
    roadShouldBeHere(pos) {
        if (this._roadLookup == undefined) {
            this._roadLookup = _.memoize((p) => (this.memory.roadCoordsPacked[p.roomName] || '').includes(packCoord(p)));
        }
        return this._roadLookup(pos);
    }
    getRoadPositions(roomName) {
        if (this.memory.roadCoordsPacked[roomName]) {
            return unpackCoordListAsPosList(this.memory.roadCoordsPacked[roomName], roomName);
        }
        else {
            return [];
        }
    }
    cleanRoadCoverage() {
        const colonyDestinations = this.colony.destinations.map(dest => `${dest.pos.roomName}:${dest.pos.x}:${dest.pos.y}`);
        for (const roadCoverageKey of Object.keys(this.memory.roadCoverages)) {
            if (colonyDestinations.includes(roadCoverageKey))
                continue;
            log.alert(`Colony does not have destination of ${roadCoverageKey}, deleting.`);
            delete this.memory.roadCoverages[roadCoverageKey];
        }
    }
    run() {
        if (this.roomPlanner.active) {
            if (this.roomPlanner.storagePos) {
                this.buildRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles(8));
            }
            this.visuals();
            return;
        }
        if (this.colony.level >= RoadPlanner_1.settings.buildRoadsAtRCL && this.roomPlanner.storagePos) {
            if (Game.time % RoadPlanner_1.settings.recalculateRoadNetworkInterval == this.colony.id) {
                log.debug("recalculate road network");
                this.recalculateRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles(8));
            }
            if (Game.time % RoadPlanner_1.settings.recomputeCoverageInterval == this.colony.id) {
                log.debug("recalculate road coverage");
                this.cleanRoadCoverage();
                this.recomputeRoadCoverages(this.roomPlanner.storagePos);
            }
        }
        if (this.colony.level >= RoadPlanner_1.settings.buildRoadsAtRCL && this.roomPlanner.shouldRecheck(4)) {
            this.buildMissing();
        }
    }
    visuals() {
        Visualizer.drawRoads(this.roadPositions);
    }
};
RoadPlanner.settings = {
    encourageRoadMerging: true,
    recalculateRoadNetworkInterval: onPublicServer() ? 1250 : 250,
    recomputeCoverageInterval: onPublicServer() ? 1500 : 500,
    buildRoadsAtRCL: 4,
};
RoadPlanner = RoadPlanner_1 = __decorate([
    profile
], RoadPlanner);

var RoomPlanner_1;
const getDefaultRoomPlannerMemory = () => ({
    active: true,
    savedFlags: [],
});
function getAllStructureCoordsFromLayout(layout, rcl) {
    if (!layout[rcl]) {
        return [];
    }
    const positionsByType = layout[rcl].buildings;
    let coords = [];
    for (const structureType in positionsByType) {
        coords = coords.concat(positionsByType[structureType].pos);
    }
    return _.unique(coords, coord => coord.x + 50 * coord.y);
}
function translatePositions(positions, fromAnchor, toAnchor) {
    const dx = toAnchor.x - fromAnchor.x;
    const dy = toAnchor.y - fromAnchor.y;
    const newPositions = [];
    for (const pos of positions) {
        newPositions.push(new RoomPosition(pos.x + dx, pos.y + dy, pos.roomName));
    }
    return newPositions;
}
let RoomPlanner = RoomPlanner_1 = class RoomPlanner {
    constructor(colony) {
        this.colony = colony;
        this.memory = Mem.wrap(this.colony.memory, 'roomPlanner', getDefaultRoomPlannerMemory);
        this.barrierPlanner = new BarrierPlanner(this);
        this.roadPlanner = new RoadPlanner(this);
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'roomPlanner', getDefaultRoomPlannerMemory);
        this.placements = {
            hatchery: undefined,
            commandCenter: undefined,
            bunker: undefined,
        };
        this.plan = {};
        this.map = {};
        this.barrierPlanner.refresh();
        this.roadPlanner.refresh();
        if (this.active && Game.time % 25 == 0) {
            log.alert(`RoomPlanner for ${this.colony.room.print} is still active! Close to save CPU.`);
        }
    }
    get active() {
        return this.memory.active;
    }
    set active(active) {
        this.memory.active = active;
        if (active) {
            this.reactivate();
        }
    }
    recallMap(level = this.colony.controller.level) {
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            this.map = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor, level);
        }
        else if (this.memory.mapsByLevel) {
            this.map = _.mapValues(this.memory.mapsByLevel[level], posArr => _.map(posArr, protoPos => derefRoomPosition(protoPos)));
        }
    }
    plannedStructurePositions(structureType) {
        if (this.map[structureType]) {
            return this.map[structureType];
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return this.getBunkerStructurePlacement(structureType, this.memory.bunkerData.anchor, 8);
        }
        const roomMap = this.memory.mapsByLevel ? this.memory.mapsByLevel[8] : undefined;
        if (roomMap && roomMap[structureType]) {
            return _.map(roomMap[structureType], protoPos => derefRoomPosition(protoPos));
        }
    }
    get storagePos() {
        if (this.placements.commandCenter) {
            return this.placements.commandCenter;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_STORAGE);
        if (positions) {
            return positions[0];
        }
    }
    get hatcheryPos() {
        if (this.placements.hatchery) {
            return this.placements.hatchery;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_SPAWN);
        if (positions) {
            return positions[0];
        }
    }
    get bunkerPos() {
        if (this.placements.bunker) {
            return this.placements.bunker;
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return new RoomPosition(this.memory.bunkerData.anchor.x, this.memory.bunkerData.anchor.y, this.colony.name);
        }
    }
    reactivate() {
        for (const protoFlag of this.memory.savedFlags) {
            const pos = derefRoomPosition(protoFlag.pos);
            const result = pos.createFlag(undefined, COLOR_WHITE, protoFlag.secondaryColor);
            if (typeof result == 'string') {
                Memory.flags[result] = protoFlag.memory;
            }
        }
        this.memory.savedFlags = [];
        const msg = [
            `Room planner activated for ${this.colony.name}. Reinstantiating flags from previous session on next tick.`,
            'Place colony components with room planner flags:',
            bullet + 'Place bunker (recommended)  white/red',
            bullet + 'Place hatchery:             white/green',
            bullet + 'Place command center:       white/blue',
            'Finalize layout '
        ];
        _.forEach(msg, command => console.log(command));
    }
    make(level = 8) {
        this.plan = {};
        this.map = {};
        this.plan = this.generatePlan(level);
        this.map = this.mapFromPlan(this.plan);
    }
    placeStructure(type, pos) {
        if (!this.map[type])
            this.map[type] = [];
        this.map[type].push(pos);
    }
    addComponent(componentName, pos, rotation = 0) {
        this.placements[componentName] = pos;
    }
    getLayout(name) {
        switch (name) {
            case 'hatchery':
                return hatcheryLayout;
            case 'commandCenter':
                return commandCenterLayout;
            case 'bunker':
                return bunkerLayout;
        }
    }
    generatePlan(level) {
        const plan = {};
        for (const name in this.placements) {
            const layout = this.getLayout(name);
            if (layout) {
                const anchor = layout.data.anchor;
                const pos = this.placements[name];
                if (!pos)
                    continue;
                const componentMap = this.parseLayout(layout, level);
                this.translateComponent(componentMap, anchor, pos);
                plan[name] = {
                    map: componentMap,
                    pos: new RoomPosition(anchor.x, anchor.y, this.colony.name),
                    rotation: 0,
                };
            }
        }
        return plan;
    }
    parseLayout(structureLayout, level) {
        const map = {};
        const layout = structureLayout[level];
        if (layout) {
            for (const buildingName in layout.buildings) {
                map[buildingName] = _.map(layout.buildings[buildingName].pos, pos => new RoomPosition(pos.x, pos.y, this.colony.name));
            }
        }
        return map;
    }
    mapFromPlan(plan) {
        const map = {};
        const componentMaps = _.map(plan, componentPlan => componentPlan.map);
        const structureNames = _.unique(_.flatten(_.map(componentMaps, map => _.keys(map))));
        for (const name of structureNames) {
            map[name] = _.compact(_.flatten(_.map(componentMaps, map => map[name])));
        }
        return map;
    }
    translateComponent(map, fromPos, toPos) {
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                pos.x += dx;
                pos.y += dy;
            }
        }
    }
    rotateComponent(map, pivot, angle) {
        let R = ([x, y]) => ([x, y]);
        if (angle == 0) {
            return;
        }
        else if (angle == 90 || angle == 1) {
            R = ([x, y]) => ([-y, x]);
        }
        else if (angle == 180 || angle == 2) {
            R = ([x, y]) => ([-x, -y]);
        }
        else if (angle == 270 || angle == 3) {
            R = ([x, y]) => ([y, -x]);
        }
        let offset, dx, dy;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                offset = [pos.x - pivot.x, pos.y - pivot.y];
                [dx, dy] = R(offset);
                pos.x = pivot.x + dx;
                pos.y = pivot.y + dy;
            }
        }
    }
    getStructureMapForBunkerAt(anchor, level) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const structureLayout = _.mapValues(bunkerLayout[level].buildings, obj => obj.pos);
        return _.mapValues(structureLayout, coordArr => _.map(coordArr, coord => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name)));
    }
    getBunkerStructurePlacement(structureType, anchor, level) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        return _.map(bunkerLayout[level].buildings[structureType].pos, coord => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name));
    }
    getObstacles(level) {
        let obstacles = [];
        obstacles.concat(_.map(this.colony.sources, source => source.pos));
        obstacles.concat(_.map(this.colony.extractors, extr => extr.pos));
        const passableStructureTypes = [STRUCTURE_ROAD, STRUCTURE_CONTAINER, STRUCTURE_RAMPART];
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            const structureMap = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor, level);
            for (const structureType in structureMap) {
                if (!passableStructureTypes.includes(structureType)) {
                    obstacles = obstacles.concat(structureMap[structureType]);
                }
            }
        }
        else if (this.memory.mapsByLevel) {
            for (const structureType in this.memory.mapsByLevel[level]) {
                if (!passableStructureTypes.includes(structureType)) {
                    obstacles = obstacles.concat(_.map(this.memory.mapsByLevel[level][structureType], protoPos => derefRoomPosition(protoPos)));
                }
            }
        }
        return _.unique(obstacles);
    }
    findCollision(ignoreRoads = false) {
        const terrain = Game.map.getRoomTerrain(this.colony.room.name);
        for (const structureType in this.map) {
            if (ignoreRoads && structureType == STRUCTURE_ROAD) {
                continue;
            }
            for (const pos of this.map[structureType]) {
                if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {
                    return pos;
                }
            }
        }
    }
    finalize(ignoreRoads = false) {
        const collision = this.findCollision(ignoreRoads);
        if (collision) {
            log.warning(`Invalid layout: collision detected at ${collision.print}!`);
            return;
        }
        const layoutIsValid = (!!this.placements.commandCenter && !!this.placements.hatchery)
            || !!this.placements.bunker;
        if (layoutIsValid) {
            delete this.memory.bunkerData;
            delete this.memory.mapsByLevel;
            if (this.placements.bunker) {
                this.memory.bunkerData = {
                    anchor: this.placements.bunker,
                };
            }
            else {
                this.memory.mapsByLevel = {};
                for (let rcl = 1; rcl <= 8; rcl++) {
                    this.make(rcl);
                    this.memory.mapsByLevel[rcl] = this.map;
                }
            }
            this.barrierPlanner.finalize();
            this.roadPlanner.finalize();
            const flagsToWrite = _.filter(this.colony.flags, flag => flag.color == COLOR_WHITE);
            for (const flag of flagsToWrite) {
                this.memory.savedFlags.push({
                    secondaryColor: flag.secondaryColor,
                    pos: flag.pos,
                    memory: flag.memory,
                });
                flag.remove();
            }
            this.memory.lastGenerated = Game.time;
            console.log('Room layout and flag positions have been saved.');
            if (this.colony.level == 1) {
                this.demolishMisplacedStructures(true, true);
                for (const barrier of this.colony.room.barriers) {
                    if (barrier.structureType == STRUCTURE_WALL || !barrier.my) {
                        barrier.destroy();
                    }
                }
            }
            this.memory.recheckStructuresAt = Game.time + 3;
            this.active = false;
        }
        else {
            log.warning('Not a valid room layout! Must have both hatchery and commandCenter placements ' +
                'or bunker placement.');
        }
    }
    static canBuild(structureType, pos) {
        if (!pos.room)
            return false;
        const structure = pos.lookForStructure(structureType);
        const constructionSite = pos.lookFor(LOOK_CONSTRUCTION_SITES)[0];
        return !structure && !constructionSite;
    }
    structureShouldBeHere(structureType, pos, level = this.colony.controller.level) {
        if (structureType == STRUCTURE_ROAD) {
            return this.roadShouldBeHere(pos);
        }
        else if (structureType == STRUCTURE_RAMPART) {
            return this.barrierPlanner.barrierShouldBeHere(pos);
        }
        else if (structureType == STRUCTURE_EXTRACTOR) {
            return pos.lookFor(LOOK_MINERALS).length > 0;
        }
        else {
            if (_.isEmpty(this.map)) {
                this.recallMap();
            }
            const positions = this.map[structureType];
            if (positions && _.find(positions, p => p.isEqualTo(pos))) {
                return true;
            }
            if (structureType == STRUCTURE_CONTAINER || structureType == STRUCTURE_LINK) {
                const thingsBuildingLinksAndContainers = _.map([...this.colony.room.sources,
                    this.colony.room.mineral,
                    this.colony.controller], thing => thing.pos);
                const maxRange = 4;
                return pos.findInRange(thingsBuildingLinksAndContainers, maxRange).length > 0;
            }
        }
        return false;
    }
    demolishHostileStructures(destroyStorageUnits = false) {
        _.forEach(this.colony.room.walls, wall => wall.destroy());
        for (const structure of _.filter(this.colony.room.hostileStructures)) {
            if ((structure.structureType != STRUCTURE_STORAGE && structure.structureType != STRUCTURE_TERMINAL)
                || destroyStorageUnits) {
                structure.destroy();
            }
        }
    }
    removeMisplacedConstructionSites() {
        for (const site of this.colony.room.find(FIND_CONSTRUCTION_SITES)) {
            if (site.owner.username != MY_USERNAME) {
                site.remove();
            }
            else if (!this.structureShouldBeHere(site.structureType, site.pos)) {
                site.remove();
            }
        }
    }
    demolishMisplacedStructures(skipRamparts = true, destroyAllStructureTypes = false) {
        this.demolishHostileStructures();
        this.removeMisplacedConstructionSites();
        if (getAllColonies().length <= 1 && !this.colony.storage) {
            return;
        }
        if (this.colony.terminal) {
            if (this.colony.storage && !this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos)
                || !this.structureShouldBeHere(STRUCTURE_TERMINAL, this.colony.terminal.pos)) {
                DirectiveTerminalRebuildState.createIfNotPresent(this.colony.terminal.pos, 'pos');
            }
        }
        const count = RoomPlanner_1.settings.maxSitesPerColony - this.colony.constructionSites.length;
        this.recallMap();
        if (!this.map || _.isEmpty(this.map)) {
            log.info(this.colony.name + ' does not have a room plan yet! Unable to demolish errant structures.');
        }
        if (this.colony.room.extractor && !this.colony.room.extractor.my) {
            this.colony.room.extractor.destroy();
        }
        this.memory.relocating = false;
        this.memory.misplacedStructures = false;
        for (const priority of DemolishStructurePriorities) {
            const structureType = priority.structureType;
            const maxRemoved = priority.maxRemoved || Infinity;
            let removeCount = 0;
            let structures = _.filter(this.colony.room.find(FIND_STRUCTURES), s => s.structureType == structureType);
            if (structureType == STRUCTURE_WALL) {
                structures = _.filter(structures, wall => wall.hits != undefined);
            }
            for (const structure of structures) {
                if (!this.structureShouldBeHere(structureType, structure.pos) || (isOwnedStructure(structure) && !structure.my)) {
                    if (skipRamparts && !destroyAllStructureTypes && isRampart(structure) && structure.my) {
                        continue;
                    }
                    this.memory.misplacedStructures = true;
                    if (this.colony.level < 4 && (isStorage(structure) || isTerminal(structure))) {
                        break;
                    }
                    if (this.colony.level < 6 && isTerminal(structure) && hasMinerals(structure.store)) {
                        break;
                    }
                    if (!isWall(structure) && !isRampart(structure)) {
                        this.memory.relocating = true;
                    }
                    if (this.colony.level >= 6 && isTerminal(structure)) {
                        if (!this.colony.storage) {
                            log.info(`${this.colony.name}: waiting until storage is built to remove terminal`);
                            return;
                        }
                        else if (this.colony.terminal && _.sum(this.colony.terminal.store) - this.colony.terminal.energy > 1000) {
                            log.info(`${this.colony.name}: waiting on resources to evacuate before removing terminal`);
                            return;
                        }
                        else if (this.colony.storage && this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos) &&
                            this.colony.storage.energy < Energetics.settings.storage.energy.destroyTerminalThreshold) {
                            log.info(`${this.colony.name}: waiting to move energy to storage before removing terminal`);
                            return;
                        }
                    }
                    const amountMissing = CONTROLLER_STRUCTURES[structureType][this.colony.level] - structures.length
                        + removeCount;
                    if (amountMissing < maxRemoved) {
                        if (isSpawn(structure) && this.colony.spawns.length == 1) {
                            const spawnCost = 15000;
                            if (this.colony.assets[RESOURCE_ENERGY] < spawnCost) {
                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ${this.colony.assets[RESOURCE_ENERGY]}/${spawnCost} energy available`);
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                            const workTicksNeeded = 15000 / BUILD_POWER;
                            const workTicksAvailable = _.sum(this.colony.overlords.work.workers, worker => worker.getActiveBodyparts(WORK) * (worker.ticksToLive || 0));
                            if (workTicksAvailable < workTicksNeeded) {
                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                    `${workTicksAvailable}/${workTicksNeeded} [WORK * ticks] available`);
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                        }
                        const result = 'destroy() disabled';
                        if (result != OK) {
                            log.warning(`${this.colony.name}: couldn't destroy structure of type ` +
                                `"${structureType}" at ${structure.pos.print}. Result: ${result}`);
                        }
                        else {
                            log.info(`${this.colony.name}: destroyed ${structureType} at ${structure.pos.print}`);
                        }
                        removeCount++;
                        this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;
                    }
                }
            }
            if (this.memory.relocating && !destroyAllStructureTypes) {
                return;
            }
        }
    }
    buildMissingStructures() {
        let remainingSites = RoomPlanner_1.settings.maxSitesPerColony - this.colony.constructionSites.length;
        if (this.colony.defcon > DEFCON.safe) {
            remainingSites = 1;
            if (this.colony.constructionSites.length > 1)
                return;
        }
        this.recallMap();
        if (!this.map || _.isEmpty(this.map)) {
            log.info(this.colony.name + ' does not have a room plan yet! Unable to build missing structures.');
        }
        for (const structureType of BuildPriorities) {
            if (!this.map[structureType])
                continue;
            for (const pos of this.map[structureType]) {
                if (RoomPlanner_1.canBuild(structureType, pos) && remainingSites > 0) {
                    if (structureType == STRUCTURE_TOWER || structureType == STRUCTURE_RAMPART || structureType == STRUCTURE_WALL) {
                        if (this.colony.stage == ColonyStage.Larva && (this.colony.controller.safeMode || 0) > 2500) {
                            continue;
                        }
                    }
                    const result = pos.createConstructionSite(structureType);
                    if (result == OK) {
                        remainingSites--;
                        this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;
                    }
                    else if (result == ERR_GCL_NOT_ENOUGH || result == ERR_RCL_NOT_ENOUGH) {
                        log.debug(`${this.colony.print}: couldn't build ${structureType} at ${pos.print}! RCL or GCL too low.`);
                    }
                    else {
                        log.warning(`${this.colony.print}: couldn't create site of type "${structureType}" at ${pos.print}. Result: ${result}`);
                        const destroyResult = this.destroyStructurePreventingBuildingAtPos(pos);
                        if (destroyResult == OK) {
                            log.info(`${this.colony.print}: destroyed ${structureType} at ${pos.print}`);
                            this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;
                        }
                        else {
                            log.warning(`${this.colony.print}: couldn't destroy ${structureType} at ${pos.print}! Result: ${destroyResult}`);
                        }
                    }
                }
            }
        }
        const mineral = this.colony.room.mineral;
        if (mineral) {
            const extractor = mineral.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            if (!extractor) {
                mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);
            }
        }
    }
    destroyStructurePreventingBuildingAtPos(pos) {
        const structures = pos.lookFor(LOOK_STRUCTURES);
        for (const structure of structures) {
            const safeTypes = [STRUCTURE_STORAGE, STRUCTURE_TERMINAL, STRUCTURE_SPAWN];
            if (!this.structureShouldBeHere(structure.structureType, pos)) {
                if (safeTypes.includes(structure.structureType)) {
                    return `${structure.structureType} is safe type!`;
                }
                else {
                    return 'destroy() disabled';
                }
            }
        }
        log.error(`destroyStructurePreventingBuildingAtPos shouldn't be called here`);
        return `destroyStructurePreventingBuildingAtPos shouldn't be called here`;
    }
    calculateLinkPos(anchor) {
        if (anchor.isEqualTo(this.colony.controller.pos)) {
            return this.calculateUpgradeSiteLinkPos();
        }
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(anchor, originPos).path;
            return _.find(path, pos => anchor.getRangeTo(pos) == 2);
        }
    }
    calculateUpgradeSiteLinkPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos && this.colony.upgradeSite.batteryPos) {
            const path = Pathing.findShortestPath(this.colony.upgradeSite.batteryPos, originPos).path;
            return path[0];
        }
    }
    nextNeededLinkAnchor() {
        const linksEtAl = _.map([]
            .concat(this.colony.links, _.filter(this.colony.constructionSites, site => site.structureType == STRUCTURE_LINK)), s => s.pos);
        const upgradeLink = this.colony.controller.pos.findClosestByLimitedRange(linksEtAl, 3);
        if (!upgradeLink)
            return this.colony.controller.pos;
        const origin = (this.colony.storage || this.colony.terminal || _.first(this.colony.spawns) || this.colony).pos;
        const farthestSources = _.sortBy(this.colony.room.sources, source => -1 * (Pathing.distance(origin, source.pos) || Infinity));
        for (const source of farthestSources) {
            const sourceLink = source.pos.findClosestByLimitedRange(linksEtAl, 2);
            if (!sourceLink)
                return source.pos;
        }
    }
    buildNeededLinks() {
        const numLinks = this.colony.links.length +
            _.filter(this.colony.constructionSites, site => site.structureType == STRUCTURE_LINK).length;
        const numLinksAllowed = CONTROLLER_STRUCTURES.link[this.colony.level];
        if (numLinksAllowed > numLinks &&
            (this.colony.bunker || (this.colony.hatchery && this.colony.hatchery.link)) &&
            this.colony.commandCenter && this.colony.commandCenter.link) {
            const anchor = this.nextNeededLinkAnchor();
            if (!anchor) {
                return;
            }
            const linkPos = this.calculateLinkPos(anchor);
            if (!linkPos) {
                log.warning(`Could not calculate link position for anchor at ${anchor.print}!`);
                return;
            }
            linkPos.createConstructionSite(STRUCTURE_LINK);
        }
    }
    roadShouldBeHere(pos) {
        return this.roadPlanner.roadShouldBeHere(pos);
    }
    init() {
        if (this.active) {
            Overmind.overseer.notifier.alert(`Room planner active!`, this.colony.room.name);
        }
        if (this.memory.misplacedStructures) {
            Overmind.overseer.notifier.alert(`Misplaced structures!`, this.colony.room.name);
        }
        if (this.active && getAutonomyLevel() == Autonomy.Automatic && !this.memory.bunkerData) {
            let bunkerAnchor;
            if (this.colony.spawns.length > 0) {
                const lowerRightSpawn = maxBy(this.colony.spawns, s => 50 * s.pos.y + s.pos.x);
                const spawnPos = lowerRightSpawn.pos;
                bunkerAnchor = new RoomPosition(spawnPos.x - 4, spawnPos.y, spawnPos.roomName);
            }
            else {
                const expansionData = RoomIntel.getExpansionData(this.colony.room.name);
                if (expansionData) {
                    bunkerAnchor = expansionData.bunkerAnchor;
                }
                else {
                    log.error(`Cannot determine anchor! No spawns or expansionData.bunkerAnchor for ` +
                        `${this.colony.print}!`);
                    return;
                }
            }
            this.addComponent('bunker', bunkerAnchor);
        }
        this.barrierPlanner.init();
        this.roadPlanner.init();
    }
    requestRecheck(ticksFromNow = 1) {
        this.memory.recheckStructuresAt = Game.time + ticksFromNow;
    }
    shouldRecheck(offset = 0) {
        if (Game.time == (this.memory.recheckStructuresAt || Infinity) + offset) {
            return true;
        }
        else {
            const checkFreq = RoomPlanner_1.settings.siteCheckFrequency * this.colony.level;
            return Game.time % checkFreq == (2 * this.colony.id + offset) % checkFreq;
        }
    }
    run() {
        if (this.active) {
            this.make();
            this.visuals();
        }
        else {
            if (this.shouldRecheck()) {
                this.demolishMisplacedStructures();
            }
            else if (this.shouldRecheck(1)) {
                this.buildMissingStructures();
            }
            if (Game.time % RoomPlanner_1.settings.linkCheckFrequency == 3) {
                this.buildNeededLinks();
            }
        }
        this.barrierPlanner.run();
        this.roadPlanner.run();
        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {
            if (this.placements.bunker) {
                this.finalize();
            }
            else {
                log.warning(`No bunker placement!`);
            }
        }
    }
    visuals() {
        if (getAutonomyLevel() < Autonomy.Automatic) {
            const expansionData = RoomIntel.getExpansionData(this.colony.room.name);
            if (expansionData) {
                Visualizer.drawLayout(bunkerLayout, expansionData.bunkerAnchor, { opacity: 0.2 });
            }
        }
        Visualizer.drawStructureMap(this.map);
    }
};
RoomPlanner.settings = {
    recheckAfter: 50,
    siteCheckFrequency: onPublicServer() ? 50 : 25,
    linkCheckFrequency: 100,
    maxSitesPerColony: onPublicServer() ? 10 : 25,
    maxDismantleCount: 5,
};
RoomPlanner = RoomPlanner_1 = __decorate([
    profile
], RoomPlanner);

const BUNKER_RADIUS = 6;
const bunkerLayout = {
    data: {
        anchor: { 'x': 25, 'y': 25 }
    },
    1: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '1',
        'buildings': {
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] }
        }
    },
    2: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '2',
        'buildings': {
            'extension': {
                'pos': [{ 'x': 28, 'y': 26 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, {
                        'x': 27,
                        'y': 28
                    }, { 'x': 29, 'y': 26 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    3: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '3',
        'buildings': {
            'tower': { 'pos': [{ 'x': 25, 'y': 26 }] },
            'extension': {
                'pos': [{ 'x': 28, 'y': 26 }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, {
                        'x': 27,
                        'y': 27
                    }, { 'x': 27, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, {
                        'x': 27,
                        'y': 29
                    }, { 'x': 29, 'y': 26 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    4: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '4',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 26 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, {
                        'x': 23,
                        'y': 20
                    }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 27, 'y': 30 }]
            },
            'observer': { 'pos': [] },
            'lab': { 'pos': [] },
            'extension': {
                'pos': [{ 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, {
                        'x': 28,
                        'y': 26
                    }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, {
                        'x': 28,
                        'y': 28
                    }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 26, 'y': 28 }, {
                        'x': 24,
                        'y': 30
                    }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 29, 'y': 26 }, { 'x': 24, 'y': 29 }, {
                        'x': 30,
                        'y': 27
                    }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    5: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '5',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, {
                        'x': 23,
                        'y': 20
                    }, { 'x': 27, 'y': 30 }]
            },
            'observer': { 'pos': [] },
            'lab': { 'pos': [] },
            'extension': {
                'pos': [{ 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, {
                        'x': 28,
                        'y': 26
                    }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, {
                        'x': 28,
                        'y': 28
                    }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 26, 'y': 28 }, {
                        'x': 23,
                        'y': 27
                    }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 22, 'y': 27 }, { 'x': 21, 'y': 27 }, {
                        'x': 22,
                        'y': 28
                    }, { 'x': 23, 'y': 29 }, { 'x': 21, 'y': 28 }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }, {
                        'x': 26,
                        'y': 30
                    }, { 'x': 29, 'y': 26 }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 30, 'y': 27 }, {
                        'x': 25,
                        'y': 29
                    }, { 'x': 22, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    6: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '6',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [{ 'x': 26, 'y': 25 }] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, {
                        'x': 22,
                        'y': 22
                    }, { 'x': 23, 'y': 23 }, { 'x': 23, 'y': 20 }, { 'x': 27, 'y': 30 }]
            },
            'observer': { 'pos': [] },
            'lab': { 'pos': [{ 'x': 27, 'y': 23 }, { 'x': 28, 'y': 24 }, { 'x': 28, 'y': 23 }] },
            'extension': {
                'pos': [{ 'x': 22, 'y': 24 }, { 'x': 22, 'y': 23 }, { 'x': 21, 'y': 23 }, {
                        'x': 30,
                        'y': 24
                    }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, { 'x': 20, 'y': 24 }, { 'x': 20, 'y': 25 }, {
                        'x': 20,
                        'y': 26
                    }, { 'x': 21, 'y': 22 }, { 'x': 28, 'y': 26 }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, {
                        'x': 27,
                        'y': 27
                    }, { 'x': 27, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, {
                        'x': 27,
                        'y': 29
                    }, { 'x': 26, 'y': 28 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 24, 'y': 28 }, {
                        'x': 23,
                        'y': 28
                    }, { 'x': 22, 'y': 27 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 23, 'y': 29 }, {
                        'x': 22,
                        'y': 29
                    }, { 'x': 21, 'y': 28 }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, {
                        'x': 29,
                        'y': 26
                    }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 20, 'y': 23 }, {
                        'x': 30,
                        'y': 27
                    }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    7: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '7',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [{ 'x': 26, 'y': 25 }] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }, { 'x': 25, 'y': 23 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 27, 'y': 22 }, { 'x': 28, 'y': 21 }, {
                        'x': 23,
                        'y': 25
                    }, { 'x': 27, 'y': 25 }, { 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }]
            },
            'observer': { 'pos': [] },
            'lab': {
                'pos': [{ 'x': 27, 'y': 23 }, { 'x': 28, 'y': 24 }, { 'x': 28, 'y': 22 }, {
                        'x': 28,
                        'y': 23
                    }, { 'x': 29, 'y': 23 }, { 'x': 29, 'y': 22 }]
            },
            'extension': {
                'pos': [{ 'x': 24, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 22, 'y': 24 }, {
                        'x': 22,
                        'y': 23
                    }, { 'x': 23, 'y': 22 }, { 'x': 23, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 21, 'y': 23 }, {
                        'x': 25,
                        'y': 20
                    }, { 'x': 26, 'y': 20 }, { 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, {
                        'x': 20,
                        'y': 24
                    }, { 'x': 20, 'y': 25 }, { 'x': 20, 'y': 26 }, { 'x': 22, 'y': 21 }, { 'x': 21, 'y': 22 }, {
                        'x': 28,
                        'y': 26
                    }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, {
                        'x': 28,
                        'y': 28
                    }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 26, 'y': 28 }, {
                        'x': 22,
                        'y': 26
                    }, { 'x': 23, 'y': 27 }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 22, 'y': 27 }, {
                        'x': 21,
                        'y': 27
                    }, { 'x': 22, 'y': 28 }, { 'x': 23, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 21, 'y': 28 }, {
                        'x': 24,
                        'y': 30
                    }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 29, 'y': 26 }, { 'x': 21, 'y': 24 }, {
                        'x': 26,
                        'y': 21
                    }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 20, 'y': 23 }, { 'x': 27, 'y': 20 }, {
                        'x': 30,
                        'y': 27
                    }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }, { 'x': 26, 'y': 24 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }] }
        }
    },
    8: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '8',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [{ 'x': 26, 'y': 25 }] },
            'nuker': { 'pos': [{ 'x': 24, 'y': 24 }] },
            'tower': {
                'pos': [{ 'x': 27, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 25, 'y': 27 }, {
                        'x': 25,
                        'y': 23
                    }, { 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }]
            },
            'powerSpawn': { 'pos': [{ 'x': 24, 'y': 26 }] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }]
            },
            'observer': { 'pos': [{ 'x': 21, 'y': 25 }] },
            'lab': {
                'pos': [{ 'x': 26, 'y': 22 }, { 'x': 27, 'y': 23 }, { 'x': 28, 'y': 24 }, {
                        'x': 27,
                        'y': 22
                    }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 22 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, {
                        'x': 28,
                        'y': 21
                    }, { 'x': 29, 'y': 22 }]
            },
            'extension': {
                'pos': [{ 'x': 24, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 22, 'y': 24 }, {
                        'x': 22,
                        'y': 23
                    }, { 'x': 23, 'y': 22 }, { 'x': 23, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 21, 'y': 23 }, {
                        'x': 24,
                        'y': 20
                    }, { 'x': 25, 'y': 20 }, { 'x': 26, 'y': 20 }, { 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, {
                        'x': 30,
                        'y': 26
                    }, { 'x': 20, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 20, 'y': 26 }, { 'x': 22, 'y': 21 }, {
                        'x': 21,
                        'y': 22
                    }, { 'x': 28, 'y': 26 }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, {
                        'x': 27,
                        'y': 28
                    }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, {
                        'x': 26,
                        'y': 28
                    }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 28 }, {
                        'x': 22,
                        'y': 27
                    }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 23, 'y': 29 }, { 'x': 22, 'y': 29 }, {
                        'x': 21,
                        'y': 28
                    }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 29, 'y': 26 }, {
                        'x': 21,
                        'y': 24
                    }, { 'x': 26, 'y': 21 }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 20, 'y': 23 }, {
                        'x': 27,
                        'y': 20
                    }, { 'x': 30, 'y': 27 }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }, { 'x': 26, 'y': 24 }, { 'x': 25, 'y': 21 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }] }
        }
    }
};
let _allBunkerCoords = {};
for (let rcl of [1, 2, 3, 4, 5, 6, 7, 8]) {
    if (bunkerLayout[rcl].buildings) {
        _allBunkerCoords[rcl] = getAllStructureCoordsFromLayout(bunkerLayout, rcl);
    }
    if (rcl == 7 || rcl == 8) {
        _allBunkerCoords[rcl].push(bunkerLayout.data.anchor);
    }
}
const allBunkerCoords = _allBunkerCoords;
const bunkerCoordLookup = _.mapValues(_allBunkerCoords, (coordArr) => _.zipObject(_.map(coordArr, c => [packCoord(c), true])));
function insideBunkerBounds(pos, colony) {
    if (colony.roomPlanner.memory.bunkerData && colony.roomPlanner.memory.bunkerData.anchor) {
        const dx = bunkerLayout.data.anchor.x - colony.roomPlanner.memory.bunkerData.anchor.x;
        const dy = bunkerLayout.data.anchor.y - colony.roomPlanner.memory.bunkerData.anchor.y;
        const coord = { x: pos.x + dx, y: pos.y + dy };
        return (!!bunkerCoordLookup[colony.level][packCoord(coord)]);
    }
    return false;
}
function getPosFromBunkerCoord(coord, colony) {
    if (colony.roomPlanner.memory.bunkerData && colony.roomPlanner.memory.bunkerData.anchor) {
        let dx = colony.roomPlanner.memory.bunkerData.anchor.x - bunkerLayout.data.anchor.x;
        let dy = colony.roomPlanner.memory.bunkerData.anchor.y - bunkerLayout.data.anchor.y;
        return new RoomPosition(coord.x + dx, coord.y + dy, colony.room.name);
    }
    console.log('getPosFromBunkerCoord: shouldn\'t reach here! Unprotected call from non-bunker?');
    return new RoomPosition(-1, -1, 'invalid');
}
const bunkerChargingSpots = [{ 'x': 29, 'y': 24 }, { 'x': 24, 'y': 21 }];
const reagentLabSpots = [{ 'x': 27, 'y': 22 }, { 'x': 28, 'y': 23 }];
const quadrantFillOrder = {
    lowerRight: [{ 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 29, 'y': 25 }, { 'x': 29, 'y': 26 }, { 'x': 28, 'y': 26 }, {
            'x': 27,
            'y': 25
        }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 29 }, {
            'x': 28,
            'y': 29
        }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 29, 'y': 27 }, { 'x': 30, 'y': 27 }, { 'x': 30, 'y': 26 }],
    lowerLeft: [{ 'x': 22, 'y': 26 }, { 'x': 22, 'y': 27 }, { 'x': 23, 'y': 27 }, { 'x': 23, 'y': 28 }, {
            'x': 24,
            'y': 28
        }, { 'x': 25, 'y': 27 }, { 'x': 24, 'y': 29 }, { 'x': 25, 'y': 29 }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, {
            'x': 24,
            'y': 30
        }, { 'x': 23, 'y': 30 }, { 'x': 23, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 22, 'y': 28 }, { 'x': 21, 'y': 28 }, {
            'x': 21,
            'y': 27
        }],
    upperLeft: [{ 'x': 23, 'y': 21 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 23, 'y': 23 }, {
            'x': 22,
            'y': 23
        }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 25 }, { 'x': 21, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 20, 'y': 25 }, {
            'x': 20,
            'y': 26
        }, { 'x': 22, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 21, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 20, 'y': 23 }, {
            'x': 20,
            'y': 24
        }],
    upperRight: [{ 'x': 24, 'y': 20 }, { 'x': 25, 'y': 20 }, { 'x': 25, 'y': 21 }, { 'x': 26, 'y': 21 }, {
            'x': 26,
            'y': 22
        }, { 'x': 27, 'y': 22 }, { 'x': 27, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 28, 'y': 24 }, {
            'x': 29,
            'y': 23
        }, { 'x': 29, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 28, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 27, 'y': 20 }, {
            'x': 26,
            'y': 20
        }]
};
const energyStructureOrder = [].concat(quadrantFillOrder.lowerRight, quadrantFillOrder.upperLeft, quadrantFillOrder.lowerLeft, quadrantFillOrder.upperRight);

const MAX_SAMPLE = 10;
const MAX_TOTAL_PATH_LENGTH = 25 * 3;
let BasePlanner = class BasePlanner {
    static getBunkerLocation(room, visualize = true) {
        const colony = Overmind.colonies[room.name];
        if (colony && colony.bunker && colony.bunker.anchor) {
            return colony.bunker.anchor;
        }
        let allowableLocations = this.getAllowableBunkerLocations(room, visualize);
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        const minimizePathLengthTo = _.map(_.compact([...room.sources, room.controller]), obj => obj.pos);
        const totalPathLength = function (anchor) {
            let totalDistance = 0;
            for (const pos of minimizePathLengthTo) {
                const ret = Pathing.findShortestPath(anchor, pos, { ignoreStructures: true });
                if (!ret.incomplete) {
                    totalDistance += ret.path.length;
                }
                else {
                    totalDistance += Infinity;
                }
            }
            return totalDistance;
        };
        const bestAnchor = minBy(allowableLocations, pos => totalPathLength(pos));
        if (bestAnchor && totalPathLength(bestAnchor) <= MAX_TOTAL_PATH_LENGTH) {
            return bestAnchor;
        }
    }
    static getAllowableBunkerLocations(room, visualize = true) {
        let allowableLocations = this.getNonIntersectingBunkerLocations(room.name, visualize);
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        if (!room.controller)
            return [];
        allowableLocations = _.filter(allowableLocations, anchor => !this.bunkerIntersectsWith(anchor, room.controller.pos, 3));
        const sitesAndMineral = _.map(_.compact([...room.sources, room.mineral]), obj => obj.pos);
        allowableLocations = _.filter(allowableLocations, anchor => !_.any(sitesAndMineral, pos => this.bunkerIntersectsWith(anchor, pos, 1)));
        if (visualize) {
            const vis = room.visual;
            for (const pos of allowableLocations) {
                vis.circle(pos.x, pos.y, { fill: 'purple' });
            }
        }
        return allowableLocations;
    }
    static getNonIntersectingBunkerLocations(roomName, visualize = true) {
        const dt = distanceTransform(roomName);
        const coords = [];
        let x, y;
        for (y of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
            for (x of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
                if (dt.get(x, y) >= BUNKER_RADIUS + 1) {
                    coords.push({ x, y });
                }
                else if (dt.get(x, y) >= (BUNKER_RADIUS - 1) && !this.terrainIntersectsWithBunker({ x, y }, dt)) {
                    coords.push({ x, y });
                }
            }
        }
        if (visualize) {
            const vis = new RoomVisual(roomName);
            for (const coord of coords) {
                vis.text(dt.get(coord.x, coord.y).toString(), coord.x, coord.y);
            }
        }
        return _.map(coords, coord => new RoomPosition(coord.x, coord.y, roomName));
    }
    static terrainIntersectsWithBunker(anchor, distanceMatrix) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const bunkerCoordsAtAnchor = _.map(allBunkerCoords[8], function (coord) {
            return { x: coord.x + dx, y: coord.y + dy };
        });
        return _.any(bunkerCoordsAtAnchor, coord => distanceMatrix.get(coord.x, coord.y) == 0);
    }
    static bunkerIntersectsWith(anchor, obstacle, padding = 1) {
        const dx = bunkerLayout.data.anchor.x - anchor.x;
        const dy = bunkerLayout.data.anchor.y - anchor.y;
        let x, y;
        for (x of _.range(obstacle.x + dx - padding, obstacle.x + dx + padding + 1)) {
            for (y of _.range(obstacle.y + dy - padding, obstacle.y + dy + padding + 1)) {
                if (bunkerCoordLookup[8][packCoord({ x, y })]) {
                    return true;
                }
            }
        }
        return false;
    }
};
BasePlanner = __decorate([
    profile
], BasePlanner);

const EXPANSION_EVALUATION_FREQ = 1000;
const MIN_EXPANSION_DISTANCE = 2;
const EXPANSION_SEARCH_DEPTH = 5;
let ExpansionEvaluator = class ExpansionEvaluator {
    static refreshExpansionData(expansionData, colonyRoomName) {
        if (_.keys(expansionData.possibleExpansions).length == 0 || Game.time > expansionData.expiration) {
            const nearbyRooms = Cartographer.recursiveRoomSearch(colonyRoomName, EXPANSION_SEARCH_DEPTH);
            let possibleExpansions = [];
            for (const depth in nearbyRooms) {
                if (parseInt(depth, 10) <= MIN_EXPANSION_DISTANCE)
                    continue;
                possibleExpansions = possibleExpansions.concat(nearbyRooms[depth]);
            }
            for (const roomName in expansionData.possibleExpansions) {
                expansionData.possibleExpansions[roomName] = false;
            }
            for (const roomName of possibleExpansions) {
                if (Cartographer.roomType(roomName) == ROOMTYPE_CONTROLLER) {
                    expansionData.possibleExpansions[roomName] = true;
                }
            }
        }
        for (const roomName in expansionData.possibleExpansions) {
            if (!expansionData.possibleExpansions[roomName])
                continue;
            if (!Memory.rooms[roomName])
                continue;
            const roomExpansionData = RoomIntel.getExpansionData(roomName);
            if (roomExpansionData == false) {
                expansionData.possibleExpansions[roomName] = false;
            }
            else if (roomExpansionData && roomExpansionData.score) {
                expansionData.possibleExpansions[roomName] = roomExpansionData.score;
            }
        }
    }
    static computeTheoreticalMiningEfficiency(dropoffLocation, room, verbose = false) {
        const roomName = room;
        const roomType = Cartographer.roomType(roomName);
        let cpuCost = 0;
        let creepEnergyCost = 0;
        let spawnTimeCost = 0;
        const upkeepEnergyCost = 0;
        const sourcePositions = RoomIntel.getSourceInfo(roomName);
        if (sourcePositions == undefined) {
            if (verbose)
                log.info(`No memory of outpost room: ${roomName}. Aborting score calculation!`);
            return false;
        }
        const sourcePathLengths = {};
        for (const source of sourcePositions) {
            if (!source.containerPos) {
                log.info(`Can't find container position for source ${source} during efficiency calc`);
                return false;
            }
            const path = Pathing.findShortestPath(dropoffLocation, source.containerPos, { ignoreStructures: true, allowHostile: true });
            if (path.incomplete) {
                log.error(`Couldn't find path to source ${source} for mining efficiency calc`);
                return false;
            }
            sourcePathLengths[source.pos.print] = path.path.length;
        }
        const energyPerSource = roomType == ROOMTYPE_CONTROLLER ? SOURCE_ENERGY_CAPACITY : SOURCE_ENERGY_KEEPER_CAPACITY;
        for (const source of sourcePositions) {
            const setup = roomType == ROOMTYPE_CONTROLLER ? Setups.drones.miners.standard.generateMaxedBody()
                : Setups.drones.miners.sourceKeeper.generateMaxedBody();
            const effectiveCreepUptime = (CREEP_LIFE_TIME - sourcePathLengths[source.pos.print]);
            creepEnergyCost += bodyCost(setup) / effectiveCreepUptime;
            spawnTimeCost += setup.length * CREEP_SPAWN_TIME / effectiveCreepUptime;
            cpuCost += 0.2 + 0.2 * (1 - effectiveCreepUptime / CREEP_LIFE_TIME);
        }
        if (roomType == ROOMTYPE_CONTROLLER) {
            const controller = RoomIntel.getControllerInfo(roomName);
            if (!controller) {
                log.error(`Expansion Efficiency Calc: Can't find controller for room ${roomName}`);
                return false;
            }
            else {
                const setup = Setups.infestors.reserve.generateMaxedBody();
                const controllerPath = Pathing.findShortestPath(dropoffLocation, controller.pos, { ignoreStructures: true, allowHostile: true });
                if (controllerPath.incomplete) {
                    log.error(`Couldn't find path to controller ${controller} for mining efficiency calc`);
                    return false;
                }
                const claimPower = _.filter(setup, (part) => part == CLAIM).length;
                const effectiveLifetimeReservationGeneration = (CREEP_CLAIM_LIFE_TIME - controllerPath.path.length) * claimPower;
                creepEnergyCost += bodyCost(setup) / effectiveLifetimeReservationGeneration;
                spawnTimeCost += setup.length * CREEP_SPAWN_TIME / effectiveLifetimeReservationGeneration;
                cpuCost += 0.2 * CREEP_CLAIM_LIFE_TIME / effectiveLifetimeReservationGeneration;
            }
        }
        else if (roomType == ROOMTYPE_SOURCEKEEPER) {
            const setup = CombatSetups.zerglings.sourceKeeper.generateMaxedBody();
            const skPath = Pathing.findPathToRoom(dropoffLocation, roomName, { ignoreStructures: true, allowHostile: true });
            if (skPath.incomplete) {
                log.error(`Couldn't find path to sk room ${roomName} for mining efficiency calc`);
                return false;
            }
            const effectiveCreepUptime = (CREEP_LIFE_TIME - skPath.path.length);
            creepEnergyCost += bodyCost(setup) / effectiveCreepUptime;
            spawnTimeCost += setup.length * CREEP_SPAWN_TIME / effectiveCreepUptime;
            cpuCost += 0.2 + 0.15 + 0.2 * (1 - effectiveCreepUptime / CREEP_LIFE_TIME);
        }
        for (const source of sourcePositions) {
            const setup = Setups.transporters.default.generateMaxedBody();
            const transporterCarryParts = _.filter(setup, (part) => part == CARRY).length;
            const effectiveEnergyTransportedPerTick = transporterCarryParts * CARRY_CAPACITY
                / (2 * sourcePathLengths[source.pos.print]);
            const transportersPerSource = energyPerSource / ENERGY_REGEN_TIME / effectiveEnergyTransportedPerTick;
            creepEnergyCost += bodyCost(setup) * transportersPerSource / CREEP_LIFE_TIME;
            spawnTimeCost += setup.length * CREEP_SPAWN_TIME * transportersPerSource / CREEP_LIFE_TIME;
            cpuCost += 0.2 * transportersPerSource;
        }
        const netIncome = (energyPerSource * sourcePositions.length / ENERGY_REGEN_TIME) - creepEnergyCost;
        let msg = `(Potential) Outpost ${room} type ${roomType} evaluated for colony at ${dropoffLocation.roomName} with per tick results \n`;
        msg += `Income: ${energyPerSource * sourcePositions.length / ENERGY_REGEN_TIME} Net Income: ${netIncome} Net Energy per CPU: ${netIncome / cpuCost}\n`;
        msg += `Creep Costs: Energy ${creepEnergyCost}, Spawn Time ${spawnTimeCost}, and CPU ${cpuCost} \n`;
        log.alert(msg);
        return netIncome / cpuCost;
    }
    static computeExpansionData(room, verbose = false) {
        if (Game.shard.name == "shard3" && _.keys(Overmind.colonies).length >= SHARD3_MAX_OWNED_ROOMS) {
            log.debug("Already on max rooms, no need to evaluate new expansions");
            return false;
        }
        log.debug(`Computing score for ${room.print}...`);
        if (!room.controller) {
            RoomIntel.setExpansionData(room.name, false);
            return false;
        }
        const possibleOutposts = Cartographer.findRoomsInRange(room.name, 2);
        const outpostSourcePositions = {};
        for (const roomName of possibleOutposts) {
            if (Cartographer.roomType(roomName) == ROOMTYPE_ALLEY
                || Cartographer.roomType(roomName) == ROOMTYPE_CROSSROAD) {
                continue;
            }
            const sourcePositions = RoomIntel.getSourceInfo(roomName);
            if (sourcePositions == undefined) {
                if (verbose)
                    log.info(`No memory of neighbor: ${roomName}. Aborting score calculation!`);
                return false;
            }
            else {
                outpostSourcePositions[roomName] = _.map(sourcePositions, src => src.pos);
            }
        }
        const bunkerLocation = BasePlanner.getBunkerLocation(room, false);
        if (!bunkerLocation) {
            RoomIntel.setExpansionData(room.name, false);
            log.info(`Room ${room.name} is uninhabitable because a bunker can't be built here!`);
            return false;
        }
        if (verbose)
            log.info(`Origin: ${bunkerLocation.print}`);
        const outpostScores = {};
        for (const roomName in outpostSourcePositions) {
            if (verbose)
                log.info(`Analyzing neighbor ${roomName}`);
            const sourcePositions = outpostSourcePositions[roomName];
            let valid = true;
            const roomType = Cartographer.roomType(roomName);
            let energyPerSource = SOURCE_ENERGY_CAPACITY;
            if (roomType == ROOMTYPE_SOURCEKEEPER) {
                energyPerSource = 0.6 * SOURCE_ENERGY_KEEPER_CAPACITY;
            }
            else if (roomType == ROOMTYPE_CORE) {
                energyPerSource = SOURCE_ENERGY_KEEPER_CAPACITY;
            }
            let roomScore = 0;
            for (const position of sourcePositions) {
                const msg = verbose ? `Computing distance from ${bunkerLocation.print} to ${position.print}... ` : '';
                const ret = Pathing.findShortestPath(bunkerLocation, position, { ignoreStructures: true, allowHostile: true });
                if (ret.incomplete || ret.path.length > 100) {
                    if (verbose)
                        log.info(msg + 'incomplete path!');
                    valid = false;
                    break;
                }
                if (verbose)
                    log.info(msg + ret.path.length);
                const offset = 25;
                roomScore += energyPerSource / (ret.path.length + offset);
            }
            if (valid) {
                outpostScores[roomName] = Math.floor(roomScore);
            }
        }
        let totalScore = 0;
        let sourceCount = 0;
        const roomsByScore = _.sortBy(_.keys(outpostScores), roomName => -1 * outpostScores[roomName]);
        for (const roomName of roomsByScore) {
            if (sourceCount > 9)
                break;
            const factor = roomName == room.name ? 2 : 1;
            totalScore += outpostScores[roomName];
            sourceCount += outpostSourcePositions[roomName].length;
        }
        totalScore = Math.floor(totalScore);
        log.info(`Room: ${room.name} Expansionscore: ${totalScore}`);
        const existingExpansionData = RoomIntel.getExpansionData(room.name);
        if (existingExpansionData === false) {
            log.error(`ExpansionEvaluator: shouldn't be here!`);
            return false;
        }
        if (existingExpansionData == undefined || totalScore > existingExpansionData.score) {
            RoomIntel.setExpansionData(room.name, {
                score: totalScore,
                bunkerAnchor: bunkerLocation,
                outposts: outpostScores,
            });
        }
        return true;
    }
};
ExpansionEvaluator = __decorate([
    profile
], ExpansionEvaluator);

function getOverlord(creep) {
    if (creep.memory["O"]) {
        return Overmind.overlords[creep.memory["O"]] || null;
    }
    else {
        return null;
    }
}
function setOverlord(creep, newOverlord) {
    const roleName = creep.memory.role;
    const ref = creep.memory["O"];
    const oldOverlord = ref ? Overmind.overlords[ref] : null;
    if (ref && Overmind.cache.overlords[ref] && Overmind.cache.overlords[ref][roleName]) {
        _.remove(Overmind.cache.overlords[ref][roleName], name => name == creep.name);
    }
    if (newOverlord) {
        creep.memory["C"] = newOverlord.colony.name;
        creep.memory["O"] = newOverlord.ref;
        if (!Overmind.cache.overlords[newOverlord.ref]) {
            Overmind.cache.overlords[newOverlord.ref] = {};
        }
        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {
            Overmind.cache.overlords[newOverlord.ref][roleName] = [];
        }
        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);
    }
    else {
        creep.memory["O"] = null;
    }
    if (oldOverlord)
        oldOverlord.recalculateCreeps();
    if (newOverlord)
        newOverlord.recalculateCreeps();
}
function normalizeAnyZerg(creep) {
    return Overmind.zerg[creep.name] || Overmind.powerZerg[creep.name] || creep;
}
const RANGES$1 = {
    BUILD: 3,
    REPAIR: 3,
    RANGED_HEAL: 3,
    HEAL: 1,
    TRANSFER: 1,
    WITHDRAW: 1,
    HARVEST: 1,
    DROP: 0,
};
let AnyZerg = class AnyZerg {
    constructor(creep, notifyWhenAttacked = true) {
        this.isAnyZerg = true;
        this.creep = creep;
        this.carry = creep.carry;
        this.store = creep.store;
        this.carryCapacity = creep.carryCapacity;
        this.effects = creep.effects;
        this.hits = creep.hits;
        this.hitsMax = creep.hitsMax;
        this.id = creep.id;
        this.memory = creep.memory;
        this.name = creep.name;
        this.pos = creep.pos;
        this.nextPos = creep.pos;
        this.ref = creep.ref;
        this.room = creep.room;
        this.saying = creep.saying;
        this.ticksToLive = creep.ticksToLive;
        if (isPowerCreep(creep)) {
            this.lifetime = POWER_CREEP_LIFE_TIME;
        }
        else {
            this.lifetime = _.filter(creep.body, part => part.type == CLAIM).length > 0
                ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        }
        this.actionLog = {};
        this.blockMovement = false;
        global[this.name] = this;
        if (!notifyWhenAttacked && (this.ticksToLive || 0) >= this.lifetime - (NEW_OVERMIND_INTERVAL + 1)) {
            this.notifyWhenAttacked(notifyWhenAttacked);
        }
    }
    refresh() {
        const creep = Game.creeps[this.name];
        if (creep) {
            this.creep = creep;
            this.pos = creep.pos;
            this.nextPos = creep.pos;
            this.carry = creep.carry;
            this.store = creep.store;
            this.carryCapacity = creep.carryCapacity;
            this.hits = creep.hits;
            this.memory = creep.memory;
            this.room = creep.room;
            this.saying = creep.saying;
            this.ticksToLive = creep.ticksToLive;
            this.actionLog = {};
            this.blockMovement = false;
        }
        else {
            log.debug(`Deleting ${this.print} from global`);
            delete global[this.name];
        }
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.name + ']</a>';
    }
    cancelOrder(methodName) {
        const result = this.creep.cancelOrder(methodName);
        if (result == OK)
            this.actionLog[methodName] = false;
        return result;
    }
    drop(resourceType, amount) {
        const result = this.creep.drop(resourceType, amount);
        if (!this.actionLog.drop)
            this.actionLog.drop = (result == OK);
        return result;
    }
    goDrop(pos, resourceType, amount) {
        if (this.pos.inRangeToPos(pos, RANGES$1.DROP)) {
            return this.drop(resourceType, amount);
        }
        else {
            return this.goTo(pos);
        }
    }
    goPickup(resource) {
        if (this.pos.inRangeToPos(resource.pos, RANGES$1.DROP)) {
            return this.pickup(resource);
        }
        else {
            return this.goTo(resource.pos);
        }
    }
    move(direction, force = false) {
        if (this.blockMovement && !force)
            return ERR_BUSY;
        const result = this.creep.move(direction);
        if (result == OK) {
            if (!this.actionLog.move)
                this.actionLog.move = true;
            this.nextPos = this.pos.getPositionAtDirection(direction);
        }
        return result;
    }
    notifyWhenAttacked(enabled) {
        return this.creep.notifyWhenAttacked(enabled);
    }
    pickup(resource) {
        const result = this.creep.pickup(resource);
        if (!this.actionLog.pickup)
            this.actionLog.pickup = (result == OK);
        return result;
    }
    say(message, pub) {
        return this.creep.say(message, pub);
    }
    suicide() {
        return this.creep.suicide();
    }
    transfer(target, resourceType = RESOURCE_ENERGY, amount) {
        let result;
        if (isAnyZerg(target)) {
            result = this.creep.transfer(target.creep, resourceType, amount);
        }
        else {
            result = this.creep.transfer(target, resourceType, amount);
        }
        if (!this.actionLog.transfer)
            this.actionLog.transfer = (result == OK);
        return result;
    }
    transferAll(target, amount) {
        for (const [resourceType, amount] of this.creep.store.contents) {
            if (amount > 0) {
                return this.transfer(target, resourceType);
            }
        }
    }
    goTransfer(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.transfer(target, resourceType, amount) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    withdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        const result = this.creep.withdraw(target, resourceType, amount);
        if (!this.actionLog.withdraw)
            this.actionLog.withdraw = (result == OK);
        return result;
    }
    goWithdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.withdraw(target, resourceType, amount) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    get hasMineralsInCarry() {
        for (const [resourceType, amount] of this.carry.contents) {
            if (resourceType != RESOURCE_ENERGY && amount > 0) {
                return true;
            }
        }
        return false;
    }
    get overlord() {
        return getOverlord(this);
    }
    set overlord(newOverlord) {
        setOverlord(this, newOverlord);
    }
    get colony() {
        if (this.memory["C"] != null) {
            return Overmind.colonies[this.memory["C"]];
        }
        else {
            return null;
        }
    }
    set colony(newColony) {
        if (newColony != null) {
            this.memory["C"] = newColony.name;
        }
        else {
            this.memory["C"] = null;
        }
    }
    get inColonyRoom() {
        return Overmind.colonyMap[this.room.name] == this.memory["C"];
    }
    get inFriendlyRoom() {
        var room = this.room;
        return (room.isColony || room.isOutpost);
    }
    getCurrentColony() {
        var colony = Overmind.colonies[this.room.name];
        if (colony) {
            return colony;
        }
    }
    towersAvaliable(colony) {
        if (colony && colony.towers.length >= 1) {
            return true;
        }
        return false;
    }
    goTo(destination, options = {}) {
        return Movement.goTo(this, destination, options);
    }
    goToSameRoom(destination, options = {}) {
        return Movement.goToSameRoom(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        return Movement.goToRoom(this, roomName, options);
    }
    inSameRoomAs(target) {
        return this.pos.roomName == target.pos.roomName;
    }
    safelyInRoom(roomName) {
        return this.room.name == roomName && !this.pos.isEdge;
    }
    get inRampart() {
        return this.creep.inRampart;
    }
    get isMoving() {
        const moveData = this.memory._go;
        return (!!moveData && !!moveData.path && moveData.path.length > 1) || this.actionLog[MOVE];
    }
    kite(avoidGoals = this.room.hostiles, options = {}) {
        _.defaults(options, {
            fleeRange: 5
        });
        return Movement.kite(this, avoidGoals, options);
    }
    defaultFleeGoals() {
        let fleeGoals = [];
        fleeGoals = fleeGoals.concat(this.room.hostiles)
            .concat(_.filter(this.room.keeperLairs, lair => (lair.ticksToSpawn || Infinity) < 10));
        return fleeGoals;
    }
    flee(avoidGoals = this.room.fleeDefaults, fleeOptions = {}, moveOptions = {}) {
        var _a;
        if (avoidGoals.length == 0 || this.room.dangerousHostiles.find(creep => creep.pos.getRangeToXY(this.pos.x, this.pos.y) < 6) == undefined) {
            return false;
        }
        if (this.room.controller && this.room.controller.my && this.room.controller.safeMode)
            return false;
        if (((_a = this.colony) === null || _a === void 0 ? void 0 : _a.room.name) == this.room.name && this.hits == this.hitsMax)
            return false;
        const fleeing = Movement.flee(this, avoidGoals, fleeOptions.dropEnergy, moveOptions) != undefined;
        if (fleeing) {
            if (fleeOptions.dropEnergy && this.carry.energy > 0) {
                const nearbyContainers = this.pos.findInRange(this.room.storageUnits, 1);
                if (nearbyContainers.length > 0) {
                    this.transfer(_.first(nearbyContainers), RESOURCE_ENERGY);
                }
                else {
                    this.drop(RESOURCE_ENERGY);
                }
            }
        }
        return fleeing;
    }
    avoidDanger(opts = {}) {
        var _a;
        if ((this.ticksToLive || 0) < 50) {
            return false;
        }
        _.defaults(opts, { timer: 10, dropEnergy: true });
        if (this.memory.avoidDanger) {
            if (this.memory.avoidDanger.timer > 0) {
                this.goToRoom(this.memory.avoidDanger.fallback);
                if (opts.dropEnergy && this.carry.energy > 0) {
                    this.drop(RESOURCE_ENERGY);
                }
                this.memory.avoidDanger.timer--;
                return true;
            }
            else {
                delete this.memory.avoidDanger;
            }
        }
        if (this.room.isSafe && this.hits == this.hitsMax)
            return false;
        if (((_a = this.colony) === null || _a === void 0 ? void 0 : _a.room.name) == this.room.name && this.hits == this.hitsMax)
            return false;
        if (Cartographer.roomType(this.room.name) == ROOMTYPE_SOURCEKEEPER) {
            if (this.hits == this.hitsMax &&
                this.room.dangerousPlayerHostiles.length == 0 &&
                this.room.invaders.length == 0 &&
                !_.any(this.room.fleeDefaults, fleeThing => this.pos.inRangeTo(fleeThing, 5))) {
                return false;
            }
        }
        let fallback;
        const maxLinearRange = 6;
        if (this.colony && Game.map.getRoomLinearDistance(this.room.name, this.colony.name) <= maxLinearRange) {
            fallback = this.colony.name;
        }
        else {
            const nearbyColonies = _.filter(getAllColonies(), colony => Game.map.getRoomLinearDistance(this.room.name, colony.name) <= maxLinearRange);
            const closestColony = minBy(nearbyColonies, colony => {
                const route = Pathing.findRoute(this.room.name, colony.room.name);
                if (route == ERR_NO_PATH) {
                    return false;
                }
                else {
                    return route.length;
                }
            });
            if (!closestColony) {
                log.error(`${this.print} is all alone in a dangerous place and can't find their way home!`);
                return false;
            }
            fallback = closestColony.name;
        }
        this.memory.avoidDanger = {
            start: Game.time,
            timer: opts.timer,
            fallback: fallback,
        };
        if (opts.dropEnergy && this.carry.energy > 0) {
            const containersInRange = this.pos.findInRange(this.room.containers, 1);
            const adjacentContainer = _.first(containersInRange);
            if (adjacentContainer) {
                this.transfer(adjacentContainer, RESOURCE_ENERGY);
            }
        }
        this.goToRoom(fallback);
        return true;
    }
    park(pos = this.pos, maintainDistance = false) {
        return Movement.park(this, pos, maintainDistance);
    }
    moveOffCurrentPos() {
        return Movement.moveOffCurrentPos(this);
    }
    moveOnExit() {
        return Movement.moveOnExit(this);
    }
    moveOffExit(towardPos, avoidSwamp = true) {
        return Movement.moveOffExit(this, towardPos, avoidSwamp);
    }
    sayLoop(messageList, pub) {
        return this.say(messageList[Game.time % messageList.length], pub);
    }
    sayRandom(phrases, pub) {
        return this.say(phrases[Math.floor(Math.random() * phrases.length)], pub);
    }
};
AnyZerg = __decorate([
    profile
], AnyZerg);

var Movement_1;
const CROSSING_PORTAL = 21;
const ERR_CANNOT_PUSH_CREEP = -30;
const REPORT_CPU_THRESHOLD = 750;
const REPORT_SWARM_CPU_THRESHOLD = 1500;
const DEFAULT_STUCK_VALUE = 2;
const STATE_PREV_X = 0;
const STATE_PREV_Y = 1;
const STATE_STUCK = 2;
const STATE_CPU = 3;
const STATE_DEST_X = 4;
const STATE_DEST_Y = 5;
const STATE_DEST_ROOMNAME = 6;
const STATE_CURRENT_X = 7;
const STATE_CURRENT_Y = 8;
const MovePriorities = {
    [Roles.manager]: 0,
    [Roles.queen]: 2,
    [Roles.bunkerDefender]: 3,
    [Roles.melee]: 3,
    powerCreep: 3,
    [Roles.dismantler]: 4,
    [Roles.ranged]: 4,
    [Roles.guardMelee]: 5,
    [Roles.transport]: 8,
    [Roles.worker]: 9,
    default: 10,
};
const getDefaultMoveOptions = () => ({
    pathOpts: {},
});
let Movement = Movement_1 = class Movement {
    static goToSameRoom(creep, destination, opts = {}) {
        const options = { ...opts, pathOpts: { ...opts.pathOpts, maxRooms: 1 } };
        return Movement_1.goTo(creep, destination, options);
    }
    static goTo(creep, destination, opts = {}) {
        if (creep.blockMovement && !opts.force) {
            return ERR_BUSY;
        }
        if (isStandardZerg(creep)) {
            if (creep.spawning) {
                return NO_ACTION;
            }
            if (creep.fatigue > 0) {
                Movement_1.circle(creep.pos, 'aqua', .3);
                return ERR_TIRED;
            }
        }
        if (opts.movingTarget) {
            opts.range = 0;
        }
        _.defaultsDeep(opts, getDefaultMoveOptions());
        const pathOpts = opts.pathOpts;
        if (!creep.memory._go) {
            creep.memory._go = {};
        }
        const moveData = creep.memory._go;
        destination = normalizePos(destination);
        Pathing.updateRoomStatus(creep.room);
        if (opts.range != undefined && destination.rangeToEdge <= opts.range) {
            opts.range = Math.min(Math.abs(destination.rangeToEdge - 1), 0);
        }
        if (opts.range != undefined) {
            pathOpts.range = opts.range;
        }
        if (opts.fleeRange != undefined) {
            pathOpts.fleeRange = opts.fleeRange;
        }
        const rangeToDestination = creep.pos.getRangeTo(destination);
        if (opts.range != undefined && rangeToDestination <= opts.range) {
            if (creep.pos.isEdge) {
                return creep.moveOffExit(destination);
            }
            else {
                delete creep.memory._go;
                return NO_ACTION;
            }
        }
        else if (rangeToDestination <= 1) {
            if (rangeToDestination == 1 && !opts.range) {
                const direction = creep.pos.getDirectionTo(destination);
                if (destination.isWalkable(opts.ignoreCreepsOnDestination)) {
                    return creep.move(direction, !!opts.force);
                }
            }
            else {
                if (!moveData.fleeWait) {
                    delete creep.memory._go;
                }
                return NO_ACTION;
            }
        }
        if (moveData.delay != undefined) {
            if (moveData.delay <= 0) {
                delete moveData.delay;
            }
            else {
                moveData.delay--;
                return OK;
            }
        }
        const state = this.deserializeState(moveData, destination);
        if (this.isStuck(creep, state)) {
            state.stuckCount++;
            this.circle(creep.pos, 'magenta', state.stuckCount * .3);
        }
        else {
            state.stuckCount = 0;
        }
        if (!opts.stuckValue) {
            opts.stuckValue = DEFAULT_STUCK_VALUE;
        }
        if (state.stuckCount >= opts.stuckValue && Math.random() > .5) {
            pathOpts.blockCreeps = true;
            delete moveData.path;
        }
        if (!destination.isEqualTo(state.destination)) {
            if (opts.movingTarget && state.destination.isNearTo(destination)) {
                if (moveData.path) {
                    moveData.path += state.destination.getDirectionTo(destination);
                }
                state.destination = destination;
            }
            else {
                delete moveData.path;
            }
        }
        if (opts.repathChance && Math.random() < opts.repathChance) {
            delete moveData.path;
        }
        let newPath = false;
        if (!moveData.path || moveData.path.length == 0) {
            newPath = true;
            if (isStandardZerg(creep) && creep.spawning) {
                return ERR_BUSY;
            }
            state.destination = destination;
            if (isPowerZerg(creep)) {
                if (pathOpts.terrainCosts) {
                    log.error(`${creep.print}: MoveOptions.terrainCosts not supported by PowerZerg`);
                }
                pathOpts.terrainCosts = { plainCost: 1, swampCost: 1 };
            }
            else if (isStandardZerg(creep)) {
                if (!pathOpts.terrainCosts) {
                    pathOpts.terrainCosts = getTerrainCosts(creep.creep);
                }
            }
            else {
                log.error(`${creep.print} is not Zerg or PowerZerg!`);
            }
            const cpu = Game.cpu.getUsed();
            const ret = Pathing.findPath(creep.pos, destination, pathOpts);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_CPU_THRESHOLD) {
                log.alert(`Movement: heavy cpu use: ${creep.name}, cpu: ${state.cpu}. ` +
                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);
            }
            let color = 'orange';
            if (ret.incomplete) {
                log.debug(`Movement: incomplete path for ${creep.print}! ` +
                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);
                color = 'red';
            }
            this.circle(creep.pos, color);
            moveData.path = Pathing.serializePath(creep.pos, ret.path, color);
            const roomsVisited = _.unique(_.map(ret.path, pos => pos.roomName));
            if (!moveData.roomVisibility) {
                moveData.roomVisibility = {};
            }
            for (const roomName of roomsVisited) {
                moveData.roomVisibility[roomName] = !!Game.rooms[roomName];
            }
            state.stuckCount = 0;
        }
        if (!moveData.path || moveData.path.length == 0) {
            this.serializeState(creep, destination, state, moveData);
            return ERR_NO_PATH;
        }
        if (!opts.noPush) {
            const obstructingCreep = this.findBlockingCreep(creep);
            if (obstructingCreep && this.shouldPush(creep, obstructingCreep)) {
                const pushedCreep = this.pushCreep(creep, obstructingCreep);
                if (!pushedCreep) {
                    this.serializeState(creep, destination, state, moveData);
                    return ERR_CANNOT_PUSH_CREEP;
                }
            }
        }
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        const nextPos = creep.pos.getPositionAtDirection(nextDirection);
        this.serializeState(creep, destination, state, moveData, { x: nextPos.x, y: nextPos.y });
        return creep.move(nextDirection, !!opts.force);
    }
    static visualizeMemorizedPath(creep, color = 'aqua') {
        if (creep.memory._go && creep.memory._go.path) {
            const directions = creep.memory._go.path.substr(1);
            let pos = creep.pos;
            const path = [pos];
            for (const direction of directions) {
                const nextDirection = parseInt(direction, 10);
                const nextPos = pos.getPositionAtDirection(nextDirection);
                path.push(nextPos);
                pos = nextPos;
            }
            const positionsGroupedByRoom = _.groupBy(path, pos => pos.roomName);
            for (const roomName in positionsGroupedByRoom) {
                new RoomVisual(roomName).poly(positionsGroupedByRoom[roomName], { stroke: color, lineStyle: 'dotted' });
            }
        }
    }
    static getPushPriority(creep) {
        if (!creep.memory)
            return MovePriorities.default;
        if (creep.memory._go && creep.memory._go.priority) {
            return creep.memory._go.priority;
        }
        if (isPowerZerg(creep)) {
            return MovePriorities.powerCreep;
        }
        if (creep.memory.role in MovePriorities) {
            return MovePriorities[creep.memory.role];
        }
        return MovePriorities.default;
    }
    static shouldPush(pusher, pushee) {
        if (this.getPushPriority(pusher) < this.getPushPriority(pushee)) {
            return true;
        }
        else if (this.getPushPriority(pushee) == 0) {
            return false;
        }
        else {
            pushee = normalizeAnyZerg(pushee);
            if (isAnyZerg(pushee)) {
                if (isStandardZerg(pushee)) {
                    if (pushee.task && pushee.task.isWorking) {
                        const targetPos = pushee.task.targetPos;
                        const targetRange = pushee.task.settings.targetRange;
                        return _.filter(pushee.pos.availableNeighbors().concat(pusher.pos), pos => pos.getRangeTo(targetPos) <= targetRange).length > 0;
                    }
                    else if (!pushee.isMoving) {
                        return true;
                    }
                }
                else if (isPowerZerg(pushee)) {
                    if (!pushee.isMoving) {
                        return true;
                    }
                }
            }
            else {
                return pushee.my;
            }
        }
        return false;
    }
    static getPushDirection(pusher, pushee) {
        const possiblePositions = pushee.pos.availableNeighbors();
        pushee = normalizeAnyZerg(pushee);
        if (isStandardZerg(pushee)) {
            let preferredPositions = [];
            if (pushee.task && pushee.task.isWorking) {
                const targetPos = pushee.task.targetPos;
                const targetRange = pushee.task.settings.targetRange;
                preferredPositions = _.filter(possiblePositions, pos => pos.getRangeTo(targetPos) <= targetRange);
            }
            if (preferredPositions[0]) {
                return pushee.pos.getDirectionTo(preferredPositions[0]);
            }
        }
        else {
            log.debug(`${pushee.name}@${pushee.pos.print} is not Zerg! (Why?)`);
        }
        return pushee.pos.getDirectionTo(pusher);
    }
    static findBlockingCreep(creep) {
        const nextDir = Pathing.nextDirectionInPath(creep);
        if (nextDir == undefined)
            return;
        const nextPos = Pathing.positionAtDirection(creep.pos, nextDir);
        if (!nextPos)
            return;
        return nextPos.room ? nextPos.lookFor(LOOK_CREEPS)[0] : undefined;
    }
    static pushCreep(creep, otherCreep) {
        if (!otherCreep.memory)
            return false;
        otherCreep = normalizeAnyZerg(otherCreep);
        const pushDirection = this.getPushDirection(creep, otherCreep);
        const otherData = otherCreep.memory._go;
        const outcome = otherCreep.move(pushDirection);
        const otherNextPos = otherCreep.pos.getPositionAtDirection(pushDirection);
        if (isStandardZerg(otherCreep)) {
            if (outcome == OK) {
                if (otherData && otherData.path && !otherCreep.blockMovement) {
                    otherData.path = Pathing.oppositeDirection(pushDirection) + otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                otherCreep.blockMovement = true;
                return true;
            }
            else {
                return false;
            }
        }
        else {
            log.warning(`${otherCreep.name}@${otherCreep.pos.print} is not Zerg! (Why?)`);
            if (outcome == OK) {
                if (otherData && otherData.path) {
                    otherData.path = Pathing.oppositeDirection(pushDirection) + otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                return true;
            }
            else {
                return false;
            }
        }
    }
    static vacatePos(pos, suicide = false) {
        const nearbyCreeps = _.compact(_.map(pos.findInRange(FIND_MY_CREEPS, 2), creep => Overmind.zerg[creep.name]));
        _.forEach(nearbyCreeps, creep => creep.blockMovement = true);
        const creep = pos.lookFor(LOOK_CREEPS)[0];
        if (!creep)
            return true;
        const blockingCreep = Overmind.zerg[creep.name];
        if (!blockingCreep)
            return true;
        const moved = !!this.recursivePush(blockingCreep);
        if (moved) {
            log.debug(`Moved creep ${blockingCreep.name} off of ${blockingCreep.pos.print}.`);
            return true;
        }
        else {
            if (suicide) {
                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}! ` +
                    `Suiciding creep! (RIP)`);
                blockingCreep.suicide();
                return true;
            }
            else {
                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}!`);
                return false;
            }
        }
    }
    static recursivePush(creep, excludePos = []) {
        const creepPos = creep.pos;
        let movePos = _.find(creepPos.availableNeighbors(), neighbor => !_.any(excludePos, pos => pos.isEqualTo(neighbor)));
        if (movePos) {
            log.debug(`Moving ${creep.name} to ${JSON.stringify(movePos)}`);
            this.goTo(creep, movePos, { force: true });
            creep.blockMovement = true;
            return creepPos;
        }
        else {
            const availablePositions = _.filter(creepPos.availableNeighbors(true), neighbor => !_.any(excludePos, pos => pos.isEqualTo(neighbor)));
            for (const otherPos of availablePositions) {
                const otherCreep = otherPos.lookFor(LOOK_CREEPS)[0];
                if (!otherCreep)
                    continue;
                const otherZerg = Overmind.zerg[otherCreep.name];
                if (!otherZerg)
                    continue;
                movePos = this.recursivePush(otherZerg, excludePos.concat(creepPos));
                if (movePos) {
                    this.goTo(creep, movePos, { range: 0, force: true });
                    creep.blockMovement = true;
                    return creepPos;
                }
            }
        }
    }
    static goToRoom(creep, roomName, options = {}) {
        options.range = 20;
        return this.goTo(creep, new RoomPosition(25, 25, roomName), options);
    }
    static goToRoom_swarm(swarm, roomName, options = {}) {
        options.range = 24 - Math.max(swarm.width, swarm.height);
        return this.swarmMove(swarm, new RoomPosition(25, 25, roomName), options);
    }
    static park(creep, pos = creep.pos, maintainDistance = false) {
        const road = creep.pos.lookForStructure(STRUCTURE_ROAD);
        if (!road)
            return OK;
        if (!maintainDistance && creep.colony && creep.colony.bunker && insideBunkerBounds(creep.pos, creep.colony)) {
            return this.goTo(creep, creep.colony.controller.pos);
        }
        let positions = _.sortBy(creep.pos.availableNeighbors(), p => p.getRangeTo(pos));
        if (maintainDistance) {
            const currentRange = creep.pos.getRangeTo(pos);
            positions = _.filter(positions, p => p.getRangeTo(pos) <= currentRange);
        }
        let swampPosition;
        for (const position of positions) {
            if (position.lookForStructure(STRUCTURE_ROAD))
                continue;
            const terrain = position.lookFor(LOOK_TERRAIN)[0];
            if (terrain === 'swamp') {
                swampPosition = position;
            }
            else {
                return creep.move(creep.pos.getDirectionTo(position));
            }
        }
        if (swampPosition) {
            return creep.move(creep.pos.getDirectionTo(swampPosition));
        }
        return this.goTo(creep, pos);
    }
    static moveOffCurrentPos(creep) {
        const destinationPos = _.first(creep.pos.availableNeighbors());
        if (destinationPos) {
            const direction = creep.pos.getDirectionTo(destinationPos);
            return creep.move(direction);
        }
        else {
            log.debug(`${creep.print} can't move off current pos!`);
        }
    }
    static moveOnExit(creep) {
        if (creep.pos.rangeToEdge > 0) {
            if (isStandardZerg(creep) && creep.fatigue > 0) {
                return;
            }
            const directions = [1, 3, 5, 7, 2, 4, 6, 8];
            for (const direction of directions) {
                const position = creep.pos.getPositionAtDirection(direction);
                const terrain = position.lookFor(LOOK_TERRAIN)[0];
                if (terrain != 'wall' && position.rangeToEdge == 0) {
                    return creep.move(direction);
                }
            }
            log.warning(`moveOnExit() assumes nearby exit tile, position: ${creep.pos}`);
            return ERR_NO_PATH;
        }
    }
    static moveOffExit(creep, towardPos, avoidSwamp = true) {
        if (!creep.pos.isEdge) {
            return NO_ACTION;
        }
        const terrain = creep.room.getTerrain();
        const pos = minBy(creep.pos.neighbors, pos => {
            if (pos.isEdge || !pos.isWalkable()) {
                return false;
            }
            let penalty = 0;
            if (avoidSwamp && terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP) {
                penalty += 10;
            }
            if (towardPos) {
                penalty += pos.getRangeTo(towardPos);
            }
            return penalty;
        });
        if (pos) {
            const direction = creep.pos.getDirectionTo(pos);
            creep.debug(`moving off exit toward ${pos.print}, direction ${direction}`);
            return creep.move(direction);
        }
        else {
            log.warning(`${creep.print}: cannot move off exit!`);
            return ERR_NO_PATH;
        }
    }
    static pairwiseMove(leader, follower, target, opts = {}, allowedRange = 1) {
        let outcome;
        if (leader.room != follower.room) {
            if (leader.pos.rangeToEdge == 0) {
                outcome = leader.goToSameRoom(target);
            }
            follower.goTo(leader);
            return outcome;
        }
        const range = leader.pos.getRangeTo(follower);
        if (range > allowedRange) {
            if (follower.pos.isEdge && follower.room == leader.room) {
                const goToPos = _.find(follower.pos.availableNeighbors(), pos => pos.isNearTo(leader));
                if (goToPos) {
                    follower.goTo(goToPos);
                }
                else {
                    follower.goTo(leader, { pathOpts: { blockCreeps: true } });
                }
            }
            else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        else if (isStandardZerg(follower) && follower.fatigue == 0) {
            outcome = leader.goTo(target, opts);
            if (range == 1) {
                follower.move(follower.pos.getDirectionTo(leader));
            }
            else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        return outcome;
    }
    static swarmMove(swarm, destination, opts = {}) {
        if (swarm.fatigue > 0) {
            Movement_1.circle(swarm.anchor, 'aqua', .3);
            console.log('tired');
            return ERR_TIRED;
        }
        _.defaults(opts, {
            range: Math.max(swarm.width, swarm.height),
            blockCreeps: false,
            exitCost: 10,
        });
        destination = normalizePos(destination);
        if (!swarm.memory._go) {
            swarm.memory._go = {};
        }
        const moveData = swarm.memory._go;
        if (opts.range != undefined && swarm.minRangeTo(destination) <= opts.range &&
            swarm.maxRangeTo(destination) <= opts.range + Math.max(swarm.width, swarm.height)) {
            delete swarm.memory._go;
            console.log('no action');
            return NO_ACTION;
        }
        const state = this.deserializeState(moveData, destination);
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(swarm.anchor, state.lastCoord)) {
                stuck = true;
            }
            else if (isExit(swarm.anchor) && isExit(state.lastCoord)) {
                stuck = true;
            }
        }
        if (stuck) {
            state.stuckCount++;
            this.circle(swarm.anchor, 'magenta', state.stuckCount * .3);
        }
        else {
            state.stuckCount = 0;
        }
        if (!opts.stuckValue) {
            opts.stuckValue = DEFAULT_STUCK_VALUE;
        }
        if (state.stuckCount >= opts.stuckValue && Math.random() > .5) {
            opts.blockCreeps = true;
            delete moveData.path;
        }
        if (!destination.isEqualTo(state.destination)) {
            delete moveData.path;
        }
        if (opts.repathChance && Math.random() < opts.repathChance) {
            delete moveData.path;
        }
        let newPath = false;
        if (!moveData.path) {
            newPath = true;
            state.destination = destination;
            const cpu = Game.cpu.getUsed();
            const ret = Pathing.findSwarmPath(swarm.anchor, destination, swarm.width, swarm.height, opts);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_SWARM_CPU_THRESHOLD) {
                log.alert(`Movement: heavy cpu use for swarm with ${_.first(swarm.creeps).print}, cpu: ${state.cpu}. ` +
                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);
            }
            let color = 'orange';
            if (ret.incomplete) {
                log.debug(`Movement: incomplete path for swarm with ${_.first(swarm.creeps).print}! ` +
                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);
                color = 'red';
            }
            this.circle(swarm.anchor, color);
            moveData.path = Pathing.serializePath(swarm.anchor, ret.path, color);
            state.stuckCount = 0;
        }
        this.circle(destination, 'orange');
        moveData.state = [swarm.anchor.x, swarm.anchor.y, state.stuckCount, state.cpu, destination.x, destination.y,
            destination.roomName];
        if (!moveData.path || moveData.path.length == 0) {
            console.log(`No path from ${swarm.anchor.print} to ${destination.print}!`);
            return ERR_NO_PATH;
        }
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        return swarm.move(nextDirection);
    }
    static combatMoveCallbackModifier(room, matrix, approach, avoid, options) {
        if (!options.allowExit) {
            MatrixLib.blockExits(matrix);
        }
        _.forEach(avoid, avoidThis => {
            let cost;
            let x, y;
            for (let dx = -avoidThis.range; dx <= avoidThis.range; dx++) {
                for (let dy = -avoidThis.range; dy <= avoidThis.range; dy++) {
                    x = avoidThis.pos.x + dx;
                    y = avoidThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) {
                        cost = Math.min(cost + options.avoidPenalty, 0xfe);
                        matrix.set(x, y, cost);
                    }
                }
            }
        });
        _.forEach(approach, approachThis => {
            let cost;
            let x, y;
            for (let dx = -approachThis.range; dx <= approachThis.range; dx++) {
                for (let dy = -approachThis.range; dy <= approachThis.range; dy++) {
                    x = approachThis.pos.x + dx;
                    y = approachThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) {
                        cost = Math.max(cost - options.approachBonus, 1);
                        matrix.set(x, y, cost);
                    }
                }
            }
        });
        if (options.preferRamparts) {
            MatrixLib.setWalkableRampartCostToOne(matrix, room);
        }
        return matrix;
    }
    static swarmCombatMove(swarm, approach, avoid, options = {}) {
        _.defaults(options, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
            blockMyCreeps: true,
        });
        const debug = false;
        const callback = (roomName) => {
            const room = swarm.roomsByName[roomName];
            const matrixOpts = {
                explicitTerrainCosts: true,
                swarmWidth: swarm.width,
                swarmHeight: swarm.height,
                blockExits: !options.allowExit,
            };
            let matrix = MatrixLib.getMatrix(roomName, matrixOpts).clone();
            if (room) {
                matrix = matrix.clone();
                if (options.blockMyCreeps) {
                    const otherCreeps = _.filter(room.creeps, creep => !_.any(swarm.creeps, c => c.name == creep.name));
                    MatrixLib.blockAfterMaxPooling(matrix, otherCreeps, swarm.width, swarm.height);
                }
                Movement_1.combatMoveCallbackModifier(room, matrix, approach, avoid, options);
            }
            if (options.displayCostMatrix) {
                Visualizer.displayCostMatrix(matrix, roomName);
            }
            return matrix;
        };
        let outcome = NO_ACTION;
        if (avoid.length > 0) {
            const size = Math.max(swarm.width, swarm.height);
            if (_.any(avoid, goal => swarm.minRangeTo(goal) <= goal.range)) {
                const allAvoid = _.flatten(_.map(avoid, goal => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), pos => ({
                    pos: pos,
                    range: goal.range
                }))));
                if (options.displayAvoid) {
                    const room = swarm.rooms[0];
                    for (const avoid of allAvoid) {
                        const { x, y } = avoid.pos;
                        room.visual.text(avoid.range.toString(), x, y, { color: 'ff0099' });
                    }
                }
                const avoidRet = PathFinder.search(swarm.anchor, allAvoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: options.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    if (debug)
                        Pathing.serializePath(swarm.anchor, avoidRet.path, 'magenta');
                    outcome = swarm.move(swarm.anchor.getDirectionTo(avoidRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        if (approach.length > 0) {
            if (!_.any(approach, goal => swarm.minRangeTo(goal) <= goal.range)) {
                const allApproach = _.flatten(_.map(approach, goal => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), pos => ({
                    pos: pos,
                    range: goal.range
                }))));
                const approachRet = PathFinder.search(swarm.anchor, allApproach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    if (debug)
                        Pathing.serializePath(swarm.anchor, approachRet.path, 'cyan');
                    outcome = swarm.move(swarm.anchor.getDirectionTo(approachRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static combatMove(creep, approach, avoid, opts = {}) {
        _.defaults(opts, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
            requireRamparts: false,
            blockMyCreeps: true,
            blockHostileCreeps: false,
            blockAlliedCreeps: false,
        });
        const debug = false;
        const callback = (roomName) => {
            const matrixOpts = {
                blockExits: !opts.allowExit,
            };
            let matrix = MatrixLib.getMatrix(roomName, matrixOpts);
            if (roomName == creep.room.name) {
                matrix = matrix.clone();
                if (opts.blockMyCreeps) {
                    MatrixLib.blockMyCreeps(matrix, creep.room);
                }
                if (opts.blockHostileCreeps) {
                    MatrixLib.blockHostileCreeps(matrix, creep.room);
                }
                if (opts.blockAlliedCreeps) {
                    MatrixLib.blockAlliedCreeps(matrix, creep.room);
                }
                if (opts.preferRamparts) {
                    MatrixLib.setWalkableRampartCostToOne(matrix, creep.room);
                }
                if (opts.requireRamparts) {
                    MatrixLib.blockNonRamparts(matrix, creep.room);
                }
                Movement_1.combatMoveCallbackModifier(creep.room, matrix, approach, avoid, opts);
                if (opts.displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            }
            else {
                if (Memory.rooms[roomName] && Memory.rooms[roomName]["a"])
                    return false;
                return matrix;
            }
        };
        let outcome = NO_ACTION;
        if (avoid.length > 0) {
            if (_.any(avoid, goal => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))
                && !creep.inRampart) {
                const avoidRet = PathFinder.search(creep.pos, avoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: opts.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    if (debug)
                        Pathing.serializePath(creep.pos, avoidRet.path, 'magenta');
                    outcome = creep.move(creep.pos.getDirectionTo(avoidRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        if (approach.length > 0) {
            if (!_.any(approach, goal => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))) {
                const approachRet = PathFinder.search(creep.pos, approach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    if (debug)
                        Pathing.serializePath(creep.pos, approachRet.path, 'cyan');
                    outcome = creep.move(creep.pos.getDirectionTo(approachRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        if ((opts.preferRamparts || opts.requireRamparts) && !creep.inRampart && approach.length > 0) {
            const openRamparts = _.filter(creep.room.walkableRamparts, rampart => _.any(approach, g => rampart.pos.inRangeToXY(g.pos.x, g.pos.y, g.range))
                && rampart.pos.isWalkable());
            if (openRamparts.length > 0) {
                const ret = PathFinder.search(creep.pos, _.map(openRamparts, r => ({ pos: r.pos, range: 0 })), {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (ret.path.length > 0) {
                    if (debug)
                        Pathing.serializePath(creep.pos, ret.path, 'green');
                    outcome = creep.move(creep.pos.getDirectionTo(ret.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static invasionMoveCallbackModifier(room, matrix) {
        MatrixLib.blockExits(matrix);
        for (const hostile of room.invaders) {
            if (hostile.getActiveBodyparts(RANGED_ATTACK) > 1) {
                MatrixLib.setInRange(matrix, hostile, 3, 1, true);
            }
            else if (hostile.getActiveBodyparts(ATTACK) > 1) {
                MatrixLib.setInRange(matrix, hostile, 1, 1, true);
            }
        }
        for (const keeper of room.sourceKeepers) {
            MatrixLib.setInRange(matrix, keeper, 3, 10, true);
        }
        for (const lair of room.keeperLairs) {
            if ((lair.ticksToSpawn || Infinity) < 25) {
                MatrixLib.setInRange(matrix, lair, 5, 5, true);
            }
        }
        return matrix;
    }
    static invasionMove(creep, destination, opts = {}) {
        _.defaults(opts, getDefaultMoveOptions());
        const dest = normalizePos(destination);
        if (creep.pos.getRangeTo(dest) > 8) {
            opts.repathChance = .1;
            opts.movingTarget = true;
        }
        if (creep.room.name == dest.roomName) {
            _.defaults(opts.pathOpts, {
                maxRooms: 1,
                modifyRoomCallback: Movement_1.invasionMoveCallbackModifier,
            });
        }
        return creep.goTo(dest, opts);
    }
    static kite(creep, avoidGoals, options = {}) {
        _.defaults(options, {
            fleeRange: 5,
            terrainCosts: isPowerZerg(creep) ? { plainCost: 1, swampCost: 1 } : getTerrainCosts(creep.creep),
        });
        const nextPos = _.first(Pathing.findKitingPath(creep.pos, avoidGoals, options.pathOpts || {}).path);
        if (nextPos) {
            return creep.move(creep.pos.getDirectionTo(nextPos));
        }
    }
    static flee(creep, avoidGoals, dropEnergy = false, opts = {}) {
        if (avoidGoals.length == 0) {
            return;
        }
        const terrainCosts = isPowerZerg(creep) ? { plainCost: 1, swampCost: 1 } : getTerrainCosts(creep.creep);
        const fleeDefaultOpts = { pathOpts: { terrainCosts: terrainCosts } };
        _.defaults(opts, fleeDefaultOpts);
        const fleeRange = opts.fleeRange || (terrainCosts.plainCost > 1 ? 8 : 16);
        if (opts.fleeRange == undefined) {
            opts.fleeRange = fleeRange;
            opts.pathOpts.fleeRange = fleeRange;
        }
        const closest = creep.pos.findClosestByRange(avoidGoals);
        const rangeToClosest = closest ? creep.pos.getRangeTo(closest) : 50;
        if (rangeToClosest > opts.fleeRange) {
            if (!creep.memory._go) {
                return;
            }
            if (creep.pos.isEdge) {
                return creep.moveOffExit();
            }
            const moveData = creep.memory._go;
            if (moveData.fleeWait != undefined) {
                if (moveData.fleeWait <= 0) {
                    delete creep.memory._go;
                    return;
                }
                else {
                    moveData.fleeWait--;
                    return NO_ACTION;
                }
            }
            else {
                return;
            }
        }
        else {
            if (!creep.memory._go) {
                creep.memory._go = {};
            }
            const moveData = creep.memory._go;
            moveData.fleeWait = 2;
            if (moveData.path) {
                if (moveData.path.length > 0) {
                    const nextDirection = parseInt(moveData.path[0], 10);
                    const pos = creep.pos.getPositionAtDirection(nextDirection);
                    if (!pos.isEdge) {
                        const newClosest = pos.findClosestByRange(avoidGoals);
                        if (newClosest && normalizePos(newClosest).getRangeTo(pos) < rangeToClosest) {
                            delete moveData.path;
                        }
                    }
                }
                else {
                    delete moveData.path;
                }
            }
            if (!moveData.path || !moveData.destination) {
                const ret = Pathing.findFleePath(creep.pos, avoidGoals, opts.pathOpts || {});
                if (ret.path.length == 0) {
                    return NO_ACTION;
                }
                moveData.destination = _.last(ret.path);
                moveData.path = Pathing.serializePath(creep.pos, ret.path, 'purple');
            }
            return Movement_1.goTo(creep, derefRoomPosition(moveData.destination), opts);
        }
    }
    static deserializeState(moveData, destination) {
        const state = {};
        if (moveData.state) {
            state.lastCoord = { x: moveData.state[STATE_PREV_X], y: moveData.state[STATE_PREV_Y] };
            state.cpu = moveData.state[STATE_CPU];
            state.stuckCount = moveData.state[STATE_STUCK];
            state.destination = new RoomPosition(moveData.state[STATE_DEST_X], moveData.state[STATE_DEST_Y], moveData.state[STATE_DEST_ROOMNAME]);
            if (moveData.state[STATE_CURRENT_X] && moveData.state[STATE_CURRENT_Y]) {
                state.currentXY = { x: moveData.state[STATE_CURRENT_X], y: moveData.state[STATE_CURRENT_Y] };
            }
        }
        else {
            state.cpu = 0;
            state.destination = destination;
        }
        return state;
    }
    static serializeState(creep, destination, state, moveData, nextCoord) {
        if (nextCoord) {
            moveData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,
                destination.roomName, nextCoord.x, nextCoord.y];
        }
        else {
            moveData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,
                destination.roomName];
        }
    }
    static updateStateNextCoord(moveData, nextCoord) {
        if (moveData.state) {
            if (moveData.state[STATE_CURRENT_X] != undefined && moveData.state[STATE_CURRENT_Y] != undefined) {
                moveData.state[STATE_CURRENT_X] = nextCoord.x;
                moveData.state[STATE_CURRENT_Y] = nextCoord.y;
            }
            else if (moveData.state.length == STATE_CURRENT_X) {
                moveData.state.push(nextCoord.x);
                moveData.state.push(nextCoord.y);
            }
            else {
                log.warning(`Invalid moveData.state length!`);
            }
        }
    }
    static isStuck(creep, state) {
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(creep.pos, state.lastCoord)) {
                stuck = true;
            }
            else if (isExit(creep.pos) && isExit(state.lastCoord)) {
                stuck = true;
            }
        }
        return stuck;
    }
    static circle(pos, color, opacity) {
        return new RoomVisual(pos.roomName).circle(pos, {
            radius: .45, fill: 'transparent', stroke: color, strokeWidth: .15, opacity: opacity
        });
    }
};
Movement = Movement_1 = __decorate([
    profile
], Movement);

function normalizeStandardZerg(creep) {
    return Overmind.zerg[creep.name] || creep;
}
function toCreep(creep) {
    return isStandardZerg(creep) ? creep.creep : creep;
}
const ACTION_PIPELINES = [
    ['harvest', 'attack', 'build', 'repair', 'dismantle', 'attackController', 'rangedHeal', 'heal'],
    ['rangedAttack', 'rangedMassAttack', 'build', 'repair', 'rangedHeal'],
];
const RANGES = {
    BUILD: 3,
    REPAIR: 3,
    TRANSFER: 1,
    WITHDRAW: 1,
    HARVEST: 1,
    DROP: 0,
};
let Zerg = class Zerg extends AnyZerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isStandardZerg = true;
        this.body = creep.body;
        this.fatigue = creep.fatigue;
        this.roleName = creep.memory.role;
        this.spawning = creep.spawning;
        Overmind.zerg[this.name] = this;
    }
    refresh() {
        super.refresh();
        const creep = Game.creeps[this.name];
        if (creep) {
            this.body = creep.body;
            this.fatigue = creep.fatigue;
            this.roleName = creep.memory.role;
            this.spawning = creep.spawning;
            this._task = null;
            this._neededBoosts = undefined;
        }
        else {
            delete Overmind.zerg[this.name];
        }
    }
    get ticksUntilSpawned() {
        if (this.spawning) {
            const spawner = this.pos.lookForStructure(STRUCTURE_SPAWN);
            if (spawner && spawner.spawning) {
                return spawner.spawning.remainingTime;
            }
            else {
                console.log(`Error determining ticks to spawn for ${this.name} @ ${this.pos.print}!`);
            }
        }
    }
    attack(target) {
        const result = this.creep.attack(target);
        if (result == OK) {
            this.actionLog.attack = true;
            if (isCreep(target) || isPowerCreep(target)) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.predictedDamageAmount(this.creep, target, 'attack');
            }
            if (isCreep(target)) {
                if (this.creep.hitsPredicted == undefined)
                    this.creep.hitsPredicted = this.creep.hits;
                this.creep.hitsPredicted -= CombatIntel.predictedDamageAmount(target, this.creep, 'attack');
            }
            if (this.memory.talkative)
                this.say(`💥`);
        }
        return result;
    }
    attackController(controller) {
        const result = this.creep.attackController(controller);
        if (!this.actionLog.attackController)
            this.actionLog.attackController = (result == OK);
        return result;
    }
    build(target) {
        const result = this.creep.build(target);
        if (!this.actionLog.build)
            this.actionLog.build = (result == OK);
        return result;
    }
    goBuild(target) {
        if (this.build(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    claimController(controller) {
        const result = this.creep.claimController(controller);
        if (!this.actionLog.claimController)
            this.actionLog.claimController = (result == OK);
        if (result == OK) {
            Overmind.shouldBuild = true;
        }
        return result;
    }
    dismantle(target) {
        const result = this.creep.dismantle(target);
        if (!this.actionLog.dismantle)
            this.actionLog.dismantle = (result == OK);
        return result;
    }
    goDismantle(target) {
        if (this.dismantle(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    generateSafeMode(target) {
        return this.creep.generateSafeMode(target);
    }
    harvest(source) {
        const result = this.creep.harvest(source);
        if (!this.actionLog.harvest)
            this.actionLog.harvest = (result == OK);
        return result;
    }
    goHarvest(source) {
        if (this.harvest(source) == ERR_NOT_IN_RANGE) {
            this.goTo(source);
        }
    }
    rangedAttack(target) {
        const result = this.creep.rangedAttack(target);
        if (result == OK) {
            this.actionLog.rangedAttack = true;
            if (isCreep(target)) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.predictedDamageAmount(this, target, 'rangedAttack');
            }
            if (this.memory.talkative)
                this.say(`🔫`);
        }
        return result;
    }
    rangedMassAttack() {
        const result = this.creep.rangedMassAttack();
        if (result == OK) {
            this.actionLog.rangedMassAttack = true;
            for (const target of this.pos.findInRange(this.room.hostiles, 3)) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.getMassAttackDamageTo(this, target);
            }
            if (this.memory.talkative)
                this.say(`💣`);
        }
        return result;
    }
    repair(target) {
        const result = this.creep.repair(target);
        if (!this.actionLog.repair)
            this.actionLog.repair = (result == OK);
        return result;
    }
    goRepair(target) {
        if (this.repair(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    reserveController(controller) {
        const result = this.creep.reserveController(controller);
        if (!this.actionLog.reserveController)
            this.actionLog.reserveController = (result == OK);
        return result;
    }
    signController(target, text) {
        const result = this.creep.signController(target, text);
        if (!this.actionLog.signController)
            this.actionLog.signController = (result == OK);
        return result;
    }
    upgradeController(controller) {
        const result = this.creep.upgradeController(controller);
        if (!this.actionLog.upgradeController)
            this.actionLog.upgradeController = (result == OK);
        return result;
    }
    heal(target, rangedHealInstead = false) {
        if (rangedHealInstead && !this.pos.isNearTo(target)) {
            return this.rangedHeal(target);
        }
        const creep = toCreep(target);
        const result = this.creep.heal(creep);
        if (result == OK) {
            this.actionLog.heal = true;
            if (creep.hitsPredicted == undefined)
                creep.hitsPredicted = creep.hits;
            creep.hitsPredicted += CombatIntel.getHealAmount(this);
            if (this.memory.talkative)
                this.say('🚑');
        }
        return result;
    }
    rangedHeal(target) {
        const creep = toCreep(target);
        const result = this.creep.rangedHeal(creep);
        if (result == OK) {
            this.actionLog.rangedHeal = true;
            if (creep.hitsPredicted == undefined)
                creep.hitsPredicted = creep.hits;
            creep.hitsPredicted += CombatIntel.getRangedHealAmount(this);
            if (this.memory.talkative)
                this.say(`💉`);
        }
        return result;
    }
    canExecute(actionName) {
        let conflictingActions = [actionName];
        for (const pipeline of ACTION_PIPELINES) {
            if (pipeline.includes(actionName))
                conflictingActions = conflictingActions.concat(pipeline);
        }
        for (const action of conflictingActions) {
            if (this.actionLog[action]) {
                return false;
            }
        }
        return true;
    }
    getActiveBodyparts(type) {
        return this.creep.getActiveBodyparts(type);
    }
    getBodyparts(partType) {
        return _.filter(this.body, (part) => part.type == partType).length;
    }
    get boostCounts() {
        return _.countBy(this.body, bodyPart => bodyPart.boost);
    }
    get bodypartCounts() {
        return this.creep.bodypartCounts;
    }
    get needsBoosts() {
        if (!this.overlord) {
            return false;
        }
        if ((this.ticksToLive || this.lifetime) < MIN_LIFETIME_FOR_BOOST * this.lifetime) {
            return false;
        }
        return !_.isEmpty(this.getNeededBoosts());
    }
    getNeededBoosts() {
        if (!this._neededBoosts) {
            if (this.memory.needBoosts && this.memory.needBoosts.length > 0) {
                const neededBoosts = {};
                const boostCounts = this.boostCounts;
                const bodyCounts = this.bodypartCounts;
                for (const boost of _.cloneDeep(this.memory.needBoosts)) {
                    const bodypartType = BOOST_PARTS[boost];
                    if (!bodypartType) {
                        log.error(`${boost} is not a valid boost!`);
                    }
                    const numParts = bodyCounts[bodypartType] || 0;
                    const numBoostedParts = boostCounts[boost] || 0;
                    if (numBoostedParts < numParts) {
                        neededBoosts[boost] = LAB_BOOST_MINERAL * (numParts - numBoostedParts);
                    }
                    else {
                        _.pull(this.memory.needBoosts, boost);
                    }
                }
                this._neededBoosts = neededBoosts;
            }
            else {
                this._neededBoosts = {};
            }
        }
        return this._neededBoosts;
    }
    retire() {
        this.say('💀 RIP 💀', true);
        return this.suicide();
    }
    reassign(newOverlord, newRole, invalidateTask = true) {
        this.overlord = newOverlord;
        if (newOverlord && newOverlord.colony && this.colony != newOverlord.colony) {
            this.colony = newOverlord.colony;
        }
        if (newRole) {
            this.roleName = newRole;
            this.memory.role = newRole;
        }
        if (invalidateTask) {
            this.task = null;
        }
    }
    get targetedBy() {
        return this.creep.targetedBy;
    }
    get task() {
        if (!this._task) {
            this._task = this.memory.task ? initializeTask(this.memory.task) : null;
        }
        return this._task;
    }
    set task(task) {
        const oldProtoTask = this.memory.task;
        if (oldProtoTask) {
            const oldRef = oldProtoTask._target.ref;
            if (Overmind.cache.targets[oldRef]) {
                _.remove(Overmind.cache.targets[oldRef], name => name == this.name);
            }
        }
        this.memory.task = task ? task.proto : null;
        if (task) {
            if (task.target) {
                if (!Overmind.cache.targets[task.target.ref]) {
                    Overmind.cache.targets[task.target.ref] = [];
                }
                Overmind.cache.targets[task.target.ref].push(this.name);
            }
            task.creep = this;
        }
        this._task = null;
    }
    get hasValidTask() {
        return !!this.task && this.task.isValid();
    }
    get isIdle() {
        return !this.task || !this.task.isValid();
    }
    debugger() {
        if (this.task && this.task.targetPos) {
            const color = stringToColorHash(this.name);
            Visualizer.circle(this.task.targetPos, color, { radius: 0.45 });
            Movement.visualizeMemorizedPath(this, color);
        }
    }
    run() {
        if (this.memory.debug) {
            this.debugger();
        }
        if (this.task) {
            return this.task.run();
        }
    }
};
Zerg = __decorate([
    profile
], Zerg);

var CombatIntel_1;
const getDefaultCombatIntelMemory = () => ({
    cache: {
        tick: Game.time,
    }
});
let CombatIntel = CombatIntel_1 = class CombatIntel {
    constructor(directive) {
        this.directive = directive;
    }
    get memory() {
        return Mem.wrap(this.directive.memory, 'combatIntel', getDefaultCombatIntelMemory);
    }
    get room() {
        return this.directive.room;
    }
    get colony() {
        return this.directive.colony;
    }
    static singleTowerDamage(range) {
        if (range <= TOWER_OPTIMAL_RANGE) {
            return TOWER_POWER_ATTACK;
        }
        range = Math.min(range, TOWER_FALLOFF_RANGE);
        const falloff = (range - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
        return TOWER_POWER_ATTACK * (1 - TOWER_FALLOFF * falloff);
    }
    static towerDamageAtPos(pos, ignoreEnergy = false) {
        if (pos.room) {
            let expectedDamage = 0;
            for (const tower of pos.room.towers) {
                if ((tower.energy > 0 || ignoreEnergy)) {
                    expectedDamage += this.singleTowerDamage(pos.getRangeTo(tower));
                }
            }
            return expectedDamage;
        }
        else {
            log.warning(`CombatIntel.towerDamageAtPos: room visibility at ${pos.print}!`);
            return 0;
        }
    }
    computeCostMatrix() {
        if (this.room) {
            const matrix = new PathFinder.CostMatrix();
            const barriers = this.room.barriers;
            if (barriers.length > 0) {
                const highestHits = _.last(_.sortBy(barriers, barrier => barrier.hits)).hits;
                for (const barrier of barriers) {
                    matrix.set(barrier.pos.x, barrier.pos.y, Math.ceil(barrier.hits * 10 / highestHits) * 10);
                }
            }
            return matrix;
        }
    }
    static computeCreepDamagePotentialMatrix(room, creeps, startingMatrix) {
        if (room) {
            const cpuUsed = Game.cpu.getUsed();
            const matrix = startingMatrix || new PathFinder.CostMatrix();
            creeps.forEach(creep => {
                const meleeAttack = CombatIntel_1.getAttackPotential(creep);
                const rangedAttack = CombatIntel_1.getRangedAttackPotential(creep);
                if (meleeAttack > 0) {
                    creep.pos.neighbors.forEach(pos => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) + meleeAttack * ATTACK_POWER / 100));
                }
                if (rangedAttack > 0) {
                    creep.pos.getPositionsInRange(3).forEach(pos => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) + rangedAttack * RANGED_ATTACK_POWER / 100));
                }
            });
            Visualizer.displayCostMatrix(matrix, room.name);
            console.log(`Cost matrix cpu used in ${room.print} = ${(Game.cpu.getUsed() - cpuUsed)}`);
            return matrix;
        }
    }
    static computeTotalCreepPotentialMatrix(room, creeps, startingMatrix) {
        if (room) {
            const cpuUsed = Game.cpu.getUsed();
            const matrix = startingMatrix || new PathFinder.CostMatrix();
            creeps.forEach(creep => {
                const meleeAttack = CombatIntel_1.getAttackPotential(creep);
                const rangedAttack = CombatIntel_1.getRangedAttackPotential(creep);
                if (meleeAttack > 0) {
                    creep.pos.neighbors.forEach(pos => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) + meleeAttack * ATTACK_POWER / 100));
                }
                if (rangedAttack > 0) {
                    creep.pos.getPositionsInRange(3).forEach(pos => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) + rangedAttack * RANGED_ATTACK_POWER / 100));
                }
            });
            Visualizer.displayCostMatrix(matrix, room.name);
            console.log(`Cost matrix cpu used in ${room.print} = ${(Game.cpu.getUsed() - cpuUsed)}`);
            return matrix;
        }
    }
    findBestExit(matrix, towers, spawns) {
        if (!this.room) {
            return;
        }
        let bestExit;
        const destination = this.room.spawns[0] || this.room.storage;
        if (!destination) {
            return;
        }
        const ret = Pathing.findPath(this.colony.pos, destination.pos, { range: 1 });
        if (!ret.incomplete) {
            bestExit = _.find(ret.path, p => p.roomName == this.room.name);
        }
        const maxRoomDistance = 8;
        const allowedExits = {};
        if (!bestExit) {
            const exitData = Game.map.describeExits(this.room.name);
            for (const direction in exitData) {
                const roomName = exitData[direction];
                const allowedRooms = Pathing.findRoute(this.colony.name, roomName);
                if (allowedRooms && Object.keys(allowedRooms).length <= maxRoomDistance) {
                    allowedExits[direction] = true;
                }
            }
            if (_.keys(allowedExits).length == 0) {
                return;
            }
        }
        const exitPositions = [];
        const terrain = Game.map.getRoomTerrain(this.room.name);
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (x !== 0 && y !== 0 && x !== 49 && y !== 49) {
                    continue;
                }
                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, 0xff);
                if (bestExit) {
                    continue;
                }
                if (allowedExits['1'] && y === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits['3'] && x === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits['5'] && y === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits['7'] && x === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
            }
        }
        if (!bestExit) {
            bestExit = _(exitPositions)
                .sortBy((p) => -_.sum(towers, (t) => p.getRangeTo(t)))
                .head();
        }
        matrix.set(bestExit.x, bestExit.y, 1);
        return bestExit;
    }
    findSimpleSiegeFallback() {
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, { range: 23 });
        if (ret.incomplete) {
            log.warning(`Incomplete path while finding fallback! Destination: ${this.directive.pos.print}`);
        }
        const firstPosInRoom = _.find(ret.path, pos => pos.roomName == this.directive.pos.roomName);
        if (firstPosInRoom) {
            return CombatIntel_1.getFallbackFrom(firstPosInRoom);
        }
        else {
            return CombatIntel_1.getFallbackFrom(this.directive.pos);
        }
    }
    findSwarmAssemblyPoint(clearance, swarmIndex = 0) {
        const simpleFallback = this.findSimpleSiegeFallback();
        const startPos = Pathing.findPathablePosition(simpleFallback.roomName, clearance);
        let ret = Pathing.findSwarmPath(startPos, this.directive.pos, clearance.width, clearance.height);
        if (ret.incomplete) {
            log.debug(`Incomplete swarm path to find assembly point. Retrying with startpos = fallback.`);
            ret = Pathing.findSwarmPath(simpleFallback, this.directive.pos, clearance.width, clearance.height);
            if (ret.incomplete) {
                log.warning(`No pathable assembly point!`);
            }
        }
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(path, pos => pos.roomName == simpleFallback.roomName &&
            pos.rangeToEdge > 1);
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return acceptablePositions[posIndex] || acceptablePositions[0] || simpleFallback;
    }
    findSwarmAssemblyPointInColony(clearance, swarmIndex = 0) {
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos);
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(path, pos => pos.roomName == this.colony.name && pos.rangeToEdge > 1);
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return acceptablePositions[posIndex] || acceptablePositions[0];
    }
    static getFallbackFrom(pos, fallbackDistance = 2) {
        let { x, y, roomName } = pos;
        const rangesToExit = [[x, 'left'], [49 - x, 'right'], [y, 'top'], [49 - y, 'bottom']];
        const [range, direction] = _.first(_.sortBy(rangesToExit, pair => pair[0]));
        switch (direction) {
            case 'left':
                x = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, -1, 0);
                break;
            case 'right':
                x = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 1, 0);
                break;
            case 'top':
                y = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, -1);
                break;
            case 'bottom':
                y = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, 1);
                break;
            default:
                log.error('Error getting fallback position!');
                break;
        }
        return new RoomPosition(x, y, roomName);
    }
    static cache(creep, key, callback) {
        if (!creep.intel)
            creep.intel = {};
        if (creep.intel[key] == undefined) {
            creep.intel[key] = callback();
        }
        return creep.intel[key];
    }
    static uniqueBoosts(creep) {
        return _.compact(_.unique(_.map(creep.body, bodyPart => bodyPart.boost)));
    }
    static getHealPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'healPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == HEAL) {
                let boost = part.boost;
                if (!boost && countIntendedBoosts && creep.my) {
                    if (creep.memory.needBoosts) {
                        boost = _.find(creep.memory.needBoosts, boost => boost == BOOST_TIERS.heal.T1 ||
                            boost == BOOST_TIERS.heal.T2 ||
                            boost == BOOST_TIERS.heal.T3);
                    }
                }
                if (!boost) {
                    return 1;
                }
                else if (boost == BOOST_TIERS.heal.T1) {
                    return BOOSTS.heal.LO.heal;
                }
                else if (boost == BOOST_TIERS.heal.T2) {
                    return BOOSTS.heal.LHO2.heal;
                }
                else if (boost == BOOST_TIERS.heal.T3) {
                    return BOOSTS.heal.XLHO2.heal;
                }
            }
            return 0;
        }));
    }
    static getHealAmount(creep) {
        return HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    static getRangedHealAmount(creep) {
        return RANGED_HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    static isHealer(zerg) {
        const creep = toCreep(zerg);
        const healParts = _.filter(zerg.body, part => part.type == HEAL).length;
        const attackParts = _.filter(zerg.body, part => part.type == ATTACK).length;
        const rangedAttackParts = _.filter(zerg.body, part => part.type == RANGED_ATTACK).length;
        return healParts > attackParts + rangedAttackParts;
    }
    static getAttackPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'attackPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == ATTACK) {
                let boost = part.boost;
                if (!boost && countIntendedBoosts && creep.my) {
                    if (creep.memory.needBoosts) {
                        boost = _.find(creep.memory.needBoosts, boost => boost == BOOST_TIERS.attack.T1 ||
                            boost == BOOST_TIERS.attack.T2 ||
                            boost == BOOST_TIERS.attack.T3);
                    }
                }
                if (!boost) {
                    return 1;
                }
                else if (boost == BOOST_TIERS.attack.T1) {
                    return BOOSTS.attack.UH.attack;
                }
                else if (boost == BOOST_TIERS.attack.T2) {
                    return BOOSTS.attack.UH2O.attack;
                }
                else if (boost == BOOST_TIERS.attack.T3) {
                    return BOOSTS.attack.XUH2O.attack;
                }
            }
            return 0;
        }));
    }
    static getAttackDamage(creep) {
        return ATTACK_POWER * this.getAttackPotential(toCreep(creep));
    }
    static getRangedAttackPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'rangedAttackPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == RANGED_ATTACK) {
                let boost = part.boost;
                if (!boost && countIntendedBoosts && creep.my) {
                    if (creep.memory.needBoosts) {
                        boost = _.find(creep.memory.needBoosts, boost => boost == BOOST_TIERS.ranged.T1 ||
                            boost == BOOST_TIERS.ranged.T2 ||
                            boost == BOOST_TIERS.ranged.T3);
                    }
                }
                if (!boost) {
                    return 1;
                }
                else if (boost == BOOST_TIERS.ranged.T1) {
                    return BOOSTS.ranged_attack.KO.rangedAttack;
                }
                else if (boost == BOOST_TIERS.ranged.T2) {
                    return BOOSTS.ranged_attack.KHO2.rangedAttack;
                }
                else if (boost == BOOST_TIERS.ranged.T3) {
                    return BOOSTS.ranged_attack.XKHO2.rangedAttack;
                }
            }
            return 0;
        }));
    }
    static getRangedAttackDamage(creep) {
        return RANGED_ATTACK_POWER * this.getRangedAttackPotential(toCreep(creep));
    }
    static getDismantlePotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'dismantlePotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == WORK) {
                let boost = part.boost;
                if (!boost && countIntendedBoosts && creep.my) {
                    if (creep.memory.needBoosts) {
                        boost = _.find(creep.memory.needBoosts, boost => boost == BOOST_TIERS.dismantle.T1 ||
                            boost == BOOST_TIERS.dismantle.T2 ||
                            boost == BOOST_TIERS.dismantle.T3);
                    }
                }
                if (!boost) {
                    return 1;
                }
                else if (boost == BOOST_TIERS.dismantle.T1) {
                    return BOOSTS.work.ZH.dismantle;
                }
                else if (boost == BOOST_TIERS.dismantle.T2) {
                    return BOOSTS.work.ZH2O.dismantle;
                }
                else if (boost == BOOST_TIERS.dismantle.T3) {
                    return BOOSTS.work.XZH2O.dismantle;
                }
            }
            return 0;
        }));
    }
    static getDismantleDamage(creep) {
        return DISMANTLE_POWER * this.getDismantlePotential(toCreep(creep));
    }
    static getRepairPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'repairPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == WORK) {
                let boost = part.boost;
                if (!boost && countIntendedBoosts && creep.my) {
                    if (creep.memory.needBoosts) {
                        boost = _.find(creep.memory.needBoosts, boost => boost == BOOST_TIERS.construct.T1 ||
                            boost == BOOST_TIERS.construct.T2 ||
                            boost == BOOST_TIERS.construct.T3);
                    }
                }
                if (!boost) {
                    return 1;
                }
                else if (boost == BOOST_TIERS.construct.T1) {
                    return BOOSTS.work.LH.repair;
                }
                else if (boost == BOOST_TIERS.construct.T2) {
                    return BOOSTS.work.LH2O.repair;
                }
                else if (boost == BOOST_TIERS.construct.T3) {
                    return BOOSTS.work.XLH2O.repair;
                }
            }
            return 0;
        }));
    }
    static getRepairPower(creep) {
        return REPAIR_POWER * this.getRepairPotential(toCreep(creep));
    }
    static getCarryPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'carryPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == CARRY) {
                let boost = part.boost;
                if (!boost && countIntendedBoosts && creep.my) {
                    if (creep.memory.needBoosts) {
                        boost = _.find(creep.memory.needBoosts, boost => boost == BOOST_TIERS.carry.T1 ||
                            boost == BOOST_TIERS.carry.T2 ||
                            boost == BOOST_TIERS.carry.T3);
                    }
                }
                if (!boost) {
                    return 1;
                }
                else if (boost == BOOST_TIERS.carry.T1) {
                    return BOOSTS.carry.KH.capacity;
                }
                else if (boost == BOOST_TIERS.carry.T2) {
                    return BOOSTS.carry.KH2O.capacity;
                }
                else if (boost == BOOST_TIERS.carry.T3) {
                    return BOOSTS.carry.XKH2O.capacity;
                }
            }
            return 0;
        }));
    }
    static minimumDamageTakenMultiplier(creep) {
        return this.cache(creep, 'minDamageMultiplier', () => _.min(_.map(creep.body, function (part) {
            if (part.type == TOUGH && part.hits > 0) {
                if (part.boost == BOOST_TIERS.tough.T1) {
                    return BOOSTS.tough.GO.damage;
                }
                else if (part.boost == BOOST_TIERS.tough.T2) {
                    return BOOSTS.tough.GHO2.damage;
                }
                else if (part.boost == BOOST_TIERS.tough.T3) {
                    return BOOSTS.tough.XGHO2.damage;
                }
            }
            return 1;
        })));
    }
    static minimumDamageMultiplierForGroup(creeps) {
        return _.min(_.map(creeps, creep => this.minimumDamageTakenMultiplier(creep)));
    }
    static getMassAttackDamageTo(attacker, target) {
        if (isStructure(target) && (!isOwnedStructure(target) || target.my)) {
            return 0;
        }
        const range = attacker.pos.getRangeTo(target.pos);
        let rangedMassAttackPower = 0;
        if (range <= 1) {
            rangedMassAttackPower = 10;
        }
        else if (range == 2) {
            rangedMassAttackPower = 4;
        }
        else if (range == 3) {
            rangedMassAttackPower = 1;
        }
        return rangedMassAttackPower * this.getRangedAttackPotential(isStandardZerg(attacker) ? attacker.creep : attacker);
    }
    static getMassAttackDamage(attacker, targets = attacker.room.hostiles, checkRampart = true) {
        const hostiles = attacker.pos.findInRange(targets, 3);
        return _.sum(hostiles, function (hostile) {
            if (checkRampart && hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                return 0;
            }
            else {
                return CombatIntel_1.getMassAttackDamageTo(attacker, hostile);
            }
        });
    }
    static rating(creep) {
        const c = toCreep(creep);
        return this.cache(c, 'rating', () => {
            let rating = this.getRangedAttackPotential(c) + this.getAttackPotential(c) / 2;
            const healMultiplier = 1 / this.minimumDamageTakenMultiplier(c);
            rating += healMultiplier * this.getHealPotential(c);
            return rating;
        });
    }
    static maxDamageByCreeps(creeps) {
        return _.sum(creeps, creep => ATTACK_POWER * this.getAttackPotential(creep) +
            RANGED_ATTACK_POWER * this.getRangedAttackPotential(creep));
    }
    static maxHealingByCreeps(creeps) {
        return _.sum(creeps, creep => this.getHealAmount(creep));
    }
    static getCombatPotentials(creeps) {
        const attack = _.sum(creeps, creep => this.getAttackPotential(creep));
        const rangedAttack = _.sum(creeps, creep => this.getRangedAttackPotential(creep));
        const heal = _.sum(creeps, creep => this.getHealPotential(creep));
        const dismantle = _.sum(creeps, creep => this.getDismantlePotential(creep));
        return { attack, ranged: rangedAttack, heal, dismantle };
    }
    static getMyCombatPotentials(zergs, countIntendedBoosts = true) {
        const attack = _.sum(zergs, zerg => this.getAttackPotential(zerg.creep, countIntendedBoosts));
        const rangedAttack = _.sum(zergs, zerg => this.getRangedAttackPotential(zerg.creep, countIntendedBoosts));
        const heal = _.sum(zergs, zerg => this.getHealPotential(zerg.creep, countIntendedBoosts));
        const dismantle = _.sum(zergs, zerg => this.getDismantlePotential(zerg.creep, countIntendedBoosts));
        return { attack, ranged: rangedAttack, heal, dismantle };
    }
    static maxDamageAtPos(pos) {
        if (!pos.room) {
            return 0;
        }
        const hostilesInMeleeRange = _.filter(pos.room.dangerousHostiles, creep => pos.getRangeTo(creep) <= 1);
        const meleeDamage = _.sum(hostilesInMeleeRange, hostile => this.getAttackDamage(hostile));
        const hostilesInRange = _.filter(pos.room.dangerousHostiles, creep => pos.getRangeTo(creep) <= 3);
        const rangedDamage = _.sum(hostilesInRange, hostile => this.getRangedAttackDamage(hostile));
        let totalDamage = meleeDamage + rangedDamage;
        if (!pos.room.my) {
            totalDamage += this.towerDamageAtPos(pos) || 0;
        }
        return totalDamage;
    }
    static maxHostileHealingTo(creep) {
        return this.cache(creep, 'maxHostileHealing', () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.hostiles, hostile => hostile.pos.isNearTo(creep));
            const neighborHealing = _.sum(neighbors, neighbor => this.getHealAmount(neighbor));
            const rangedHealers = _.filter(creep.room.hostiles, hostile => hostile.pos.getRangeTo(creep) <= 3 &&
                !neighbors.includes(hostile));
            const rangedHealing = _.sum(rangedHealers, healer => this.getRangedHealAmount(healer));
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    static avgHostileHealingTo(creeps) {
        return _.max(_.map(creeps, creep => CombatIntel_1.maxHostileHealingTo(creep))) / creeps.length;
    }
    static maxFriendlyHealingTo(friendly) {
        const creep = toCreep(friendly);
        return this.cache(creep, 'maxFriendlyHealing', () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.creeps, hostile => hostile.pos.isNearTo(creep));
            const neighborHealing = _.sum(neighbors, neighbor => this.getHealAmount(neighbor));
            const rangedHealers = _.filter(creep.room.creeps, hostile => hostile.pos.getRangeTo(creep) <= 3 &&
                !neighbors.includes(hostile));
            const rangedHealing = _.sum(rangedHealers, healer => this.getHealAmount(healer));
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    static predictedDamageAmount(attacker, target, attackType, useHitsPredicted = true) {
        let grossDamage;
        if (attackType == 'attack') {
            grossDamage = this.getAttackDamage(attacker);
        }
        else if (attackType == 'rangedAttack') {
            grossDamage = this.getRangedAttackDamage(attacker);
        }
        else {
            grossDamage = this.getMassAttackDamageTo(attacker, target);
        }
        let toughHits;
        let damageMultiplier;
        if (isCreep(target)) {
            if (useHitsPredicted) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                const nonToughHits = _.sum(target.body, part => part.type == TOUGH ? 0 : part.hits);
                toughHits = Math.min(target.hitsPredicted - nonToughHits, 0);
            }
            else {
                toughHits = 100 * target.getActiveBodyparts(TOUGH);
            }
            damageMultiplier = this.minimumDamageTakenMultiplier(target);
        }
        else {
            toughHits = 0;
            damageMultiplier = 1;
        }
        if (grossDamage * damageMultiplier < toughHits) {
            return grossDamage * damageMultiplier;
        }
        else {
            grossDamage -= toughHits / damageMultiplier;
            return toughHits + grossDamage;
        }
    }
    static isApproaching(approacher, toPos) {
        const previousPos = RoomIntel.getPreviousPos(approacher);
        const previousRange = toPos.getRangeTo(previousPos);
        const currentRange = toPos.getRangeTo(approacher.pos);
        return currentRange < previousRange;
    }
    static isRetreating(retreater, fromPos) {
        const previousPos = RoomIntel.getPreviousPos(retreater);
        const previousRange = fromPos.getRangeTo(previousPos);
        const currentRange = fromPos.getRangeTo(retreater.pos);
        return currentRange > previousRange;
    }
    static isEdgeDancing(creep, reentryThreshold = 3) {
        return false;
    }
    static getPositionsNearEnemies(hostiles, range = 0) {
        return _.unique(_.flatten(_.map(hostiles, hostile => hostile.pos.getPositionsInRange(range, false, true))));
    }
};
CombatIntel = CombatIntel_1 = __decorate([
    profile
], CombatIntel);
global.CombatIntel = CombatIntel;

var RoomIntel_1;
const RECACHE_TIME = 5000;
const OWNED_RECACHE_TIME = 1000;
const ROOM_CREEP_HISTORY_TICKS = 25;
const defaultRoomIntelMemory = {
    portalRooms: [],
};
let RoomIntel = RoomIntel_1 = class RoomIntel {
    constructor() {
        _.defaultsDeep(Memory.roomIntel, defaultRoomIntelMemory);
    }
    static get memory() {
        return Memory.roomIntel;
    }
    static markVisible(room) {
        room.memory["T"] = Game.time;
    }
    static lastVisible(roomName) {
        if (Memory.rooms[roomName]) {
            return Memory.rooms[roomName]["T"] || -100;
        }
        else {
            return -100;
        }
    }
    static getExpansionData(roomName) {
        if (!Memory.rooms[roomName] || Memory.rooms[roomName]["e"] === undefined) {
            return undefined;
        }
        const data = Memory.rooms[roomName]["e"];
        if (data === 0) {
            return false;
        }
        return {
            score: data["s"],
            bunkerAnchor: unpackCoordAsPos(data["a"], roomName),
            outposts: data["o"]
        };
    }
    static setExpansionData(roomName, data) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        if (data === false) {
            Memory.rooms[roomName]["e"] = 0;
        }
        else {
            Memory.rooms[roomName]["e"] = {
                ["s"]: data.score,
                ["a"]: packCoord(data.bunkerAnchor),
                ["o"]: data.outposts,
            };
        }
    }
    static getPortalInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["pr"]) {
            return [];
        }
        const localPortals = _.filter(Memory.rooms[roomName]["pr"], savedPortal => typeof savedPortal.dest == 'string');
        const nonExpiredPortals = _.filter(localPortals, portal => Game.time < portal["X"]);
        return _.map(nonExpiredPortals, savedPortal => {
            const pos = unpackCoordAsPos(savedPortal.c, roomName);
            const destinationPos = unpackPos(savedPortal.dest);
            const expiration = savedPortal["X"];
            return { pos: pos, destination: destinationPos, expiration: expiration };
        });
    }
    static getSourceInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["s"]) {
            return;
        }
        return _.map(Memory.rooms[roomName]["s"], savedSource => ({
            pos: unpackCoordAsPos(savedSource.c, roomName),
            containerPos: savedSource.cn ? unpackCoordAsPos(savedSource.cn, roomName) : undefined
        }));
    }
    static getKeeperLairInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["k"]) {
            return;
        }
        return _.map(Memory.rooms[roomName]["k"], savedLair => ({
            pos: unpackCoordAsPos(savedLair.c, roomName),
            chillPos: savedLair.cp ? unpackCoordAsPos(savedLair.cp, roomName) : undefined
        }));
    }
    static getControllerInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["c"]) {
            return;
        }
        const ctlr = Memory.rooms[roomName]["c"];
        return {
            pos: unpackCoordAsPos(ctlr.c, roomName),
            level: ctlr["l"],
            owner: ctlr["o"],
            reservation: ctlr["r"] ? {
                username: ctlr["r"]["u"],
                ticksToEnd: ctlr["r"]["t"],
            } : undefined,
            safemode: ctlr["s"],
            safemodeAvailable: ctlr["sa"],
            safemodeCooldown: ctlr["sc"],
            progress: ctlr["p"],
            progressTotal: ctlr["pt"],
        };
    }
    static getImportantStructureInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["i"]) {
            return;
        }
        const data = Memory.rooms[roomName]["i"];
        return {
            storagePos: data["s"] ?
                unpackCoordAsPos(data["s"], roomName) : undefined,
            terminalPos: data["e"] ?
                unpackCoordAsPos(data["e"], roomName) : undefined,
            towerPositions: unpackCoordListAsPosList(data["t"], roomName),
            spawnPositions: unpackCoordListAsPosList(data["sp"], roomName),
            wallPositions: unpackCoordListAsPosList(data["w"], roomName),
            rampartPositions: unpackCoordListAsPosList(data["r"], roomName),
        };
    }
    static getAllRoomObjectInfo(roomName) {
        const mem = Memory.rooms[roomName];
        if (mem) {
            const savedController = mem["c"];
            const savedSources = mem["s"] || [];
            const savedMineral = mem["m"];
            const savedSkLairs = mem["k"] || [];
            const savedImportantStructures = mem["i"];
            const returnObject = {
                controller: this.getControllerInfo(roomName),
                portals: this.getPortalInfo(roomName),
                sources: _.map(savedSources, src => src.cn ? { pos: unpackCoordAsPos(src.c, roomName), containerPos: unpackCoordAsPos(src.cn, roomName) }
                    : { pos: unpackCoordAsPos(src.c, roomName) }),
                mineral: savedMineral ? {
                    pos: unpackCoordAsPos(savedMineral.c, roomName),
                    mineralType: savedMineral["t"],
                    density: savedMineral["d"],
                } : undefined,
                skLairs: _.map(savedSkLairs, lair => ({ pos: unpackCoordAsPos(lair.c, roomName) })),
                importantStructures: this.getImportantStructureInfo(roomName)
            };
            return returnObject;
        }
    }
    static recordPermanentObjects(room) {
        room.memory["T"] = Game.time;
        if (room.sources.length > 0) {
            room.memory["s"] = _.map(room.sources, source => {
                const coord = packCoord(source.pos);
                const container = source.pos.findClosestByLimitedRange(room.containers, 2);
                return container ? { c: coord, cn: packCoord(container.pos) } : { c: coord };
            });
        }
        else {
            delete room.memory["s"];
        }
        if (room.controller) {
            room.memory["c"] = {
                c: packCoord(room.controller.pos),
                ["l"]: room.controller.level,
                ["o"]: room.controller.owner ? room.controller.owner.username : undefined,
                ["r"]: room.controller.reservation ?
                    {
                        ["u"]: room.controller.reservation.username,
                        ["t"]: room.controller.reservation.ticksToEnd,
                    } : undefined,
                ["s"]: room.controller.safeMode,
                ["sa"]: room.controller.safeModeAvailable,
                ["sc"]: room.controller.safeModeCooldown,
                ["p"]: room.controller.progress,
                ["pt"]: room.controller.progressTotal
            };
        }
        else {
            delete room.memory["c"];
        }
        if (room.mineral) {
            room.memory["m"] = {
                c: packCoord(room.mineral.pos),
                ["d"]: room.mineral.density,
                ["t"]: room.mineral.mineralType
            };
        }
        else {
            delete room.memory["m"];
        }
        if (room.keeperLairs.length > 0) {
            room.memory["k"] = _.map(room.keeperLairs, lair => {
                const keeperTarget = _.find(_.compact([...room.sources, room.mineral]), thing => thing.pos.getRangeTo(lair.pos) <= 5);
                let chillPos;
                if (keeperTarget) {
                    chillPos = lair.pos.findClosestByPath(keeperTarget.pos.neighbors) || undefined;
                }
                return chillPos ? { c: packCoord(lair.pos), cp: packCoord(chillPos) } : { c: packCoord(lair.pos) };
            });
        }
        else {
            delete room.memory["k"];
        }
        this.recordOwnedRoomStructures(room);
        this.recordPortalInfo(room);
    }
    static recordOwnedRoomStructures(room) {
        if (room.controller && room.controller.owner) {
            room.memory["i"] = {
                ["t"]: packCoordList(_.map(room.towers, t => t.pos)),
                ["sp"]: packCoordList(_.map(room.spawns, s => s.pos)),
                ["w"]: packCoordList(_.map(room.walls, w => w.pos)),
                ["r"]: packCoordList(_.map(room.ramparts, r => r.pos)),
                ["s"]: room.storage ? packCoord(room.storage.pos) : undefined,
                ["e"]: room.terminal ? packCoord(room.terminal.pos) : undefined,
            };
        }
        else {
            delete room.memory["i"];
        }
    }
    static recordPortalInfo(room) {
        if (room.portals.length > 0) {
            room.memory["pr"] = _.map(room.portals, portal => {
                const dest = portal.destination instanceof RoomPosition ? packPos(portal.destination)
                    : portal.destination;
                const expiration = portal.ticksToDecay != undefined ? Game.time + portal.ticksToDecay
                    : Game.time + 1000000;
                return { c: packCoord(portal.pos), dest: dest, ["X"]: expiration };
            });
            const uniquePortals = _.unique(room.portals, portal => portal.destination instanceof RoomPosition ? packPos(portal.destination)
                : portal.destination);
            if (!this.memory.portalRooms.includes(room.name)) {
                this.memory.portalRooms.push(room.name);
            }
        }
        else {
            delete room.memory["pr"];
            _.pull(this.memory.portalRooms, room.name);
        }
    }
    static recordControllerInfo(controller) {
        const savedController = controller.room.memory["c"];
        if (savedController) {
            savedController["r"] = controller.reservation ? {
                ["u"]: controller.reservation.username,
                ["t"]: controller.reservation.ticksToEnd,
            } : undefined;
            savedController["s"] = controller.safeMode;
            savedController["sc"] = controller.safeModeCooldown;
        }
    }
    static inSafeMode(roomName) {
        if (!!Memory.rooms[roomName] && !!Memory.rooms[roomName]["c"]) {
            const safemode = Memory.rooms[roomName]["c"]["s"];
            const tick = Memory.rooms[roomName]["X"];
            if (safemode && tick) {
                return Game.time < tick + safemode;
            }
        }
        return false;
    }
    static safeModeCooldown(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c"] &&
            Memory.rooms[roomName]["c"]["sc"]) {
            const smcooldown = Memory.rooms[roomName]["c"]["sc"];
            const tick = Memory.rooms[roomName]["X"];
            if (smcooldown && tick) {
                return smcooldown - (Game.time - tick);
            }
        }
    }
    static updateInvasionData(room) {
        if (!room.memory["v"]) {
            room.memory["v"] = {
                ["h"]: 0,
                ["l"]: 0,
            };
        }
        const sources = room.sources;
        const invasionData = room.memory["v"];
        for (const source of sources) {
            if (source.ticksToRegeneration == 1) {
                invasionData["h"] += source.energyCapacity - source.energy;
            }
        }
        if (room.invaders.length > 0) {
            invasionData["h"] = 0;
            invasionData["l"] = Game.time;
        }
    }
    static getExitPositions(roomName) {
        const terrain = Game.map.getRoomTerrain(roomName);
        const exitPositions = [];
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        for (let x = 0; x < 50; x++) {
            for (let y = 0; y < 50; y += 49) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        return exitPositions;
    }
    static getPreviousPos(creep) {
        const prevPositions = creep.room.memory["pp"];
        if (prevPositions) {
            const packedId = packId(creep.id);
            if (prevPositions[packedId]) {
                return unpackCoordAsPos(prevPositions[packedId], creep.room.name);
            }
        }
        return creep.pos;
    }
    static recordCreepPositions(room) {
        const positions = {};
        for (const creep of room.find(FIND_CREEPS)) {
            positions[packId(creep.id)] = packCoord(creep.pos);
        }
        room.memory["pp"] = {};
    }
    static recordSafety(roomName) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        Memory.rooms[roomName]["f"] = Memory.rooms[roomName]["f"] || {
            ["t"]: 0,
            ["s"]: 0,
            ["u"]: 0,
            ["v"]: 0,
        };
        const safetyData = Memory.rooms[roomName]["f"];
        const room = Game.rooms[roomName];
        if (room) {
            safetyData["v"] = 0;
            if (room.dangerousHostiles.length > 0) {
                safetyData["s"] = 0;
                safetyData["u"] += 1;
            }
            else {
                safetyData["s"] += 1;
                safetyData["u"] = 0;
            }
            if (room.my || room.isOutpost) {
                const potentials = CombatIntel.getCombatPotentials(room.dangerousPlayerHostiles);
                safetyData["c"] = {
                    ["a"]: potentials.attack,
                    ["r"]: potentials.ranged,
                    ["h"]: potentials.heal,
                };
                if (potentials.dismantle) {
                    safetyData["c"]["d"] = potentials.dismantle;
                }
                safetyData["nh"] = room.hostiles.length;
                safetyData["nb"] = _.filter(room.hostiles, hostile => hostile.boosts.length > 0).length;
            }
            else {
                delete safetyData["c"];
                delete safetyData["nh"];
                delete safetyData["nb"];
            }
        }
        else {
            safetyData["v"] += 1;
        }
        let instantaneousThreatLevel;
        if (!room) {
            instantaneousThreatLevel = 0.5;
        }
        else {
            if (room.controller && room.controller.safeMode) {
                instantaneousThreatLevel = 0;
            }
            else {
                if (room.dangerousPlayerHostiles.length > 0) {
                    instantaneousThreatLevel = 1;
                }
                else if (room.dangerousHostiles.length > 0) {
                    instantaneousThreatLevel = 0.5;
                }
                else {
                    instantaneousThreatLevel = 0;
                }
            }
        }
        const numBoostedHostiles = safetyData["nb"] || 0;
        switch (instantaneousThreatLevel) {
            case 0:
                safetyData["t"] = ema(instantaneousThreatLevel, safetyData["t"], CREEP_LIFE_TIME / 2);
                break;
            case 0.5:
                safetyData["t"] = ema(instantaneousThreatLevel, safetyData["t"], CREEP_LIFE_TIME / (1 + numBoostedHostiles));
                break;
            case 1:
                safetyData["t"] = ema(instantaneousThreatLevel, safetyData["t"], CREEP_LIFE_TIME / (4 + numBoostedHostiles));
                break;
        }
        if (room) {
            room.instantaneousThreatLevel = instantaneousThreatLevel;
            room.threatLevel = safetyData["t"];
            room.isSafe = room.instantaneousThreatLevel == 0 &&
                (room.threatLevel < 0.15 || safetyData["s"] > 50);
        }
    }
    static getSafetyData(roomName) {
        const data = Memory.rooms[roomName]["f"];
        return {
            threatLevel: data["t"],
            safeFor: data["s"],
            unsafeFor: data["u"],
            invisibleFor: data["v"],
            combatPotentials: data["c"],
            numHostiles: data["nh"],
            numBoostedHostiles: data["nb"],
        };
    }
    static isInvasionLikely(room) {
        const data = room.memory["v"];
        if (!data)
            return false;
        const harvested = data["h"];
        const lastSeen = data["l"];
        if (lastSeen > 20000) {
            return false;
        }
        switch (room.sources.length) {
            case 1:
                return harvested > 90000;
            case 2:
                return harvested > 75000;
            case 3:
                return harvested > 65000;
            default:
                return false;
        }
    }
    static roomOwnedBy(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c"] &&
            Memory.rooms[roomName]["c"]["o"]) {
            if (Game.time - (Memory.rooms[roomName]["T"] || 0) < 25000) {
                return Memory.rooms[roomName]["c"]["o"];
            }
        }
    }
    static roomReservedBy(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c"] &&
            Memory.rooms[roomName]["c"]["r"]) {
            if (Game.time - (Memory.rooms[roomName]["T"] || 0) < 10000) {
                return Memory.rooms[roomName]["c"]["r"]["u"];
            }
        }
    }
    static roomReservationRemaining(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c"] &&
            Memory.rooms[roomName]["c"]["r"]) {
            const ticksToEnd = Memory.rooms[roomName]["c"]["r"]["t"];
            const timeSinceLastSeen = Game.time - (Memory.rooms[roomName]["T"] || 0);
            return ticksToEnd - timeSinceLastSeen;
        }
        return 0;
    }
    static findPortalsInRange(roomName, range, includeIntershard = false) {
        const potentialPortalRooms = Cartographer.findRoomsInRange(roomName, range)
            .filter(roomName => Cartographer.roomType(roomName) == ROOMTYPE_CORE);
        const portalRooms = potentialPortalRooms.filter(roomName => Memory.rooms[roomName]
            && !!Memory.rooms[roomName]["pr"]);
        const rooms = {};
        for (const roomName of portalRooms) {
            const roomPortals = Memory.rooms[roomName]["pr"];
            if (roomPortals != undefined && roomPortals.length > 0) {
                rooms[roomName] = roomPortals;
            }
        }
        return rooms;
    }
    static getRoomStatus(roomName) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        if (!Memory.rooms[roomName]["rs"] ||
            new Date().getTime() > new Date(Memory.rooms[roomName]["rs"][1] * 1000).getTime()) {
            let { status, timestamp } = Game.map.getRoomStatus(roomName);
            if (timestamp == null) {
                const extraMilliseconds = 3 * 24 * 60 * 60 * 1000;
                timestamp = new Date().getTime() + extraMilliseconds;
            }
            timestamp = Math.floor(timestamp / 1000);
            switch (status) {
                case 'normal':
                    Memory.rooms[roomName]["rs"] = ["nm", timestamp];
                    break;
                case 'closed':
                    Memory.rooms[roomName]["rs"] = ["cl", timestamp];
                    break;
                case 'novice':
                    Memory.rooms[roomName]["rs"] = ["nv", timestamp];
                    break;
                case 'respawn':
                    Memory.rooms[roomName]["rs"] = ["re", timestamp];
                    break;
            }
        }
        const [statusCompressed, timestampCompressed] = Memory.rooms[roomName]["rs"];
        const timestamp = timestampCompressed * 1000;
        switch (statusCompressed) {
            case "nm":
                return { status: 'normal', timestamp: null };
            case "cl":
                return { status: 'closed', timestamp: null };
            case "nv":
                return { status: 'novice', timestamp: timestamp };
            case "re":
                return { status: 'respawn', timestamp: timestamp };
        }
    }
    static isRoomAccessible(roomName) {
        return RoomIntel_1.getRoomStatus(roomName).status == RoomIntel_1.getMyZoneStatus();
    }
    static getMyZoneStatus() {
        const oneOfMyColonies = _.first(_.values(Overmind.colonies));
        return RoomIntel_1.getRoomStatus(oneOfMyColonies.name).status;
    }
    static init() {
        for (const roomName in Game.rooms) {
            Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        }
        for (const roomName in Memory.rooms) {
            const room = Game.rooms[roomName];
            this.recordSafety(roomName);
            if (room) {
                this.markVisible(room);
            }
        }
    }
    static run() {
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            if (Overmind.colonyMap[room.name]) {
                this.updateInvasionData(room);
            }
            this.recordCreepPositions(room);
            if (Game.time >= (room.memory["X"] || 0)) {
                this.recordPermanentObjects(room);
                ExpansionEvaluator.computeExpansionData(room);
                const recacheTime = room.owner ? OWNED_RECACHE_TIME : RECACHE_TIME;
                room.memory["X"] = getCacheExpiration(recacheTime, 250);
            }
            if (room.controller && Game.time % 5 == 0) {
                this.recordControllerInfo(room.controller);
            }
        }
    }
};
RoomIntel = RoomIntel_1 = __decorate([
    profile
], RoomIntel);
global.RoomIntel = RoomIntel;

var Pathing_1;
const FIND_EXIT_PORTAL = 42;
const DEFAULT_MAXOPS = 20000;
const CREEP_COST = 0xfe;
const SK_COST = 10;
const PORTAL_COST = 25;
const MatrixTypes = {
    direct: 'dir',
    default: 'def',
    sk: 'sk',
    obstacle: 'obst',
    preferRampart: 'preframp',
    nearRampart: 'nearRamp'
};
const getDefaultPathOptions = () => ({
    range: 1,
    terrainCosts: { plainCost: 1, swampCost: 5 },
    roadCost: 'auto',
    ignoreCreeps: true,
    maxOps: DEFAULT_MAXOPS,
    maxRooms: 20,
    avoidSK: true,
    allowPortals: true,
    usePortalThreshold: 10,
    portalsMustBeInRange: 6,
    ensurePath: false,
});
const _defaultMatrixOptionsKeys = _.keys(getDefaultMatrixOptions());
function getMatrixOptsFromPathOpts(opts) {
    const matrixOpts = _.pick(opts, _defaultMatrixOptionsKeys);
    if (opts.obstacles) {
        matrixOpts.obstacles = packPosList(opts.obstacles);
    }
    return matrixOpts;
}
function pathOptsToMatrixAndVolatileOpts(opts) {
    const matrixOpts = getMatrixOptsFromPathOpts(opts);
    const volatileMatrixOpts = {};
    if (opts.blockCreeps)
        volatileMatrixOpts.blockCreeps = opts.blockCreeps;
    return [matrixOpts, volatileMatrixOpts];
}
let Pathing = Pathing_1 = class Pathing {
    static shouldAvoid(roomName) {
        return Memory.rooms[roomName] && Memory.rooms[roomName]["a"];
    }
    static updateRoomStatus(room) {
        if (!room) {
            return;
        }
        if (!room.my && room.towers.length > 0 && !isAlly(room.owner || '')) {
            room.memory["a"] = true;
        }
        else {
            delete room.memory["a"];
        }
    }
    static findPath(origin, destination, opts = {}) {
        var _a;
        _.defaults(opts, getDefaultPathOptions());
        const linearDistance = Game.map.getRoomLinearDistance(origin.roomName, destination.roomName);
        if (opts.maxRooms && linearDistance > opts.maxRooms && !opts.allowPortals) {
            log.warning(`Pathing from ${origin.print} to ${destination.print} exceeds max room specification ` +
                `of ${opts.maxRooms}!`);
        }
        let route = opts.route;
        if (!route && (opts.useFindRoute == true || (opts.useFindRoute === undefined && linearDistance >= 3))) {
            const foundRoute = this.findRoute(origin.roomName, destination.roomName, opts);
            if (foundRoute != ERR_NO_PATH) {
                route = foundRoute;
            }
        }
        const destinationGoal = { pos: destination, range: opts.range };
        const callback = (roomName) => Pathing_1.roomCallback(roomName, origin, destination, route, opts);
        let ret;
        const portalExitStepIndex = _.findIndex(route || [], step => step.exit == FIND_EXIT_PORTAL);
        const usesPortals = (portalExitStepIndex != -1);
        let portalUsed;
        if (usesPortals) {
            const portalEntranceStepIndex = portalExitStepIndex - 1;
            const portalEntraceRoom = portalEntranceStepIndex < 0
                ? origin.roomName
                : route[portalExitStepIndex - 1].room;
            const portals = RoomIntel.getPortalInfo(portalEntraceRoom);
            const portalGoals = _.map(portals, portal => ({ pos: portal.pos, range: 0 }));
            const path1ret = PathFinder.search(origin, portalGoals, {
                maxOps: opts.maxOps,
                maxRooms: opts.maxRooms,
                plainCost: opts.terrainCosts.plainCost,
                swampCost: opts.terrainCosts.swampCost,
                roomCallback: callback,
            });
            if (!path1ret.incomplete) {
                const lastPosInPath = (_a = _.last(path1ret.path)) !== null && _a !== void 0 ? _a : origin;
                const usedPortal = _.find(portals, portal => portal.pos.isEqualTo(lastPosInPath));
                if (usedPortal) {
                    portalUsed = usedPortal;
                    const portalDest = usedPortal.destination;
                    const path2ret = PathFinder.search(portalDest, destinationGoal, {
                        maxOps: opts.maxOps,
                        maxRooms: opts.maxRooms,
                        plainCost: opts.terrainCosts.plainCost,
                        swampCost: opts.terrainCosts.swampCost,
                        roomCallback: callback,
                    });
                    ret = {
                        path: path1ret.path.concat([usedPortal.destination]).concat(path2ret.path),
                        ops: path1ret.ops + path2ret.ops,
                        cost: path1ret.ops + path2ret.ops,
                        incomplete: path1ret.incomplete || path2ret.incomplete,
                    };
                }
                else {
                    log.error(`Pathing: No Portal pos in ${JSON.stringify(path1ret.path)}! (Why?)`);
                    ret = path1ret;
                }
            }
            else {
                log.error(`Pathing: Incomplete first half of pathing from ${origin.print} to nearest portal!`);
                ret = path1ret;
            }
        }
        else {
            ret = PathFinder.search(origin, destinationGoal, {
                maxOps: opts.maxOps,
                maxRooms: opts.maxRooms,
                plainCost: opts.terrainCosts.plainCost,
                swampCost: opts.terrainCosts.swampCost,
                roomCallback: callback,
            });
        }
        if (ret.incomplete && opts.ensurePath && linearDistance <= 3 && !opts.route) {
            const useRoute = this.findRoute(origin.roomName, destination.roomName, opts);
            if (useRoute != ERR_NO_PATH) {
                log.warning(`Pathing: findPath from ${origin.print} to ${destination.print} failed without ` +
                    `specified route. Trying again with route: ${JSON.stringify(useRoute)}.`);
                opts.route = useRoute;
                ret = this.findPath(origin, destination, opts);
                if (ret.incomplete) {
                    log.error(`Pathing: second attempt from ${origin.print} to ${destination.print} ` +
                        `was unsuccessful!`);
                }
            }
            else {
                log.error(`Pathing: findPath from ${origin.print} to ${destination.print} failed and route could ` +
                    `not be explicitly computed!`);
            }
        }
        return {
            path: ret.path,
            incomplete: ret.incomplete,
            ops: ret.ops,
            cost: ret.cost,
            route: route,
            usesPortals: usesPortals,
            portalUsed: portalUsed,
        };
    }
    static findRoute(origin, destination, opts = {}) {
        _.defaults(opts, getDefaultPathOptions());
        const linearDistance = Game.map.getRoomLinearDistance(origin, destination);
        const maxRooms = opts.maxRooms || linearDistance + 10;
        const myZoneStatus = RoomIntel.getMyZoneStatus();
        if (RoomIntel.getRoomStatus(destination).status != myZoneStatus) {
            return ERR_NO_PATH;
        }
        const getBestPortalDestination = (portalRoom) => {
            const portalInfo = RoomIntel.getPortalInfo(portalRoom);
            if (portalInfo.length == 0) {
                return;
            }
            const bestPortalDest = _(portalInfo)
                .map(portal => portal.destination.roomName)
                .unique()
                .min(portalDest => Game.map.getRoomLinearDistance(portalDest, destination));
            return bestPortalDest;
        };
        const callback = (roomName) => {
            const rangeToRoom = Game.map.getRoomLinearDistance(origin, roomName);
            if (rangeToRoom > maxRooms) {
                return Infinity;
            }
            if (!opts.allowHostile && this.shouldAvoid(roomName) &&
                roomName !== destination && roomName !== origin) {
                return Infinity;
            }
            if (RoomIntel.getRoomStatus(roomName).status != myZoneStatus) {
                return Infinity;
            }
            return 1;
        };
        let route = Game.map.findRoute(origin, destination, { routeCallback: callback });
        if (opts.allowPortals && (route == ERR_NO_PATH || route.length >= (opts.usePortalThreshold || 1))) {
            const validPortalRooms = _.filter(RoomIntel.memory.portalRooms, roomName => {
                const originToPortal = Game.map.getRoomLinearDistance(origin, roomName);
                if (originToPortal > opts.maxRooms)
                    return false;
                if (opts.portalsMustBeInRange && originToPortal > opts.portalsMustBeInRange)
                    return false;
                const bestPortalDestination = getBestPortalDestination(roomName);
                if (!bestPortalDestination)
                    return false;
                const portalToDestination = Game.map.getRoomLinearDistance(destination, bestPortalDestination);
                return originToPortal + portalToDestination <= opts.maxRooms;
            });
            const portalCallback = (roomName) => {
                if (!opts.allowHostile && this.shouldAvoid(roomName) &&
                    roomName !== destination && roomName !== origin) {
                    return Infinity;
                }
                if (RoomIntel.getRoomStatus(roomName).status != myZoneStatus) {
                    return Infinity;
                }
                return 1;
            };
            const bestPortalRoom = minBy(validPortalRooms, portalRoom => {
                const bestPortalDestination = getBestPortalDestination(portalRoom);
                const originToPortalRoute = Game.map.findRoute(origin, portalRoom, { routeCallback: portalCallback });
                const portalToDestinationRoute = Game.map.findRoute(bestPortalDestination, destination, { routeCallback: portalCallback });
                if (originToPortalRoute != ERR_NO_PATH && portalToDestinationRoute != ERR_NO_PATH) {
                    const portalRouteLength = originToPortalRoute.length + portalToDestinationRoute.length;
                    const directRouteLength = route != ERR_NO_PATH ? route.length : Infinity;
                    if (portalRouteLength < directRouteLength) {
                        return portalRouteLength;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            });
            if (bestPortalRoom) {
                const portalDest = getBestPortalDestination(bestPortalRoom);
                const originToPortalRoute = Game.map.findRoute(origin, bestPortalRoom, { routeCallback: portalCallback });
                const portalToDestinationRoute = Game.map.findRoute(portalDest, destination, { routeCallback: portalCallback });
                if (originToPortalRoute != ERR_NO_PATH && portalToDestinationRoute != ERR_NO_PATH) {
                    route = [...originToPortalRoute,
                        { exit: FIND_EXIT_PORTAL, room: portalDest },
                        ...portalToDestinationRoute];
                }
            }
        }
        if (route == ERR_NO_PATH) {
            log.warning(`Pathing: couldn't findRoute from ${origin} to ${destination} ` +
                `with opts ${JSON.stringify(opts)}!`);
            return ERR_NO_PATH;
        }
        else {
            return route;
        }
    }
    static findSwarmPath(origin, destination, width, height, options = {}) {
        _.defaults(options, {
            blockCreeps: false,
            maxOps: 2 * DEFAULT_MAXOPS,
            range: 1,
        });
        const destinations = this.getPosWindow(destination, -width, -height);
        const callback = (roomName) => this.swarmRoomCallback(roomName, width, height, options);
        return PathFinder.search(origin, _.map(destinations, pos => ({ pos: pos, range: options.range })), {
            maxOps: options.maxOps,
            maxRooms: options.maxRooms,
            plainCost: 1,
            swampCost: 5,
            roomCallback: callback,
        });
    }
    static getPosWindow(anchor, width, height) {
        const positions = [];
        for (const dx of _.range(0, width, width < 0 ? -1 : 1)) {
            for (const dy of _.range(0, height, height < 0 ? -1 : 1)) {
                positions.push(anchor.getOffsetPos(dx, dy));
            }
        }
        return positions;
    }
    static findShortestPath(startPos, endPos, opts = {}) {
        const optDefaults = {
            blockCreeps: false,
            range: 1,
            terrainCosts: { plainCost: 1, swampCost: 1 }
        };
        _.defaults(opts, optDefaults);
        const ret = this.findPath(startPos, endPos, opts);
        if (ret.incomplete)
            log.alert(`Pathing: incomplete path from ${startPos.print} to ${endPos.print}!`);
        return ret;
    }
    static findPathToRoom(startPos, roomName, options = {}) {
        options.range = 23;
        const ret = this.findPath(startPos, new RoomPosition(25, 25, roomName), options);
        if (ret.incomplete)
            log.alert(`Pathing: incomplete path from ${startPos.print} to ${roomName}!`);
        return ret;
    }
    static roomCallback(roomName, origin, destination, route, opts) {
        if (roomName != origin.roomName && roomName != destination.roomName) {
            if (route && !_.any(route, routePart => routePart.room == roomName)) {
                return false;
            }
            if (!opts.allowHostile && this.shouldAvoid(roomName)) {
                return false;
            }
        }
        const [matrixOpts, volatileMatrixOpts] = pathOptsToMatrixAndVolatileOpts(opts);
        const matrix = MatrixLib.getMatrix(roomName, matrixOpts, volatileMatrixOpts);
        if (opts.modifyRoomCallback && Game.rooms[roomName]) {
            return opts.modifyRoomCallback(Game.rooms[roomName], matrix.clone());
        }
        else {
            return matrix;
        }
    }
    static swarmRoomCallback(roomName, width, height, opts) {
        const matrixOpts = {
            explicitTerrainCosts: true,
            ignoreStructures: opts.ignoreStructures,
            swarmWidth: width,
            swarmHeight: height,
        };
        const volatileMatrixOpts = {};
        if (opts.blockCreeps)
            volatileMatrixOpts.blockCreeps = opts.blockCreeps;
        const matrix = MatrixLib.getMatrix(roomName, matrixOpts, volatileMatrixOpts);
        if (opts.displayCostMatrix) {
            Visualizer.displayCostMatrix(matrix, roomName);
        }
        return matrix;
    }
    static kitingRoomCallback(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return Pathing_1.getKitingMatrix(room);
        }
        else {
            return true;
        }
    }
    static findKitingPath(creepPos, fleeFrom, opts = {}) {
        _.defaults(opts, {
            fleeRange: 5,
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        const fleeFromPos = _.map(fleeFrom, flee => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, pos => {
            return { pos: pos, range: opts.fleeRange };
        });
        return PathFinder.search(creepPos, avoidGoals, {
            plainCost: opts.terrainCosts.plainCost,
            swampCost: opts.terrainCosts.swampCost,
            flee: true,
            roomCallback: Pathing_1.kitingRoomCallback,
            maxRooms: 1
        });
    }
    static findFleePath(creepPos, fleeFrom, opts = {}) {
        _.defaults(opts, {
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        if (opts.fleeRange == undefined)
            opts.fleeRange = opts.terrainCosts.plainCost > 1 ? 20 : 10;
        const fleeFromPos = _.map(fleeFrom, flee => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, pos => {
            return { pos: pos, range: opts.fleeRange };
        });
        const callback = (roomName) => {
            if (!opts.allowHostile && this.shouldAvoid(roomName) && roomName != creepPos.roomName) {
                return false;
            }
            const [matrixOpts, volatileMatrixOpts] = pathOptsToMatrixAndVolatileOpts(opts);
            const matrix = MatrixLib.getMatrix(roomName, matrixOpts, volatileMatrixOpts);
            if (opts.modifyRoomCallback && Game.rooms[roomName]) {
                return opts.modifyRoomCallback(Game.rooms[roomName], matrix.clone());
            }
            else {
                return matrix;
            }
        };
        return PathFinder.search(creepPos, avoidGoals, {
            plainCost: opts.terrainCosts.plainCost,
            swampCost: opts.terrainCosts.swampCost,
            flee: true,
            roomCallback: callback,
        });
    }
    static getKitingMatrix(room) {
        if (room._kitingMatrix) {
            return room._kitingMatrix;
        }
        const matrix = MatrixLib.getMatrix(room.name, {}).clone();
        const avoidCreeps = room.dangerousHostiles;
        _.forEach(avoidCreeps, avoidCreep => MatrixLib.addSquarePotential(matrix, avoidCreep.pos, 3, 30));
        room._kitingMatrix = matrix;
        return room._kitingMatrix;
    }
    static blockImpassibleStructures(matrix, room) {
        _.forEach(room.find(FIND_STRUCTURES), (s) => {
            if (!s.isWalkable) {
                if (s.structureType == STRUCTURE_PORTAL) {
                    matrix.set(s.pos.x, s.pos.y, 0xfe);
                }
                else {
                    matrix.set(s.pos.x, s.pos.y, 0xff);
                }
            }
        });
    }
    static serializePath(startPos, path, color = 'orange') {
        let serializedPath = '';
        let lastPosition = startPos;
        for (const position of path) {
            if (position.roomName == lastPosition.roomName) {
                new RoomVisual(position.roomName)
                    .line(position, lastPosition, { color: color });
                serializedPath += lastPosition.getDirectionTo(position);
            }
            lastPosition = position;
        }
        return serializedPath;
    }
    static nextDirectionInPath(creep) {
        const moveData = creep.memory._go;
        if (!moveData || !moveData.path || moveData.path.length == 0) {
            return;
        }
        return Number.parseInt(moveData.path[0], 10);
    }
    static nextPositionInPath(creep) {
        const nextDir = this.nextDirectionInPath(creep);
        if (!nextDir) {
            return;
        }
        return this.positionAtDirection(creep.pos, nextDir);
    }
    static oppositeDirection(direction) {
        switch (direction) {
            case TOP:
                return BOTTOM;
            case TOP_LEFT:
                return BOTTOM_RIGHT;
            case LEFT:
                return RIGHT;
            case BOTTOM_LEFT:
                return TOP_RIGHT;
            case BOTTOM:
                return TOP;
            case BOTTOM_RIGHT:
                return TOP_LEFT;
            case RIGHT:
                return LEFT;
            case TOP_RIGHT:
                return BOTTOM_LEFT;
        }
    }
    static positionAtDirection(origin, direction) {
        const offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];
        const offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];
        const x = origin.x + offsetX[direction];
        const y = origin.y + offsetY[direction];
        if (x > 49 || x < 0 || y > 49 || y < 0) {
            return;
        }
        return new RoomPosition(x, y, origin.roomName);
    }
    static distance(pos1, pos2) {
        const [name1, name2] = [packPos(pos1), packPos(pos2)].sort();
        if (!Memory.pathing.distances[name1]) {
            Memory.pathing.distances[name1] = {};
        }
        if (!Memory.pathing.distances[name1][name2]) {
            const ret = this.findPath(pos1, pos2);
            if (!ret.incomplete) {
                Memory.pathing.distances[name1][name2] = ret.path.length;
            }
            else {
                log.error(`PATHING: could not compute distance from ${pos1.print} to ${pos2.print}!`);
            }
        }
        return Memory.pathing.distances[name1][name2];
    }
    static isReachable(startPos, endPos, obstacles, options = {}) {
        _.defaults(options, {
            blockCreeps: false,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.error(`isReachable() should only be used within a single room!`);
            return false;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, obstacle => {
            if (_HasRoomPosition(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            }
            else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;
        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, {
            maxOps: options.maxOps,
            plainCost: 1,
            swampCost: 5,
            maxRooms: 1,
            roomCallback: callback,
        });
        if (ret.incomplete) {
            return false;
        }
        else {
            for (const pos of ret.path) {
                if (matrix.get(pos.x, pos.y) > 100) {
                    return false;
                }
            }
        }
        return true;
    }
    static findBlockingPos(startPos, endPos, obstacles, options = {}) {
        _.defaults(options, {
            blockCreeps: false,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.debug(`findBlockingPos() should only be used within a single room!`);
            return undefined;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, obstacle => {
            if (_HasRoomPosition(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            }
            else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;
        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, {
            maxOps: options.maxOps,
            plainCost: 1,
            swampCost: 5,
            maxRooms: 1,
            roomCallback: callback,
        });
        for (const pos of ret.path) {
            if (matrix.get(pos.x, pos.y) > 100) {
                return pos;
            }
        }
    }
    static findPathablePosition(roomName, clearance = { width: 1, height: 1 }) {
        const terrain = Game.map.getRoomTerrain(roomName);
        let x, y;
        let allClear;
        for (let radius = 0; radius < 23; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = 25 + dx;
                    y = 25 + dy;
                    allClear = true;
                    for (let w = 0; w < clearance.width; w++) {
                        for (let h = 0; h < clearance.height; h++) {
                            if (terrain.get(x + w, y + h) === TERRAIN_MASK_WALL) {
                                allClear = false;
                            }
                        }
                    }
                    if (allClear) {
                        return new RoomPosition(x, y, roomName);
                    }
                }
            }
        }
        return new RoomPosition(-10, -10, 'cannotFindPathablePosition');
    }
};
Pathing = Pathing_1 = __decorate([
    profile
], Pathing);
global.Pathing = Pathing;

let CombatTargeting = class CombatTargeting {
    static findBestCreepTargetInRange(zerg, range, targets = zerg.room.hostiles) {
        const nearbyHostiles = _.filter(targets, c => zerg.pos.inRangeToXY(c.pos.x, c.pos.y, range));
        return maxBy(nearbyHostiles, function (hostile) {
            if (hostile.hitsPredicted == undefined)
                hostile.hitsPredicted = hostile.hits;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))
                return false;
            return hostile.hitsMax - hostile.hitsPredicted + CombatIntel.getHealPotential(hostile);
        });
    }
    static findBestStructureTargetInRange(zerg, range, allowUnowned = true) {
        let nearbyStructures = _.filter(zerg.room.hostileStructures, s => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));
        if (allowUnowned && nearbyStructures.length == 0 && !Overmind.colonyMap[zerg.room.name]) {
            nearbyStructures = _.filter(zerg.room.structures, s => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));
        }
        return maxBy(nearbyStructures, function (structure) {
            let score = 10 * AttackStructureScores[structure.structureType];
            if (structure.pos.lookForStructure(STRUCTURE_RAMPART))
                score *= .1;
            return score;
        });
    }
    static findTarget(zerg, targets = zerg.room.hostiles) {
        return maxBy(targets, function (hostile) {
            if (hostile.hitsPredicted == undefined)
                hostile.hitsPredicted = hostile.hits;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))
                return false;
            return hostile.hitsMax - hostile.hitsPredicted + CombatIntel.getHealPotential(hostile)
                - 10 * zerg.pos.getMultiRoomRangeTo(hostile.pos);
        });
    }
    static findBestCreepTargetForTowers(room, targets = room.hostiles) {
        return maxBy(targets, function (hostile) {
            if (hostile.hitsPredicted == undefined)
                hostile.hitsPredicted = hostile.hits;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))
                return false;
            return hostile.hitsMax - hostile.hitsPredicted
                + CombatIntel.getHealPotential(hostile) + (CombatIntel.towerDamageAtPos(hostile.pos) || 0);
        });
    }
    static findClosestHostile(zerg, opts) {
        _.defaults(opts, {
            checkReachable: false,
            ignoreCreepsAtEdge: true,
            playerOnly: false,
            onlyUnramparted: false
        });
        if (zerg.room.hostiles.length > 0) {
            let targets;
            const potentialTargets = opts.playerOnly ? zerg.room.playerHostiles : zerg.room.hostiles;
            if (opts.ignoreCreepsAtEdge) {
                targets = _.filter(potentialTargets, hostile => hostile.pos.rangeToEdge > 0);
            }
            else {
                targets = potentialTargets;
            }
            if (opts.onlyUnramparted) {
                targets = _.filter(targets, hostile => !hostile.inRampart);
            }
            if (opts.checkReachable) {
                const targetsByRange = _.sortBy(targets, target => zerg.pos.getRangeTo(target));
                return _.find(targetsByRange, target => Pathing.isReachable(zerg.pos, target.pos, zerg.room.barriers.filter(barrier => barrier.structureType == STRUCTURE_WALL
                    || (barrier.structureType == STRUCTURE_RAMPART
                        && (barrier.owner.username == MY_USERNAME || !barrier.isPublic)))));
            }
            else {
                return zerg.pos.findClosestByRange(targets);
            }
        }
    }
    static findClosestReachable(pos, targets) {
        const targetsByRange = _.sortBy(targets, target => pos.getRangeTo(target));
        return _.find(targetsByRange, target => Pathing.isReachable(pos, target.pos, target.room.barriers));
    }
    static findClosestHurtFriendly(healer) {
        return healer.pos.findClosestByRange(_.filter(healer.room.friendlies, creep => creep.hits < creep.hitsMax));
    }
    static findBestHealingTargetInRange(healer, range = RANGES$1.RANGED_HEAL, friendlies = healer.room.friendlies) {
        const tempHitsPredicted = {};
        return maxBy(_.filter(friendlies, f => f.hits < f.hitsMax && healer.pos.getRangeTo(f) <= range), friend => {
            if (friend.hitsPredicted == undefined)
                friend.hitsPredicted = friend.hits;
            const attackProbability = 0.5;
            tempHitsPredicted[friend.id] = friend.hitsPredicted;
            for (const hostile of friend.pos.findInRange(friend.room.hostiles, 3)) {
                if (!friend.inRampart) {
                    if (hostile.pos.isNearTo(friend)) {
                        tempHitsPredicted[friend.id] -= attackProbability * CombatIntel.getAttackDamage(hostile);
                    }
                    else {
                        tempHitsPredicted[friend.id] -= attackProbability * CombatIntel.getRangedAttackDamage(hostile);
                    }
                }
            }
            const missingHits = friend.hitsMax - tempHitsPredicted[friend.id];
            if (healer.pos.getRangeTo(friend) > 1) {
                return Math.min(missingHits, CombatIntel.getRangedHealAmount(healer.creep));
            }
            else {
                return Math.min(missingHits, CombatIntel.getHealAmount(healer.creep));
            }
        });
    }
    static findClosestPrioritizedStructure(zerg, checkReachable = false) {
        for (const structureType of AttackStructurePriorities) {
            const structures = _.filter(zerg.room.hostileStructures, s => s.structureType == structureType);
            if (structures.length == 0)
                continue;
            if (checkReachable) {
                const closestReachable = this.findClosestReachable(zerg.pos, structures);
                if (closestReachable)
                    return closestReachable;
            }
            else {
                return zerg.pos.findClosestByRange(structures);
            }
        }
        const core = _.filter(zerg.room.hostileStructures, s => s.structureType.toString() == 'invaderCore');
        if (core.length != 0) {
            return core[0];
        }
    }
    static findBestStructureTarget(pos) {
        const room = Game.rooms[pos.roomName];
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        const unprotectedRepairables = _.filter(room.repairables, s => {
            const rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
            return !rampart || rampart.hits < 10000;
        });
        let approach = _.map(unprotectedRepairables, structure => {
            return { pos: structure.pos, range: 0 };
        });
        if (room.barriers.length == 0 && unprotectedRepairables.length == 0)
            return;
        if (approach.length > 0) {
            const ret = PathFinder.search(pos, approach, {
                maxRooms: 1,
                maxOps: 2000,
                roomCallback: roomName => {
                    if (roomName != room.name)
                        return false;
                    const matrix = new PathFinder.CostMatrix();
                    for (const barrier of room.barriers) {
                        matrix.set(barrier.pos.x, barrier.pos.y, 0xff);
                    }
                    return matrix;
                },
            });
            const targetPos = _.last(ret.path);
            if (!ret.incomplete && targetPos) {
                const targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {
                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
                }));
                if (targetStructure) {
                    log.debug(`Found unprotected structure target @ ${targetPos.print}`);
                    return targetStructure;
                }
            }
        }
        let targets = room.spawns;
        if (targets.length == 0)
            targets = room.repairables;
        if (targets.length == 0)
            targets = room.barriers;
        if (targets.length == 0)
            targets = room.structures;
        if (targets.length == 0)
            return;
        approach = _.map(targets, s => {
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, b => b.hits)) || 0;
        const ret = PathFinder.search(pos, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: roomName => {
                if (roomName != pos.roomName)
                    return false;
                const matrix = new PathFinder.CostMatrix();
                for (const barrier of room.barriers) {
                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100);
                    matrix.set(barrier.pos.x, barrier.pos.y, cost);
                }
                return matrix;
            },
        });
        for (const pos of ret.path) {
            const targetStructure = _.first(_.filter(pos.lookFor(LOOK_STRUCTURES), s => {
                return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
            }));
            if (targetStructure) {
                log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                return targetStructure;
            }
        }
    }
    static findBestSwarmStructureTarget(swarm, roomName, randomness = 0, displayCostMatrix = false) {
        const room = Game.rooms[roomName];
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        if (swarm.anchor.roomName != roomName) {
            log.warning(`Swarm is not in target room!`);
            return;
        }
        let targets = room.spawns;
        if (targets.length == 0)
            targets = room.towers;
        if (targets.length == 0)
            targets = room.repairables;
        if (targets.length == 0)
            targets = room.barriers;
        if (targets.length == 0)
            targets = room.structures;
        if (targets.length == 0)
            return;
        const approach = _.map(targets, s => {
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, b => b.hits)) || 0;
        const ret = PathFinder.search(swarm.anchor, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: rn => {
                if (rn != roomName)
                    return false;
                const matrix = MatrixLib.getSwarmTerrainMatrix(roomName, { plainCost: 1, swampCost: 5 }, swarm.width, swarm.height);
                for (const barrier of room.barriers) {
                    const randomFactor = Math.min(Math.round(randomness * Math.random()), 100);
                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100) + randomFactor;
                    MatrixLib.setToMaxCostAfterMaxPooling(matrix, [barrier], swarm.width, swarm.height, cost);
                }
                if (displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            },
        });
        for (const pos of ret.path) {
            log.debug(`Searching path ${pos.print}...`);
            const searchPositions = Pathing.getPosWindow(pos, swarm.width, swarm.height);
            for (const searchPos of searchPositions) {
                const targetStructure = _.first(_.filter(searchPos.lookFor(LOOK_STRUCTURES), s => {
                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
                }));
                if (targetStructure) {
                    log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                    return targetStructure;
                }
            }
        }
    }
};
CombatTargeting = __decorate([
    profile
], CombatTargeting);

const getDefaultSwarmMemory = () => ({
    creeps: [],
    orientation: TOP,
    numRetreats: 0,
});
const ERR_NOT_ALL_OK = -7;
const DEBUG$2 = true;
let Swarm = class Swarm {
    constructor(overlord, ref, creeps, width = 2, height = 2) {
        this.overlord = overlord;
        this.ref = ref;
        this.memory = Mem.wrap(overlord.memory, `swarm:${ref}`, getDefaultSwarmMemory);
        const paddedCreeps = _.clone(creeps);
        for (let i = paddedCreeps.length; i < width * height; i++) {
            paddedCreeps.push(undefined);
        }
        const creepScores = this.getCreepScores(paddedCreeps);
        const sortedCreeps = _.sortBy(paddedCreeps, creep => creepScores[creep != undefined ? creep.name : 'undefined']);
        this.uniformCreepType = (_.unique(_.filter(_.values(creepScores), score => score != 0)).length <= 1);
        this.staticFormation = _.chunk(sortedCreeps, width);
        this.width = width;
        this.height = height;
        const firstCreepIndex = _.findIndex(sortedCreeps);
        let leadPos;
        if (firstCreepIndex != -1) {
            const firstCreepPos = sortedCreeps[firstCreepIndex].pos;
            const dx = firstCreepIndex % width;
            const dy = Math.floor(firstCreepIndex / width);
            leadPos = firstCreepPos.getOffsetPos(-dx, -dy);
        }
        else {
            leadPos = this.overlord.pos;
        }
        switch (this.orientation) {
            case TOP:
                this.anchor = leadPos;
                break;
            case RIGHT:
                this.anchor = leadPos.getOffsetPos(-1 * (height - 1), 0);
                break;
            case BOTTOM:
                this.anchor = leadPos.getOffsetPos(-1 * (width - 1), -1 * (height - 1));
                break;
            case LEFT:
                this.anchor = leadPos.getOffsetPos(0, -1 * (width - 1));
                break;
        }
        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(this.orientation));
        this.creeps = creeps;
        this.rooms = _.unique(_.map(this.creeps, creep => creep.room), room => room.name);
        this.roomsByName = _.zipObject(_.map(this.rooms, room => [room.name, room]));
        this.fatigue = _.max(_.map(this.creeps, creep => creep.fatigue));
        this.debug(`\n${this.print} tick ${Game.time} ========================================`);
    }
    getCreepScores(creeps) {
        const keys = _.map(creeps, c => c != undefined ? c.name : 'undefined');
        const values = _.map(creeps, z => {
            if (z == undefined) {
                return 0;
            }
            else {
                const score = CombatIntel.getAttackPotential(z.creep) + CombatIntel.getRangedAttackPotential(z.creep)
                    + CombatIntel.getDismantlePotential(z.creep) - CombatIntel.getHealPotential(z.creep);
                return (-1 * score) || 1;
            }
        });
        return _.zipObject(keys, values);
    }
    printFormation(formation) {
        const names = _.map(formation, creeps => _.map(creeps, creep => creep ? creep.name : 'NONE'));
        const SPACE = '    ';
        let msg = '';
        for (const row of names) {
            msg += '\n' + SPACE;
            for (const name of row) {
                if (name != 'NONE') {
                    const role = name.split('_')[0];
                    const num = name.split('_')[1];
                    const shortName = role.slice(0, 4 - num.length) + num;
                    msg += shortName;
                }
                else {
                    msg += name;
                }
                msg += ' ';
            }
        }
        return msg;
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + ((this.anchor
            || this.rooms[0])).roomName + '">[' + `Swarm ` + this.ref + ']</a>';
    }
    debug(...args) {
        if (DEBUG$2) {
            console.log(args);
        }
    }
    static cleanMemory(overlord) {
        for (const ref in overlord.swarms) {
        }
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(100) };
        }
        else {
            delete this.memory.target;
        }
    }
    get orientation() {
        return this.memory.orientation;
    }
    set orientation(direction) {
        this.memory.orientation = direction;
        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(direction));
    }
    pivot(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Rotating ${direction}`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(`c1...c4: ${this.printFormation([
            [c1, c2],
            [c3, c4]
        ])}`);
        let r1, r2, r3, r4 = OK;
        if (direction == 'clockwise') {
            if (c1)
                r1 = c1.move(RIGHT);
            if (c2)
                r2 = c2.move(BOTTOM);
            if (c3)
                r3 = c3.move(TOP);
            if (c4)
                r4 = c4.move(LEFT);
        }
        else {
            if (c1)
                r1 = c1.move(BOTTOM);
            if (c2)
                r2 = c2.move(LEFT);
            if (c3)
                r3 = c3.move(RIGHT);
            if (c4)
                r4 = c4.move(TOP);
        }
        const allMoved = _.all([r1, r2, r3, r4], r => r == OK);
        if (allMoved) {
            return OK;
        }
        else {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
            return -1 * (_.findIndex([r1, r2, r3, r4], r => r != OK) || 899) - 100;
        }
    }
    swap(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Swapping ${direction}ly`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(`c1...c4: ${this.printFormation([
            [c1, c2],
            [c3, c4]
        ])}`);
        let r1, r2, r3, r4 = OK;
        if (c1)
            r1 = c1.move(BOTTOM_RIGHT);
        if (c2)
            r2 = c2.move(BOTTOM_LEFT);
        if (c3)
            r3 = c3.move(TOP_RIGHT);
        if (c4)
            r4 = c4.move(TOP_LEFT);
        const allMoved = _.all([r1, r2, r3, r4], r => r == OK);
        if (allMoved) {
            return OK;
        }
        else {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
            return -1 * (_.findIndex([r1, r2, r3, r4], r => r != OK) || 899) - 100;
        }
    }
    rotate(direction) {
        if (direction == this.orientation) {
            return NO_ACTION;
        }
        if (!(this.width == 2 && this.height == 2)) {
            console.log('NOT IMPLEMENTED FOR LARGER SWARMS YET');
            return -100;
        }
        let ret = -777;
        if (this.fatigue > 0) {
            ret = ERR_TIRED;
        }
        else {
            const prevDirection = this.orientation;
            const prevFormation = this.formation;
            const prevAngle = this.rotationsFromOrientation(prevDirection);
            const newAngle = this.rotationsFromOrientation(direction);
            const rotateAngle = newAngle - prevAngle;
            if (rotateAngle == 3 || rotateAngle == -1) {
                ret = this.pivot('counterclockwise');
            }
            else if (rotateAngle == 1 || rotateAngle == -3) {
                ret = this.pivot('clockwise');
            }
            else if (rotateAngle == 2 || rotateAngle == -2) {
                if (newAngle % 2 == 0) {
                    ret = this.swap('vertical');
                }
                else {
                    ret = this.swap('horizontal');
                }
            }
            if (ret == OK) {
                this.orientation = direction;
            }
        }
        this.debug(`Rotating to ${direction}, result: ${ret}`);
        return ret;
    }
    rotationsFromOrientation(direction) {
        switch (direction) {
            case TOP:
                return 0;
            case RIGHT:
                return 1;
            case BOTTOM:
                return 2;
            case LEFT:
                return 3;
        }
    }
    minRangeTo(obj) {
        if (_HasRoomPosition(obj)) {
            return _.min(_.map(this.creeps, creep => creep.pos.roomName === obj.pos.roomName ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y) : Infinity));
        }
        else {
            return _.min(_.map(this.creeps, creep => creep.pos.roomName === obj.roomName ? creep.pos.getRangeToXY(obj.x, obj.y) : Infinity));
        }
    }
    maxRangeTo(obj) {
        if (_HasRoomPosition(obj)) {
            return _.max(_.map(this.creeps, creep => creep.pos.roomName === obj.pos.roomName ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y) : Infinity));
        }
        else {
            return _.max(_.map(this.creeps, creep => creep.pos.roomName === obj.roomName ? creep.pos.getRangeToXY(obj.x, obj.y) : Infinity));
        }
    }
    findInMinRange(targets, range) {
        const initialRange = range + Math.max(this.width, this.height) - 1;
        const targetsInRange = _.filter(targets, t => this.anchor.inRangeToXY(t.pos.x, t.pos.y, initialRange));
        return _.filter(targetsInRange, t => this.minRangeTo(t) <= range);
    }
    getDirectionTo(obj) {
        const pos = normalizePos(obj);
        const directions = _.map(this.creeps, creep => creep.pos.getDirectionTo(obj));
        log.warning(`NOT IMPLEMENTED`);
        return TOP;
    }
    getFormationPositionsFromAnchor(anchor) {
        const formationPositions = {};
        for (let dy = 0; dy < this.formation.length; dy++) {
            for (let dx = 0; dx < this.formation[dy].length; dx++) {
                if (this.formation[dy][dx]) {
                    formationPositions[this.formation[dy][dx].name] = anchor.getOffsetPos(dx, dy);
                }
            }
        }
        return formationPositions;
    }
    isInFormation(anchor = this.anchor) {
        const formationPositions = this.getFormationPositionsFromAnchor(anchor);
        return _.all(this.creeps, creep => creep.pos.isEqualTo(formationPositions[creep.name]));
    }
    get hasMaxCreeps() {
        return this.creeps.length == this.width * this.height;
    }
    get isExpired() {
        if (!this.hasMaxCreeps) {
            const minTicksToLive = _.min(_.map(this.creeps, creep => creep.ticksToLive || 9999)) || 0;
            const spawnBuffer = 150 + 25;
            const newCreepTicksToLive = CREEP_LIFE_TIME + spawnBuffer;
            return newCreepTicksToLive - minTicksToLive >= DEFAULT_SWARM_TICK_DIFFERENCE;
        }
        else {
            return false;
        }
    }
    get inMultipleRooms() {
        return _.keys(this.roomsByName).length > 1;
    }
    assemble(assemblyPoint, allowIdleCombat = true) {
        if (this.isInFormation(assemblyPoint) && this.hasMaxCreeps) {
            this.memory.initialAssembly = true;
            return true;
        }
        else {
            const formationPositions = this.getFormationPositionsFromAnchor(assemblyPoint);
            console.log(JSON.stringify(formationPositions));
            for (const creep of this.creeps) {
                if (creep.hasValidTask) {
                    continue;
                }
                if (allowIdleCombat && creep.room.dangerousPlayerHostiles.length > 0 && !this.hasMaxCreeps) {
                    creep.autoSkirmish(creep.room.name);
                }
                else {
                    const destination = formationPositions[creep.name];
                    const ret = creep.goTo(destination, {
                        noPush: creep.pos.inRangeToPos(destination, 5),
                        ignoreCreepsOnDestination: true,
                    });
                    console.log(`${creep.print} moves to ${destination.print}, response: ${ret}`);
                }
            }
            return false;
        }
    }
    findRegroupPosition() {
        let x, y;
        const MAX_RADIUS = 10;
        for (let radius = 0; radius < MAX_RADIUS; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = this.anchor.x + dx;
                    y = this.anchor.y + dy;
                    if (x < 0 || x > 49 || y < 0 || y > 49) {
                        continue;
                    }
                    let allPathable = true;
                    const pos = new RoomPosition(x, y, this.anchor.roomName);
                    for (let i = 0; i < this.formation.length; i++) {
                        for (let j = 0; j < this.formation[i].length; j++) {
                            if (!pos.getOffsetPos(i, j).isWalkable(true)) {
                                allPathable = false;
                            }
                        }
                    }
                    if (allPathable) {
                        return pos;
                    }
                }
            }
        }
        return new RoomPosition(-10, -10, 'cannotFindLocationPosition');
    }
    regroup() {
        if (this.isInFormation(this.anchor)) {
            return true;
        }
        else {
            const regroupPosition = this.findRegroupPosition();
            this.debug(`Reassembling at ${regroupPosition.print}`);
            return this.assemble(regroupPosition, false);
        }
    }
    move(direction) {
        let allMoved = true;
        for (const creep of this.creeps) {
            const result = creep.move(direction);
            this.debug(`${creep.print} move ${direction}, result: ${result}`);
            if (result != OK) {
                allMoved = false;
            }
        }
        if (!allMoved) {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
        }
        return allMoved ? OK : ERR_NOT_ALL_OK;
    }
    goTo(destination, options = {}) {
        return Movement.swarmMove(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        return Movement.goToRoom_swarm(this, roomName, options);
    }
    combatMove(approach, avoid, options = {}) {
        const ret = Movement.swarmCombatMove(this, approach, avoid, options);
        this.debug(`Moving... Result: ${ret}`);
        return ret;
    }
    safelyInRoom(roomName) {
        return _.all(this.creeps, creep => creep.safelyInRoom(roomName));
    }
    reorient(includeStructures = true, includeCreeps = false) {
        if (this.uniformCreepType) {
            return NO_ACTION;
        }
        const targetRoom = _.find(this.rooms, room => room.owner && !room.my);
        if (targetRoom) {
            const orientation = this.getBestOrientation(targetRoom, includeStructures, includeCreeps);
            if (orientation != this.orientation && this.fatigue == 0) {
                this.debug(`Reorienting to ${orientation}!`);
                return this.rotate(orientation);
            }
        }
        return NO_ACTION;
    }
    getBestOrientation(room, includeStructures = true, includeCreeps = false) {
        const targets = [];
        if (includeStructures) {
            const structureTargets = this.findInMinRange(room.hostileStructures, 1);
            for (const structure of structureTargets) {
                targets.push(structure);
            }
        }
        if (includeCreeps) {
            const creepTargets = this.findInMinRange(room.dangerousHostiles, 2);
            for (const creep of creepTargets) {
                targets.push(creep);
            }
        }
        this.debug(`Targets: `, _.map(targets, t => t.pos.print));
        if (targets.length == 0) {
            return this.orientation;
        }
        const dxList = _.flatten(_.map(this.creeps, creep => _.map(targets, target => target.pos.x - creep.pos.x)));
        const dyList = _.flatten(_.map(this.creeps, creep => _.map(targets, target => target.pos.y - creep.pos.y)));
        const dx = _.sum(dxList) / dxList.length || 0;
        const dy = _.sum(dyList) / dyList.length || 0;
        this.debug(`dx: ${dx}, dy: ${dy}`);
        if (Math.abs(dx) > Math.abs(dy)) {
            return dx > 0 ? RIGHT : LEFT;
        }
        else {
            return dy > 0 ? BOTTOM : TOP;
        }
    }
    autoMelee() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(ATTACK) > 0) {
                creep.autoMelee();
            }
        }
    }
    autoRanged() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
                creep.autoRanged();
            }
        }
    }
    autoHeal(allowRangedHeal = true) {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(HEAL) > 0) {
                creep.autoHeal(allowRangedHeal);
            }
        }
    }
    autoSiege(roomName, waypoint) {
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, creep => creep.pos.isEdge)) {
                return this.regroup();
            }
        }
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined;
            return this.recover();
        }
        if (!this.safelyInRoom(roomName)) {
            if (waypoint) {
                return this.goTo(waypoint);
            }
            else {
                return this.goToRoom(roomName);
            }
        }
        if (!this.target) {
            const displayCostMatrix = DEBUG$2;
            this.target = CombatTargeting.findBestSwarmStructureTarget(this, roomName, 10 * this.memory.numRetreats, displayCostMatrix);
            this.debug(this.target);
        }
        if (this.target) {
            const result = this.combatMove([{ pos: this.target.pos, range: 1 }], []);
            if (result != NO_ACTION) {
                this.debug(`Moving to target ${this.target}: ${result}`);
                return result;
            }
            else {
            }
        }
        else {
            log.warning(`No target for swarm ${this.ref}!`);
        }
        this.reorient(true, false);
    }
    autoCombat(roomName, waypoint) {
        this.debug(`Running autocombat!`);
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, creep => creep.pos.isEdge)) {
                return this.regroup();
            }
        }
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined;
            return this.recover();
        }
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            if (waypoint) {
                return this.goTo(waypoint);
            }
            else {
                return this.goToRoom(roomName);
            }
        }
        const goals = GoalFinder.swarmCombatGoals(this, true);
        this.debug(`Goals: ${JSON.stringify(goals)}`);
        if (_.any(goals.avoid, goal => this.minRangeTo(goal) <= goal.range)) {
            let result = this.combatMove(goals.approach, goals.avoid);
            if (result != OK) {
                result = this.reorient(true, true);
            }
            return result;
        }
        else {
            let result = this.reorient(true, true);
            if (result != OK) {
                result = this.combatMove(goals.approach, goals.avoid);
            }
            return result;
        }
    }
    needsToRecover(recoverThreshold = 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = _.any(this.creeps, creep => creep.hits < creep.hitsMax * reengageThreshold);
        }
        else {
            recovering = _.any(this.creeps, creep => creep.hits < creep.hitsMax * recoverThreshold);
        }
        if (recovering && recovering != this.memory.recovering) {
            this.memory.numRetreats++;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    recover() {
        const allHostiles = _.flatten(_.map(this.rooms, room => room.hostiles));
        const allTowers = _.flatten(_.map(this.rooms, room => room.owner && !room.my ? room.towers : []));
        if (_.filter(allHostiles, h => this.minRangeTo(h)).length > 0 || allTowers.length > 0) {
            this.memory.lastInDanger = Game.time;
        }
        const allAvoidGoals = _.flatten(_.map(this.rooms, room => GoalFinder.retreatGoalsForRoom(room).avoid));
        const result = Movement.swarmCombatMove(this, [], allAvoidGoals);
        if (result == NO_ACTION) {
            const safeRoom = _.first(_.filter(this.rooms, room => !room.owner || room.my));
            if (safeRoom && !this.safelyInRoom(safeRoom.name)) {
                if (Game.time < (this.memory.lastInDanger || 0) + 3) {
                    return this.goToRoom(safeRoom.name);
                }
            }
        }
        return result;
    }
    static findEnemySwarms(room, anchor, maxClumpSize = 3) {
        const enemySwarms = [];
        const origin = anchor || _.first(room.spawns) || room.controller || { pos: new RoomPosition(25, 25, room.name) };
        let attackers = _.sortBy(room.dangerousHostiles, creep => origin.pos.getRangeTo(creep));
        while (attackers.length > 0) {
            const clump = _.first(attackers).pos.findInRange(attackers, maxClumpSize);
            attackers = _.difference(attackers, clump);
            enemySwarms.push({ creeps: clump });
        }
        return enemySwarms;
    }
};
Swarm = __decorate([
    profile
], Swarm);

const DEBUG$1 = false;
let GoalFinder = class GoalFinder {
    static skirmishGoals(zerg) {
        const approach = [];
        const avoid = [];
        const room = zerg.room;
        const analysis = {};
        const myAttack = CombatIntel.getAttackDamage(zerg);
        const myRangedAttack = CombatIntel.getRangedAttackDamage(zerg);
        const myHealing = CombatIntel.getHealAmount(zerg);
        if (myHealing > 0 && myAttack == 0 && myRangedAttack == 0) {
            return this.healingGoals(zerg);
        }
        const preferCloseCombat = myAttack > 0;
        const myRating = CombatIntel.rating(zerg);
        const nearbyRating = _.sum(zerg.pos.findInRange(room.creeps, 6), c => CombatIntel.rating(c));
        const braveMode = zerg.hits * (nearbyRating / myRating) * .5 > zerg.hitsMax;
        const hostileHealers = [];
        for (const hostile of room.hostiles) {
            if (hostile.owner.username == 'Source Keeper')
                continue;
            const attack = CombatIntel.getAttackDamage(hostile);
            const rangedAttack = CombatIntel.getRangedAttackDamage(hostile);
            const healing = CombatIntel.getHealAmount(hostile);
            if (healing > 0 && attack == 0 && rangedAttack == 0) {
                hostileHealers.push(hostile);
            }
            analysis[hostile.id] = {
                attack: attack,
                rangedAttack: rangedAttack,
                heal: healing,
                advantage: healing == 0 || attack + rangedAttack == 0 ||
                    myAttack + myRangedAttack + myHealing / CombatIntel.minimumDamageTakenMultiplier(zerg.creep)
                        > attack + rangedAttack + healing / CombatIntel.minimumDamageTakenMultiplier(hostile),
                isRetreating: CombatIntel.isRetreating(hostile, RoomIntel.getPreviousPos(zerg.creep)),
                isApproaching: CombatIntel.isApproaching(hostile, RoomIntel.getPreviousPos(zerg.creep)),
            };
        }
        const approachTargets = hostileHealers.length > 0 ? hostileHealers : room.hostiles;
        for (const target of approachTargets) {
            const data = analysis[target.id];
            if (data && (data.advantage || braveMode)) {
                let range = 1;
                if (!preferCloseCombat && (data.attack > 0 || data.rangedAttack > myRangedAttack)) {
                    range = zerg.pos.getRangeTo(target) == 3 && data.isRetreating ? 2 : 3;
                    avoid.push({ pos: target.pos, range: range });
                }
                approach.push({ pos: target.pos, range: range });
            }
        }
        if (approach.length == 0) {
            for (const friendly of room.creeps) {
                approach.push({ pos: friendly.pos, range: 0 });
            }
        }
        for (const target of room.hostiles) {
            const data = analysis[target.id];
            if (data && (!data.advantage && !braveMode)) {
                let range = data.isApproaching ? 3 : 2;
                if (data.rangedAttack > 0) {
                    range = 8;
                }
                avoid.push({ pos: target.pos, range: range });
            }
        }
        if (DEBUG$1) {
            log.debug(`Report for ${zerg.name}:`, JSON.stringify(analysis));
            log.debug(`Approach for ${zerg.name}:`, JSON.stringify(approach));
            log.debug(`Avoid for ${zerg.name}:`, JSON.stringify(avoid));
        }
        return { approach, avoid };
    }
    static swarmCombatGoals(swarm, includeStructures = true) {
        const approach = [];
        const avoid = [];
        if (swarm.rooms.length > 1) {
            log.warning(`Swarm in more than 1 room!`);
        }
        const room = maxBy(swarm.rooms, room => room.hostiles.length + room.hostileStructures.length);
        const myAttack = _.sum(swarm.creeps, creep => CombatIntel.getAttackDamage(creep));
        const myRangedAttack = _.sum(swarm.creeps, creep => CombatIntel.getRangedAttackDamage(creep));
        const myHealing = _.sum(swarm.creeps, creep => CombatIntel.getHealAmount(creep));
        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(_.map(swarm.creeps, c => c.creep));
        const preferCloseCombat = myAttack > myRangedAttack;
        const myRating = _.sum(swarm.creeps, creep => CombatIntel.rating(creep));
        const hostileSwarms = Swarm.findEnemySwarms(room, { pos: swarm.anchor });
        for (const i in hostileSwarms) {
            const hostiles = hostileSwarms[i].creeps;
            const attack = _.sum(hostiles, creep => CombatIntel.getAttackDamage(creep));
            const rangedAttack = _.sum(hostiles, creep => CombatIntel.getRangedAttackDamage(creep));
            const healing = _.sum(hostiles, creep => CombatIntel.getHealAmount(creep));
            const damageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(hostiles);
            const canPopShield = (attack + rangedAttack + CombatIntel.towerDamageAtPos(swarm.anchor)) * myDamageMultiplier
                > _.min(_.map(swarm.creeps, creep => 100 * creep.getActiveBodyparts(TOUGH)));
            const isRetreating = _.sum(hostiles, creep => +CombatIntel.isRetreating(creep, swarm.anchor))
                / hostiles.length >= 0.5;
            const isApproaching = _.sum(hostiles, creep => +CombatIntel.isApproaching(creep, swarm.anchor))
                / hostiles.length >= 0.5;
            const advantage = healing == 0 || attack + rangedAttack == 0 ||
                myAttack + myRangedAttack + myHealing / myDamageMultiplier
                    > attack + rangedAttack + healing / damageMultiplier;
            for (const hostile of hostiles) {
                if (canPopShield && hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                    let range = (rangedAttack > attack || !preferCloseCombat ? 3 : 1) + 1;
                    if (CombatIntel.isApproaching(hostile, swarm.anchor)) {
                        range += 1;
                    }
                    avoid.push({ pos: hostile.pos, range: range });
                }
                else {
                    if (advantage) {
                        let range = preferCloseCombat ? 3 : 1;
                        if (!preferCloseCombat && (attack > 0 || rangedAttack > myAttack)) {
                            range = swarm.minRangeTo(hostile) == 3 && isRetreating ? 2 : 3;
                            avoid.push({ pos: hostile.pos, range: range });
                        }
                        approach.push({ pos: hostile.pos, range: range });
                    }
                    else {
                        let range = isApproaching ? 3 : 2;
                        if (rangedAttack > attack) {
                            range = 5;
                        }
                        avoid.push({ pos: hostile.pos, range: range });
                    }
                }
            }
        }
        if (includeStructures) {
            const approachStructures = [];
            for (const structure of room.hostileStructures) {
                approachStructures.push(structure);
            }
            for (const wall of room.walls) {
                approachStructures.push(wall);
            }
            for (const approachStructure of approachStructures) {
                approach.push({ pos: approachStructure.pos, range: 1 });
            }
        }
        if (DEBUG$1) {
            log.debug(`Approach for ${swarm.print}:`, JSON.stringify(approach));
            log.debug(`Avoid for ${swarm.print}:`, JSON.stringify(avoid));
        }
        return { approach, avoid };
    }
    static retreatGoals(creep) {
        const approach = [];
        const avoid = [];
        const isHealer = CombatIntel.isHealer(creep);
        for (const friendly of creep.room.creeps) {
            if (CombatIntel.getHealPotential(friendly) > 0 || (isHealer && isCombatZerg(creep))) {
                approach.push({ pos: friendly.pos, range: 1 });
            }
        }
        for (const hostile of creep.room.hostiles) {
            if (CombatIntel.getAttackPotential(hostile) > 0 || CombatIntel.getRangedAttackPotential(hostile) > 0) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (creep.room.owner && !creep.room.my) {
            for (const tower of creep.room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach, avoid };
    }
    static retreatGoalsForRoom(room) {
        const avoid = [];
        for (const hostile of room.hostiles) {
            if (CombatIntel.getAttackPotential(hostile) > 0 || CombatIntel.getRangedAttackPotential(hostile) > 0) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (room.owner && !room.my) {
            for (const tower of room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach: [], avoid: avoid };
    }
    static healingGoals(healer) {
        const approach = [];
        const avoid = [];
        const healAmount = CombatIntel.getHealAmount(healer);
        let target = minBy(_.filter(healer.room.creeps, c => c.hits < c.hitsMax), c => c.hits + healer.pos.getRangeTo(c));
        if (!target) {
            target = minBy(healer.room.creeps, creep => {
                const range = healer.pos.getRangeTo(creep);
                return range > 0 ? CombatIntel.maxFriendlyHealingTo(creep) / healAmount + range : false;
            });
        }
        if (target) {
            approach.push({ pos: target.pos, range: 0 });
        }
        for (const hostile of healer.room.hostiles) {
            const meleeDamage = CombatIntel.getAttackDamage(hostile);
            const rangedDamage = CombatIntel.getRangedAttackDamage(hostile);
            if (meleeDamage + rangedDamage > 0) {
                const range = rangedDamage > healAmount ? 4 : 3;
                avoid.push({ pos: hostile.pos, range: range });
            }
        }
        return { approach, avoid };
    }
    static structureGoals(creep) {
        const approach = [];
        log.error(`NOT IMPLEMENTED`);
        return { approach: approach, avoid: [] };
    }
};
GoalFinder = __decorate([
    profile
], GoalFinder);
global.GoalFinder = GoalFinder;

const DEFAULT_PARTNER_TICK_DIFFERENCE = 650;
const DEFAULT_SWARM_TICK_DIFFERENCE = 500;
let CombatZerg = class CombatZerg extends Zerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isCombatZerg = true;
        _.defaults(this.memory, {
            recovering: false,
            lastInDanger: 0,
            targets: {}
        });
    }
    findPartner(partners, tickDifference = DEFAULT_PARTNER_TICK_DIFFERENCE) {
        if (this.memory.partner) {
            const partner = _.find(partners, partner => partner.name == this.memory.partner);
            if (partner) {
                return partner;
            }
            else {
                delete this.memory.partner;
                this.findPartner(partners, tickDifference);
            }
        }
        else {
            let partner = _.find(partners, partner => partner.memory.partner == this.name);
            if (!partner) {
                partner = _(partners)
                    .filter(partner => !partner.memory.partner &&
                    Math.abs((this.ticksToLive || CREEP_LIFE_TIME)
                        - (partner.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)
                    .min(partner => Math.abs((this.ticksToLive || CREEP_LIFE_TIME)
                    - (partner.ticksToLive || CREEP_LIFE_TIME)));
            }
            if (_.isObject(partner)) {
                this.memory.partner = partner.name;
                partner.memory.partner = this.name;
                return partner;
            }
        }
        return undefined;
    }
    findSwarm(partners, maxByRole, tickDifference = DEFAULT_SWARM_TICK_DIFFERENCE) {
        if (this.memory.swarm) {
            return this.memory.swarm;
        }
        else {
            const partnersBySwarm = _.groupBy(partners, partner => partner.memory.swarm);
            for (const swarmRef in partnersBySwarm) {
                if (swarmRef == undefined || swarmRef == 'undefined')
                    continue;
                if (_.all(partnersBySwarm[swarmRef], c => Math.abs((this.ticksToLive || CREEP_LIFE_TIME)
                    - (c.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)) {
                    const swarmCreepsByRole = _.groupBy(partnersBySwarm[swarmRef], c => c.memory.role);
                    if ((swarmCreepsByRole[this.memory.role] || []).length + 1 <= maxByRole[this.memory.role]) {
                        this.memory.swarm = swarmRef;
                        return swarmRef;
                    }
                }
            }
            const newSwarmRef = randomHex(6);
            this.memory.swarm = newSwarmRef;
            return newSwarmRef;
        }
    }
    doMedicActions(roomName) {
        if (!this.safelyInRoom(roomName)) {
            this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
            return true;
        }
        const target = CombatTargeting.findClosestHurtFriendly(this);
        if (target) {
            const range = this.pos.getRangeTo(target);
            if (range > 1) {
                this.goToSameRoom(target, { movingTarget: true });
            }
            if (range <= 1) {
                this.heal(target);
            }
            else if (range <= 3) {
                this.rangedHeal(target);
            }
        }
        else {
            this.park();
        }
        return !!target;
    }
    healSelfIfPossible() {
        if (this.canExecute('heal')
            && (this.hits < this.hitsMax || this.pos.findInRange(this.room.hostiles, 3).length > 0)) {
            return this.heal(this);
        }
        return undefined;
    }
    attackAndChase(target) {
        let ret;
        if (this.pos.isNearTo(target)) {
            ret = this.attack(target);
            this.move(this.pos.getDirectionTo(target));
            return ret;
        }
        this.goToSameRoom(target, { movingTarget: (this.pos.getRangeTo(target.pos) > 10 && target instanceof Creep) });
        return ERR_NOT_IN_RANGE;
    }
    autoMelee(possibleTargets = this.room.hostiles) {
        const target = CombatTargeting.findBestCreepTargetInRange(this, 1, possibleTargets)
            || CombatTargeting.findBestStructureTargetInRange(this, 1);
        this.debug(`Melee target: ${target}`);
        if (target) {
            return this.attack(target);
        }
        return undefined;
    }
    autoRanged(possibleTargets = this.room.hostiles, allowMassAttack = true) {
        const target = CombatTargeting.findBestCreepTargetInRange(this, 3, possibleTargets)
            || CombatTargeting.findBestStructureTargetInRange(this, 3, false);
        this.debug(`Ranged target: ${target}`);
        if (target) {
            if (allowMassAttack
                && CombatIntel.getMassAttackDamage(this, possibleTargets) > CombatIntel.getRangedAttackDamage(this)) {
                return this.rangedMassAttack();
            }
            else {
                return this.rangedAttack(target);
            }
        }
        return undefined;
    }
    kiteIfNecessary() {
        const nearbyHostiles = _.filter(this.room.dangerousHostiles, c => this.pos.inRangeToXY(c.pos.x, c.pos.y, 2));
        if (nearbyHostiles.length && !this.inRampart) {
            this.rangedMassAttack();
            return this.kite(nearbyHostiles);
        }
        return undefined;
    }
    autoHeal(allowRangedHeal = true, friendlies = this.room.friendlies) {
        const target = CombatTargeting.findBestHealingTargetInRange(this, allowRangedHeal ? RANGES$1.RANGED_HEAL : RANGES$1.HEAL, friendlies);
        if (!target)
            return undefined;
        this.debug(`Heal target: ${target}`);
        if (this.pos.getRangeTo(target) <= RANGES$1.HEAL) {
            return this.heal(target);
        }
        else if (allowRangedHeal && this.pos.getRangeTo(target) <= RANGES$1.RANGED_HEAL) {
            return this.rangedHeal(target);
        }
    }
    autoSkirmish(roomName, verbose = false) {
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee();
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        const goals = GoalFinder.skirmishGoals(this);
        this.debug(JSON.stringify(goals));
        return Movement.combatMove(this, goals.approach, goals.avoid);
    }
    autoCombat(roomName, verbose = false, preferredRange, options) {
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee();
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        const target = CombatTargeting.findTarget(this);
        const preferRanged = this.getActiveBodyparts(RANGED_ATTACK) > this.getActiveBodyparts(ATTACK);
        const targetRange = preferredRange || preferRanged ? 3 : 1;
        this.debug(`Fighting: ${target}, Range: ${targetRange}`);
        if (target) {
            const avoid = [];
            if (preferRanged) {
                const meleeHostiles = _.filter(this.room.hostiles, h => CombatIntel.getAttackDamage(h) > 0);
                for (const hostile of meleeHostiles) {
                    avoid.push({ pos: hostile.pos, range: targetRange - 1 });
                }
                if (this.kiteIfNecessary()) {
                    return;
                }
            }
            return Movement.combatMove(this, [{ pos: target.pos, range: targetRange }], avoid, options);
        }
        return undefined;
    }
    autoBunkerCombat(roomName, verbose = false) {
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee();
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        const target = CombatTargeting.findTarget(this, this.colony ? this.room.playerHostiles
            .filter(creep => creep.pos.getRangeTo(this.colony.pos) <= 9) : this.room.dangerousHostiles);
        if (target) {
            return Movement.combatMove(this, [{ pos: target.pos, range: 1 }], [], {
                preferRamparts: true,
                requireRamparts: true
            });
        }
        return undefined;
    }
    needsToRecover(recoverThreshold = CombatIntel.minimumDamageTakenMultiplier(this.creep) < 1 ? 0.85 : 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = this.hits < this.hitsMax * reengageThreshold;
        }
        else {
            recovering = this.hits < this.hitsMax * recoverThreshold;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    recover() {
        if (this.pos.findInRange(this.room.hostiles, 5).length > 0 || this.room.towers.length > 0) {
            this.memory.lastInDanger = Game.time;
        }
        const goals = GoalFinder.retreatGoals(this);
        const result = Movement.combatMove(this, goals.approach, goals.avoid, { allowExit: true });
        if (result == NO_ACTION && this.pos.isEdge) {
            if (Game.time < this.memory.lastInDanger + 3) {
                return this.moveOffExit();
            }
        }
        return result;
    }
};
CombatZerg = __decorate([
    profile
], CombatZerg);

function hasColony(initializer) {
    return initializer.colony != undefined;
}
const DEFAULT_PRESPAWN = 40;
const MAX_SPAWN_REQUESTS = 100;
const getDefaultOverlordMemory = () => ({});
let Overlord = class Overlord {
    constructor(initializer, name, priority, memDefaults = getDefaultOverlordMemory) {
        this.initializer = initializer;
        this.memory = Mem.wrap(initializer.memory, name, memDefaults);
        this.room = initializer.room;
        this.priority = priority;
        this.name = name;
        this.ref = initializer.ref + '>' + name;
        this.pos = initializer.pos;
        this.colony = hasColony(initializer) ? initializer.colony : initializer;
        this.spawnGroup = undefined;
        this._creeps = {};
        this._zerg = {};
        this._combatZerg = {};
        this.recalculateCreeps();
        this.creepUsageReport = _.mapValues(this._creeps, _ => undefined);
        Overmind.overlords[this.ref] = this;
        Overmind.overseer.registerOverlord(this);
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.ref + ']</a>';
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    refresh() {
        this.memory = Mem.wrap(this.initializer.memory, this.name);
        this.room = Game.rooms[this.pos.roomName];
        this.recalculateCreeps();
        for (const role in this._creeps) {
            for (const creep of this._creeps[role]) {
                if (Overmind.zerg[creep.name]) {
                    Overmind.zerg[creep.name].refresh();
                }
                else {
                    log.warning(`${this.print}: could not find and refresh zerg with name ${creep.name}!`);
                }
            }
        }
    }
    recalculateCreeps() {
        this._creeps = _.mapValues(Overmind.cache.overlords[this.ref], creepsOfRole => _.map(creepsOfRole, creepName => Game.creeps[creepName]));
        for (const role in this._zerg) {
            this.synchronizeZerg(role);
        }
        for (const role in this._combatZerg) {
            this.synchronizeCombatZerg(role);
        }
    }
    get isSuspended() {
        if (this.memory.suspend) {
            if (this.memory.suspend.endTick) {
                if (Game.time < this.memory.suspend.endTick) {
                    return true;
                }
                else {
                    delete this.memory.suspend;
                    return false;
                }
            }
            if (this.memory.suspend.condition) {
                log.error('NOT IMPLEMENTED');
                const { fn, freq } = this.memory.suspend.condition;
                if (Game.time % freq == 0) {
                    const condition = new Function(fn);
                }
            }
        }
        return false;
    }
    suspendFor(ticks) {
        this.memory.suspend = {
            endTick: Game.time + ticks
        };
    }
    suspendUntil(endTick) {
        this.memory.suspend = {
            endTick: endTick
        };
    }
    get profilingActive() {
        if (this.memory["S"]) {
            if (this.memory["S"].end) {
                if (Game.time > this.memory["S"].end) {
                    this.finishProfiling();
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    startProfiling(ticks) {
        if (!this.memory["S"]) {
            this.memory["S"] = {
                start: Game.time,
                cpu: 0,
                spawnCost: 0,
                deaths: 0,
            };
            if (ticks) {
                this.memory["S"].end = Game.time + ticks;
            }
        }
        else {
            log.alert(`Overlord ${this.print} is already being profiled!`);
        }
    }
    finishProfiling(verbose = true) {
        if (!this.memory["S"]) {
            log.error(`Overlord ${this.print} is not being profiled, finishProfiling() invalid!`);
            return;
        }
        if (verbose) {
            log.alert(`Profiling finished for overlord ${this.print}. Results:\n` +
                JSON.stringify(this.memory["S"]));
        }
        delete this.memory["S"];
    }
    zerg(role, opts = {}) {
        if (!this._zerg[role]) {
            this._zerg[role] = [];
            this.synchronizeZerg(role, opts.notifyWhenAttacked);
        }
        return this._zerg[role];
    }
    synchronizeZerg(role, notifyWhenAttacked) {
        const zergNames = _.zipObject(_.map(this._zerg[role] || [], zerg => [zerg.name, true]));
        const creepNames = _.zipObject(_.map(this._creeps[role] || [], creep => [creep.name, true]));
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                this._zerg[role].push(Overmind.zerg[creep.name] || new Zerg(creep, notifyWhenAttacked));
            }
        }
        const removeZergNames = [];
        for (const zerg of this._zerg[role]) {
            if (!creepNames[zerg.name]) {
                removeZergNames.push(zerg.name);
            }
        }
        _.remove(this._zerg[role], deadZerg => removeZergNames.includes(deadZerg.name));
    }
    getAllZerg() {
        const allZerg = [];
        for (const role in this._creeps) {
            for (const zerg of this.zerg(role)) {
                allZerg.push(zerg);
            }
        }
        return allZerg;
    }
    combatZerg(role, opts = {}) {
        if (!this._combatZerg[role]) {
            this._combatZerg[role] = [];
            this.synchronizeCombatZerg(role, opts.notifyWhenAttacked);
        }
        return this._combatZerg[role];
    }
    synchronizeCombatZerg(role, notifyWhenAttacked) {
        const zergNames = _.zipObject(_.map(this._combatZerg[role] || [], zerg => [zerg.name, true]));
        const creepNames = _.zipObject(_.map(this._creeps[role] || [], creep => [creep.name, true]));
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                if (Overmind.zerg[creep.name] && Overmind.zerg[creep.name].isCombatZerg) {
                    this._combatZerg[role].push(Overmind.zerg[creep.name]);
                }
                else {
                    this._combatZerg[role].push(new CombatZerg(creep, notifyWhenAttacked));
                }
            }
        }
        const removeZergNames = [];
        for (const zerg of this._combatZerg[role]) {
            if (!creepNames[zerg.name]) {
                removeZergNames.push(zerg.name);
            }
        }
        _.remove(this._combatZerg[role], deadZerg => removeZergNames.includes(deadZerg.name));
    }
    getAllCombatZerg() {
        const allCombatZerg = [];
        for (const role in this._creeps) {
            for (const combatZerg of this.combatZerg(role)) {
                allCombatZerg.push(combatZerg);
            }
        }
        return allCombatZerg;
    }
    get outpostIndex() {
        return _.findIndex(this.colony.roomNames, roomName => roomName == this.pos.roomName);
    }
    reassignIdleCreeps(role, maxPerTick = 1) {
        const idleCreeps = _.filter(this.colony.getCreepsByRole(role), creep => !getOverlord(creep));
        let reassigned = 0;
        for (const creep of idleCreeps) {
            setOverlord(creep, this);
            reassigned++;
            if (reassigned >= maxPerTick) {
                break;
            }
        }
        return reassigned > 0;
    }
    creepReport(role, currentAmt, neededAmt) {
        this.creepUsageReport[role] = [currentAmt, neededAmt];
    }
    requestSquad(setups, opts = {}) {
        log.warning(`Overlord.requestSquad() is not finished yet!`);
        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN });
        const spawner = this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;
        if (spawner) {
            if (setups.length > 3) {
                log.warning(`Requesting squads of >3 is not advisable`);
            }
            const request = {
                setup: _.head(setups),
                overlord: this,
                priority: opts.priority,
                partners: _.tail(setups),
            };
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        }
        else {
            if (Game.time % 100 == 0) {
                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);
            }
        }
    }
    requestCreep(setup, opts = {}) {
        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN });
        const spawner = this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;
        if (spawner) {
            const request = {
                setup: setup,
                overlord: this,
                priority: opts.priority,
            };
            if (opts.partners) {
                request.partners = opts.partners;
            }
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        }
        else {
            if (Game.time % 100 == 0) {
                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);
            }
        }
    }
    lifetimeFilter(creeps, prespawn = DEFAULT_PRESPAWN, spawnDistance) {
        if (!spawnDistance) {
            spawnDistance = 0;
            if (this.spawnGroup) {
                const distances = _.take(_.sortBy(this.spawnGroup.memory.distances), 2);
                spawnDistance = (_.sum(distances) / distances.length) || 0;
            }
            else if (this.colony.hatchery) {
                spawnDistance = Pathing.distance(this.pos, this.colony.hatchery.pos) || 0;
            }
            if (this.colony.state.isIncubating && this.colony.spawnGroup) {
                spawnDistance += this.colony.spawnGroup.stats.avgDistance;
            }
        }
        return _.filter(creeps, creep => creep.ticksToLive > CREEP_SPAWN_TIME * creep.body.length + spawnDistance + prespawn ||
            creep.spawning || (!creep.spawning && !creep.ticksToLive));
    }
    wishlist(quantity, setup, opts = {}) {
        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN, reassignIdle: false });
        if (this.shouldSpawnAt && this.shouldSpawnAt > Game.time) {
            log.info(`Disabled spawning for ${this.print} for another ${this.shouldSpawnAt - Game.time} ticks`);
            return;
        }
        let creepQuantity;
        if (opts.noLifetimeFilter) {
            creepQuantity = (this._creeps[setup.role] || []).length;
        }
        else if (_.has(this.initializer, 'waypoints')) {
            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn, 500).length;
        }
        else {
            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn).length;
        }
        let spawnQuantity = quantity - creepQuantity;
        if (opts.reassignIdle && spawnQuantity > 0) {
            const idleCreeps = _.filter(this.colony.getCreepsByRole(setup.role), creep => !getOverlord(creep));
            for (let i = 0; i < Math.min(idleCreeps.length, spawnQuantity); i++) {
                setOverlord(idleCreeps[i], this);
                spawnQuantity--;
            }
        }
        if (spawnQuantity > MAX_SPAWN_REQUESTS) {
            log.error(`Too many requests (${spawnQuantity}) for ${setup.role}s submitted by ${this.print}! (Check for errors.)`);
        }
        else {
            for (let i = 0; i < spawnQuantity; i++) {
                if (i >= 1 && opts.spawnOneAtATime)
                    break;
                this.requestCreep(setup, opts);
            }
        }
        this.creepReport(setup.role, creepQuantity, quantity);
    }
    preInit() {
        const allZerg = _.flatten([..._.values(this._zerg), ..._.values(this._combatZerg)]);
        for (const zerg of allZerg) {
            if (zerg.needsBoosts) {
                const colony = Overmind.colonies[zerg.room.name];
                const evolutionChamber = colony ? colony.evolutionChamber : undefined;
                if (evolutionChamber) {
                    evolutionChamber.requestBoosts(zerg.getNeededBoosts());
                }
            }
        }
    }
    finish(successful) {
        for (const zerg of this.getAllZerg()) {
            zerg.reassign(this.colony.overlords.default);
        }
    }
    handleBoosting(zerg) {
        const colony = Overmind.colonies[zerg.room.name];
        const evolutionChamber = colony ? colony.evolutionChamber : undefined;
        if (evolutionChamber) {
            if (!zerg.needsBoosts) {
                log.error(`Overlord.handleBoosting() called for ${zerg.print}, but no boosts needed!`);
            }
            const neededBoosts = zerg.getNeededBoosts();
            const neededBoostResources = _.keys(neededBoosts);
            const [moveBoosts, nonMoveBoosts] = _.partition(neededBoostResources, resource => Abathur.isMoveBoost(resource));
            for (const boost of [...moveBoosts, ...nonMoveBoosts]) {
                const boostLab = _.find(evolutionChamber.boostingLabs, lab => lab.mineralType == boost);
                if (boostLab) {
                    zerg.task = Tasks.getBoosted(boostLab, boost);
                    return;
                }
            }
        }
    }
    autoRun(roleCreeps, taskHandler, fleeCallback) {
        for (const creep of roleCreeps) {
            if (creep.spawning) {
                continue;
            }
            if (!!fleeCallback) {
                if (fleeCallback(creep))
                    continue;
            }
            if (creep.isIdle) {
                if (creep.needsBoosts) {
                    this.handleBoosting(creep);
                }
                else {
                    taskHandler(creep);
                }
            }
            creep.run();
        }
    }
    visuals() {
    }
};
Overlord = __decorate([
    profile
], Overlord);

var DirectiveNukeResponse_1;
let DirectiveNukeResponse = DirectiveNukeResponse_1 = class DirectiveNukeResponse extends Directive {
    constructor(flag) {
        super(flag, colony => colony.name == Directive.getPos(flag).roomName
            && colony.level >= DirectiveNukeResponse_1.requiredRCL);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.nukes = this.room.find(FIND_NUKES);
        if (this.nukes.length > 0) {
            this.colony.state.isBeingNuked = true;
        }
    }
    spawnMoarOverlords() {
    }
    init() {
        for (const nuke of this.nukes) {
            this.alert(`Nuclear impact in ${nuke.timeToLand}`, NotifierPriority.Critical);
        }
    }
    static shouldReinforceLocation(pos) {
        const dontReinforce = [STRUCTURE_ROAD, STRUCTURE_RAMPART, STRUCTURE_WALL];
        const colony = Overmind.colonies[pos.roomName];
        if (colony && colony.assets.energy < 200000) {
            dontReinforce.push(STRUCTURE_EXTENSION);
        }
        return _.filter(pos.lookFor(LOOK_STRUCTURES), s => !_.contains(dontReinforce, s.structureType)).length > 0;
    }
    run() {
        if (Game.time % 50 == 0) {
            if (this.nukes.length > 0) {
                for (const nuke of this.nukes) {
                    const rampartPositions = _.filter(nuke.pos.getPositionsInRange(2), pos => DirectiveNukeResponse_1.shouldReinforceLocation(pos));
                    for (const pos of rampartPositions) {
                        if (!pos.lookForStructure(STRUCTURE_RAMPART)) {
                            const res = pos.createConstructionSite(STRUCTURE_RAMPART);
                            if (res == ERR_FULL)
                                break;
                        }
                    }
                    log.alert(`Incoming nuke at ${nuke.pos.print}! Time until impact: ${nuke.timeToLand}`);
                }
            }
            else {
                this.remove();
            }
        }
    }
};
DirectiveNukeResponse.directiveName = 'nukeResponse';
DirectiveNukeResponse.color = COLOR_ORANGE;
DirectiveNukeResponse.secondaryColor = COLOR_BLUE;
DirectiveNukeResponse.requiredRCL = 6;
DirectiveNukeResponse = DirectiveNukeResponse_1 = __decorate([
    profile
], DirectiveNukeResponse);

var WorkerOverlord_1;
let WorkerOverlord = WorkerOverlord_1 = class WorkerOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.work) {
        super(colony, 'worker', priority);
        this.fortifyBarriers = $.structures(this, 'fortifyBarriers', () => _.sortBy(_.filter(this.room.barriers, s => s.hits < WorkerOverlord_1.settings.barrierHits[this.colony.level]
            && this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(s.pos)), s => s.hits), 25);
        this.criticalBarriers = $.structures(this, 'criticalBarriers', () => _.filter(this.fortifyBarriers, barrier => barrier.hits < WorkerOverlord_1.settings.barrierHits.critical), 10);
        this.repairStructures = $.structures(this, 'repairStructures', () => _.filter(this.colony.repairables, structure => {
            if (structure.structureType == STRUCTURE_CONTAINER) {
                if (structure.pos.roomName != this.colony.name) {
                    return false;
                }
                return structure.hits < 0.5 * structure.hitsMax;
            }
            if (!this.colony.roomPlanner.structureShouldBeHere(structure.structureType, structure.pos))
                return false;
            return structure.hits < structure.hitsMax;
        }));
        this.dismantleStructures = [];
        const homeRoomName = this.colony.room.name;
        const defcon = this.colony.defcon;
        const room = this.colony.room;
        const level = this.colony.controller.level;
        this.constructionSites = _.filter(this.colony.constructionSites, function (site) {
            const structureAmount = room[site.structureType + 's'] ? room[site.structureType + 's'].length :
                (room[site.structureType] ? 1 : 0);
            if (structureAmount >= CONTROLLER_STRUCTURES[site.structureType][level]) {
                return false;
            }
            if (defcon > DEFCON.safe) {
                return site.pos.roomName == homeRoomName &&
                    site.structureType != STRUCTURE_CONTAINER &&
                    site.structureType != STRUCTURE_ROAD;
            }
            else {
                if (site.pos.roomName != homeRoomName
                    && Cartographer.roomType(site.pos.roomName) == ROOMTYPE_CONTROLLER) {
                    return site.structureType != STRUCTURE_CONTAINER &&
                        !(site.room && site.room.dangerousHostiles.length > 0);
                }
                else {
                    return true;
                }
            }
        });
        this.nukeDefenseRamparts = [];
        this.nukeDefenseHitsRemaining = {};
        if (this.room.find(FIND_NUKES).length > 0) {
            for (const rampart of this.colony.room.ramparts) {
                const neededHits = this.neededRampartHits(rampart);
                if (rampart.hits < neededHits && rampart.pos.findInRange(FIND_NUKES, 2).length > 0
                    && DirectiveNukeResponse.shouldReinforceLocation(rampart.pos)) {
                    this.nukeDefenseRamparts.push(rampart);
                    Visualizer.marker(rampart.pos, { color: 'gold' });
                    this.nukeDefenseHitsRemaining[rampart.id] = Math.min(neededHits - rampart.hits, 0);
                }
            }
        }
        const totalNukeDefenseHitsRemaining = _.sum(_.values(this.nukeDefenseHitsRemaining));
        const totalFortifyHitsRemaining = _.sum(this.fortifyBarriers, barrier => Math.max(WorkerOverlord_1.settings.barrierHits[this.colony.level] - barrier.hits, 0));
        const approxRepairAmountPerLifetime = REPAIR_POWER * 50 / 3 * CREEP_LIFE_TIME;
        if (totalNukeDefenseHitsRemaining > 3 * approxRepairAmountPerLifetime ||
            totalFortifyHitsRemaining > 5 * approxRepairAmountPerLifetime) {
            this.useBoostedRepair = true;
        }
        this.workers = this.zerg(Roles.worker);
    }
    neededRampartHits(rampart) {
        let neededHits = WorkerOverlord_1.settings.barrierHits[this.colony.level];
        for (const nuke of rampart.pos.lookFor(LOOK_NUKES)) {
            neededHits += 10e6;
        }
        for (const nuke of rampart.pos.findInRange(FIND_NUKES, 2)) {
            if (nuke.pos != rampart.pos) {
                neededHits += 5e6;
            }
        }
        return neededHits;
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'repairStructures', 'dismantleStructures', 'fortifyBarriers', 'criticalBarriers', 'constructionSites', 'nukeDefenseRamparts');
    }
    wishlistWorkers() {
        let setup = this.colony.level == 1 ? Setups.workers.early : Setups.workers.default;
        const workPartsPerWorker = setup.getBodyPotential(WORK, this.colony);
        let numWorkers;
        if (this.colony.stage == ColonyStage.Larva) {
            numWorkers = $.number(this, 'numWorkers', () => {
                const MAX_WORKERS = 30;
                const energyMinedPerTick = _.sum(_.map(this.colony.miningSites, function (site) {
                    const overlord = site.overlords.mine;
                    const miningPowerAssigned = _.sum(overlord.miners, miner => miner.getActiveBodyparts(WORK));
                    const saturation = Math.min(miningPowerAssigned / overlord.miningPowerNeeded, 1);
                    return overlord.energyPerTick * saturation;
                }));
                const transporterSaturation = Math.min(this.colony.overlords.logistics.memory.transporterSaturation, 1);
                const energySpentPerTickPerWorkPart = _.filter(this.colony.constructionSites, s => s.structureType != STRUCTURE_ROAD).length > 0 ? BUILD_POWER : 1;
                const energyPerTickPerWorker = workPartsPerWorker * energySpentPerTickPerWorkPart;
                const workerUptime = 1.0;
                const numWorkers = Math.ceil((energyMinedPerTick * transporterSaturation) /
                    (energyPerTickPerWorker * workerUptime)
                    + 0.5);
                return Math.min(numWorkers, MAX_WORKERS);
            });
        }
        else {
            if (this.colony.roomPlanner.memory.relocating) {
                numWorkers = 5;
            }
            else {
                numWorkers = $.number(this, 'numWorkers', () => {
                    const MAX_WORKERS = 5;
                    if (this.nukeDefenseRamparts.length > 0) {
                        return MAX_WORKERS;
                    }
                    const buildTicks = _.sum(this.constructionSites, site => Math.max(site.progressTotal - site.progress, 0)) / BUILD_POWER;
                    const repairTicks = _.sum(this.repairStructures, structure => structure.hitsMax - structure.hits) / REPAIR_POWER;
                    const activeRooms = _.filter(this.colony.roomNames, roomName => this.colony.isRoomActive(roomName));
                    const paveTicks = _.sum(activeRooms, roomName => this.colony.roadLogistics.energyToRepave(roomName));
                    let fortifyTicks = 0;
                    const shouldFortify = this.colony.assets.energy > WorkerOverlord_1.settings.fortifyDutyThreshold;
                    if (shouldFortify) {
                        fortifyTicks = 0.25 * _.sum(this.fortifyBarriers, barrier => Math.max(0, WorkerOverlord_1.settings.barrierHits[this.colony.level]
                            - barrier.hits)) / REPAIR_POWER;
                    }
                    let numWorkers = Math.ceil(2 * (5 * buildTicks + repairTicks + paveTicks + fortifyTicks) /
                        (workPartsPerWorker * CREEP_LIFE_TIME));
                    numWorkers = Math.min(numWorkers, MAX_WORKERS);
                    if (this.colony.controller.ticksToDowngrade <= (this.colony.level >= 4 ? 10000 : 2000)) {
                        numWorkers = Math.max(numWorkers, 1);
                    }
                    return numWorkers;
                });
            }
        }
        if (this.useBoostedRepair) {
            setup = CreepSetup.boosted(setup, ['construct']);
        }
        this.wishlist(numWorkers, setup);
    }
    registerEnergyRequests() {
        if (this.colony.stage == ColonyStage.Larva) {
            for (const worker of this.workers) {
                if (worker.spawning)
                    continue;
                const workParts = worker.bodypartCounts[WORK];
                const rechargeThreshold = 25 * workParts;
                if (worker.store.energy < rechargeThreshold && worker.store.getCapacity() > rechargeThreshold && worker.task) {
                    if (worker.task.name == upgradeTaskName && !this.colony.upgradeSite.battery) {
                        this.colony.logisticsNetwork.requestInput(worker, { dAmountdt: workParts * UPGRADE_CONTROLLER_POWER });
                    }
                    else if (worker.task.name == buildTaskName) {
                        this.colony.logisticsNetwork.requestInput(worker, { dAmountdt: workParts * BUILD_POWER });
                    }
                    else if (worker.task.name == repairTaskName) {
                        this.colony.logisticsNetwork.requestInput(worker, { dAmountdt: workParts * 1 });
                    }
                    else if (worker.task.name == fortifyTaskName) {
                        this.colony.logisticsNetwork.requestInput(worker, { dAmountdt: workParts * 1 });
                    }
                }
            }
        }
    }
    init() {
        this.wishlistWorkers();
        this.registerEnergyRequests();
    }
    repairActions(worker) {
        const target = worker.pos.findClosestByMultiRoomRange(this.repairStructures);
        if (target) {
            worker.task = Tasks.repair(target);
            return true;
        }
        else {
            return false;
        }
    }
    buildActions(worker) {
        const groupedSites = _.groupBy(this.constructionSites, site => site.structureType);
        for (const structureType of BuildPriorities) {
            if (groupedSites[structureType]) {
                const target = worker.pos.findClosestByMultiRoomRange(groupedSites[structureType]);
                if (target) {
                    worker.task = Tasks.build(target);
                    return true;
                }
            }
        }
        return false;
    }
    dismantleActions(worker) {
        const targets = _.filter(this.dismantleStructures, s => (s.targetedBy || []).length < 3);
        const target = worker.pos.findClosestByMultiRoomRange(targets);
        if (target) {
            _.remove(this.dismantleStructures, s => s == target);
            worker.task = Tasks.dismantle(target);
            return true;
        }
        else {
            return false;
        }
    }
    pavingActions(worker) {
        const roomToRepave = this.colony.roadLogistics.workerShouldRepave(worker);
        this.colony.roadLogistics.registerWorkerAssignment(worker, roomToRepave);
        const pavingManifest = this.colony.roadLogistics.buildPavingManifest(worker, roomToRepave);
        if (pavingManifest) {
            worker.task = pavingManifest;
            return true;
        }
        else {
            return false;
        }
    }
    fortifyActions(worker, fortifyStructures = this.fortifyBarriers) {
        let lowBarriers;
        const highestBarrierHits = _.max(_.map(fortifyStructures, structure => structure.hits));
        if (highestBarrierHits > WorkerOverlord_1.settings.hitTolerance) {
            const lowestBarrierHits = _.min(_.map(fortifyStructures, structure => structure.hits));
            lowBarriers = _.filter(fortifyStructures, structure => structure.hits <= lowestBarrierHits +
                WorkerOverlord_1.settings.hitTolerance);
        }
        else {
            const numBarriersToConsider = 5;
            lowBarriers = _.take(fortifyStructures, numBarriersToConsider);
        }
        const target = worker.pos.findClosestByMultiRoomRange(lowBarriers);
        if (target) {
            worker.task = Tasks.fortify(target);
            return true;
        }
        else {
            return false;
        }
    }
    nukeFortifyActions(worker, fortifyStructures = this.nukeDefenseRamparts) {
        const target = minBy(fortifyStructures, rampart => {
            const structuresUnderRampart = rampart.pos.lookFor(LOOK_STRUCTURES);
            return _.min(_.map(structuresUnderRampart, structure => {
                const priority = _.findIndex(FortifyPriorities, sType => sType == structure.structureType);
                if (priority >= 0) {
                    return priority;
                }
                else {
                    return 999;
                }
            }));
        });
        if (target) {
            worker.task = Tasks.fortify(target);
            return true;
        }
        else {
            return false;
        }
    }
    upgradeActions(worker) {
        if ((!this.colony.controller.signedByMe && !this.colony.controller.signedByScreeps)) {
            worker.task = Tasks.signController(this.colony.controller);
            return true;
        }
        worker.task = Tasks.upgrade(this.room.controller);
        return true;
    }
    handleWorker(worker) {
        if (worker.carry.energy == 0) {
            const workerWithdrawLimit = this.colony.stage == ColonyStage.Larva ? 200 : 100;
            worker.task = Tasks.recharge(workerWithdrawLimit);
            return;
        }
        const downgradeLevel = CONTROLLER_DOWNGRADE[this.colony.controller.level] *
            (this.colony.controller.level < 4 ? .3 : .7);
        if ((!this.colony.controller.upgradeBlocked || this.colony.controller.upgradeBlocked < 30)
            && (this.colony.controller.ticksToDowngrade <= downgradeLevel
                || this.colony.controller.progress > this.colony.controller.progressTotal)) {
            if (this.upgradeActions(worker))
                return;
        }
        if (this.repairStructures.length > 0 && this.colony.defcon == DEFCON.safe) {
            if (this.repairActions(worker))
                return;
        }
        if (this.criticalBarriers.length > 0) {
            if (this.fortifyActions(worker, this.criticalBarriers))
                return;
        }
        if (this.constructionSites.length > 0) {
            if (this.buildActions(worker))
                return;
        }
        if (this.nukeDefenseRamparts.length > 0 && !this.colony.state.isRebuilding) {
            if (this.nukeFortifyActions(worker, this.nukeDefenseRamparts))
                return;
        }
        if (this.colony.roadLogistics.workerShouldRepave(worker) && this.colony.defcon == DEFCON.safe) {
            if (this.pavingActions(worker))
                return;
        }
        if (this.dismantleStructures.length > 0 && this.colony.defcon == DEFCON.safe) {
            if (this.dismantleActions(worker))
                return;
        }
        if (this.fortifyBarriers.length > 0) {
            if (this.fortifyActions(worker, this.fortifyBarriers))
                return;
        }
        if ((this.colony.level < 8 || this.colony.upgradeSite.overlord.upgraders.length == 0)
            && (this.colony.defcon == DEFCON.safe || this.colony.level < 3)) {
            if (this.upgradeActions(worker))
                return;
        }
    }
    run() {
        this.autoRun(this.workers, worker => this.handleWorker(worker), worker => worker.flee(worker.room.fleeDefaults, { invalidateTask: true }));
    }
};
WorkerOverlord.settings = {
    barrierHits: {
        critical: 2500,
        1: 3e+3,
        2: 3e+3,
        3: 1e+4,
        4: 5e+4,
        5: 1e+5,
        6: 5e+5,
        7: 2e+6,
        8: 2.1e+7,
    },
    hitTolerance: 100000,
    fortifyDutyThreshold: 250000,
};
WorkerOverlord = WorkerOverlord_1 = __decorate([
    profile
], WorkerOverlord);

const TERMINAL_THRESHOLDS = {
    energy: {
        target: 50000,
        tolerance: 5000,
    },
    power: {
        target: 2500,
        tolerance: 2500
    },
    ops: {
        target: 2500,
        tolerance: 2500,
    },
    baseMinerals: {
        target: 6500,
        tolerance: 500,
    },
    intermediateReactants: {
        target: 3500,
        tolerance: 500
    },
    boosts: {
        target: 3500,
        tolerance: 500,
    }
};
function getTerminalThresholds(resource) {
    let thresholds;
    if (resource == RESOURCE_ENERGY) {
        thresholds = TERMINAL_THRESHOLDS.energy;
    }
    else if (resource == RESOURCE_POWER) {
        thresholds = TERMINAL_THRESHOLDS.power;
    }
    else if (resource == RESOURCE_OPS) {
        thresholds = TERMINAL_THRESHOLDS.ops;
    }
    else if (Abathur.isBaseMineral(resource)) {
        thresholds = TERMINAL_THRESHOLDS.baseMinerals;
    }
    else if (Abathur.isIntermediateReactant(resource) || resource == RESOURCE_GHODIUM) {
        thresholds = TERMINAL_THRESHOLDS.intermediateReactants;
    }
    else if (Abathur.isBoost(resource)) {
        thresholds = TERMINAL_THRESHOLDS.boosts;
    }
    return thresholds;
}
const TERMINAL_THRESHOLDS_ALL = _.zipObject(RESOURCES_ALL, _.map(RESOURCES_ALL, resource => getTerminalThresholds(resource)));
let CommandCenterOverlord = class CommandCenterOverlord extends Overlord {
    constructor(commandCenter, priority = OverlordPriority.core.manager) {
        super(commandCenter, 'manager', priority);
        this.commandCenter = commandCenter;
        this.mode = this.colony.layout;
        this.managers = this.zerg(Roles.manager);
        if (this.colony.bunker) {
            const anchor = this.colony.bunker.anchor;
            $.set(this, 'managerRepairTarget', () => minBy(_.filter(anchor.findInRange(anchor.room.barriers, 3), b => b.hits < WorkerOverlord.settings.barrierHits[this.colony.level]), b => b.hits));
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'managerRepairTarget');
    }
    init() {
        let setup = Setups.managers.default;
        let spawnRequestOptions = {};
        if (this.colony.layout == 'twoPart') {
            setup = Setups.managers.twoPart;
        }
        if (this.colony.bunker && this.colony.bunker.coreSpawn && this.colony.level == 8
            && !this.colony.roomPlanner.memory.relocating) {
            setup = Setups.managers.stationary;
            spawnRequestOptions = {
                spawn: this.colony.bunker.coreSpawn,
                directions: [this.colony.bunker.coreSpawn.pos.getDirectionTo(this.colony.bunker.anchor)]
            };
        }
        this.wishlist(1, setup, { options: spawnRequestOptions });
    }
    unloadCarry(manager) {
        if (manager.store.getUsedCapacity() == 0) {
            return false;
        }
        else {
            manager.debug(`Unloading carry: ${JSON.stringify(manager.carry)}`);
            manager.task = Tasks.transferAll(this.commandCenter.storage);
            return true;
        }
    }
    supplyActions(manager) {
        manager.debug('supplyActions');
        const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, 'supply');
        if (request) {
            const amount = Math.min(request.amount, manager.carryCapacity);
            const resource = request.resourceType;
            if (manager.store[request.resourceType] >= amount) {
                manager.task = Tasks.transfer(request.target, resource, amount);
                return true;
            }
            else if (manager.store[request.resourceType] > 0) {
                manager.task = Tasks.transfer(request.target, resource, manager.store[request.resourceType]);
                return true;
            }
            else {
                if (this.unloadCarry(manager)) {
                    return true;
                }
                const storage = this.commandCenter.storage;
                const terminal = this.commandCenter.terminal;
                let withdrawFrom;
                let withdrawAmount = amount;
                if (storage.store[resource] > 0) {
                    withdrawFrom = storage;
                    withdrawAmount = Math.min(amount, storage.store[resource]);
                }
                else if (terminal && terminal.store[resource] > 0) {
                    withdrawFrom = terminal;
                    withdrawAmount = Math.min(amount, terminal.store[resource]);
                }
                if (withdrawFrom) {
                    manager.task = Tasks.chain([Tasks.withdraw(withdrawFrom, resource, withdrawAmount),
                        Tasks.transfer(request.target, resource, withdrawAmount)]);
                    return true;
                }
                else {
                    log.warning(`${manager.print}: could not fulfilll supply request for ${resource}!`);
                    return false;
                }
            }
        }
        else {
            return false;
        }
    }
    withdrawActions(manager) {
        manager.debug('withdrawActions');
        const freeCapacity = manager.store.getFreeCapacity();
        if (freeCapacity > 0) {
            const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, 'withdraw');
            if (request) {
                const amount = Math.min(request.amount, freeCapacity);
                manager.task = Tasks.withdraw(request.target, request.resourceType, amount);
                return true;
            }
        }
        else {
            manager.task = Tasks.transferAll(this.commandCenter.terminal || this.commandCenter.storage);
            return true;
        }
        return false;
    }
    balanceStorageAndTerminal(manager) {
        manager.debug('balanceStorageAndTerminal');
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal)
            return false;
        const roomSellOrders = Overmind.tradeNetwork.getExistingOrders(ORDER_SELL, 'any', this.colony.name);
        for (const resourceType in this.colony.assets) {
            const resource = resourceType;
            if (this.colony.assets[resource] <= 0)
                continue;
            const thresholds = TERMINAL_THRESHOLDS_ALL[resource];
            if (!thresholds)
                continue;
            let { target, tolerance } = thresholds;
            if (roomSellOrders.length > 0) {
                const sellOrderForResource = _.find(roomSellOrders, order => order.resourceType == resourceType);
                if (sellOrderForResource) {
                    target = Math.max(target, sellOrderForResource.remainingAmount);
                }
            }
            if (terminal.store[resource] > target + tolerance && storage.store.getFreeCapacity(resource) > 0) {
                manager.debug(`Moving ${resource} from terminal into storage`);
                if (this.unloadCarry(manager)) {
                    return true;
                }
                const transferAmount = Math.min(terminal.store[resource] - target, storage.store.getFreeCapacity(resource), manager.carryCapacity);
                manager.task = Tasks.chain([Tasks.withdraw(terminal, resource, transferAmount),
                    Tasks.transfer(storage, resource, transferAmount)]);
                return true;
            }
            if (terminal.store[resource] < target - tolerance && storage.store[resource] > 0) {
                manager.debug(`Moving ${resource} from storage into terminal`);
                if (this.unloadCarry(manager)) {
                    return true;
                }
                const transferAmount = Math.min(target - terminal.store[resource], storage.store[resource], manager.carryCapacity);
                manager.task = Tasks.chain([Tasks.withdraw(storage, resource, transferAmount),
                    Tasks.transfer(terminal, resource, transferAmount)]);
                return true;
            }
        }
        return false;
    }
    moveEnergyFromRebuildingTerminal(manager) {
        manager.debug('moveEnergyFromRebuildingTerminal');
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal) {
            return false;
        }
        if (storage.energy < Energetics.settings.storage.energy.destroyTerminalThreshold) {
            if (this.unloadCarry(manager)) {
                return true;
            }
            manager.task = Tasks.chain([Tasks.withdraw(terminal), Tasks.transfer(storage)]);
            return true;
        }
        return false;
    }
    pickupActions(manager, tombstonesOnly = true) {
        manager.debug('pickupActions');
        const tombstones = manager.pos.lookFor(LOOK_TOMBSTONES);
        const tombstone = _.first(tombstones);
        if (tombstone) {
            manager.task = Tasks.chain([Tasks.withdrawAll(tombstone), Tasks.transferAll(this.commandCenter.storage)]);
            return true;
        }
        if (tombstonesOnly) {
            return false;
        }
        const resources = manager.pos.lookFor(LOOK_RESOURCES);
        const resource = _.first(resources);
        if (resource) {
            manager.task = Tasks.chain([Tasks.pickup(resource), Tasks.transferAll(this.commandCenter.storage)]);
            return true;
        }
        return false;
    }
    deathActions(manager) {
        manager.debug('deathActions');
        const nearbyManagers = _.filter(this.managers, manager => manager.pos.inRangeTo(this.commandCenter.pos, 3)
            && (manager.ticksUntilSpawned || 0) <= 10);
        if (nearbyManagers.length > 1) {
            if (manager.store.getUsedCapacity() > 0) {
                this.unloadCarry(manager);
            }
            else {
                const nearbySpawn = _.first(manager.pos.findInRange(manager.room.spawns, 1));
                if (nearbySpawn) {
                    nearbySpawn.recycleCreep(manager.creep);
                }
                else {
                    manager.suicide();
                }
            }
            return true;
        }
        return false;
    }
    handleManager(manager) {
        if (manager.ticksToLive < 150) {
            if (this.deathActions(manager))
                return;
        }
        if (this.pickupActions(manager))
            return;
        if (this.colony.state.isRebuilding) {
            if (this.moveEnergyFromRebuildingTerminal(manager))
                return;
        }
        if (this.colony.state.isEvacuating) {
            if (this.balanceStorageAndTerminal(manager))
                return;
        }
        if (this.commandCenter.transportRequests.needsWithdrawing(Priority.Normal)) {
            if (this.withdrawActions(manager))
                return;
        }
        if (this.commandCenter.transportRequests.needsSupplying(Priority.Normal)) {
            if (this.supplyActions(manager))
                return;
        }
        if (!this.colony.state.isEvacuating) {
            if (this.balanceStorageAndTerminal(manager))
                return;
        }
        if (this.commandCenter.transportRequests.needsWithdrawing()) {
            if (this.withdrawActions(manager))
                return;
        }
        if (this.commandCenter.transportRequests.needsSupplying()) {
            if (this.supplyActions(manager))
                return;
        }
    }
    idleActions(manager) {
        manager.debug('idleActions');
        if (this.mode == 'bunker' && this.managerRepairTarget && manager.getActiveBodyparts(WORK) > 0) {
            if (manager.carry.energy > 0) {
                manager.repair(this.managerRepairTarget);
            }
            else {
                const storage = this.commandCenter.storage;
                const terminal = this.commandCenter.terminal;
                const energyTarget = storage.store[RESOURCE_ENERGY] > 0 ? storage : terminal;
                if (energyTarget) {
                    manager.withdraw(energyTarget);
                }
            }
        }
        if (!manager.pos.isEqualTo(this.commandCenter.idlePos)) {
            manager.goTo(this.commandCenter.idlePos);
        }
    }
    run() {
        for (const manager of this.managers) {
            if (manager.isIdle) {
                this.handleManager(manager);
            }
            if (manager.hasValidTask) {
                manager.run();
            }
            else {
                this.idleActions(manager);
            }
        }
    }
};
CommandCenterOverlord.MAX_TERMINAL_FILLED_PERCENTAGE = .98;
CommandCenterOverlord = __decorate([
    profile
], CommandCenterOverlord);

let HiveCluster = class HiveCluster {
    constructor(colony, instantiationObject, name) {
        this.colony = colony;
        this.room = instantiationObject.room;
        this.pos = instantiationObject.pos;
        this.ref = name + '@' + this.colony.name;
        this.colony.hiveClusters.push(this);
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.ref + ']</a>';
    }
    debug(...args) {
        var _a;
        if ((_a = this.memory) === null || _a === void 0 ? void 0 : _a.debug) {
            log.alert(this.print, args);
        }
    }
};
HiveCluster = __decorate([
    profile
], HiveCluster);

var CommandCenter_1;
const MAX_OBSERVE_DISTANCE = 4;
let CommandCenter = CommandCenter_1 = class CommandCenter extends HiveCluster {
    constructor(colony, storage) {
        super(colony, storage, 'commandCenter');
        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');
        this.storage = storage;
        this.terminal = colony.terminal;
        this.powerSpawn = colony.powerSpawn;
        this.nuker = colony.nuker;
        this.observer = colony.observer;
        if (this.colony.bunker) {
            this.link = this.colony.bunker.anchor.findClosestByLimitedRange(colony.availableLinks, 1);
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.colony.bunker.anchor.findInRange(colony.towers, 1);
        }
        else {
            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.pos.findInRange(colony.towers, 3);
        }
        this.transportRequests = new TransportRequestGroup();
        this.observeRoom = undefined;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');
        $.refreshRoom(this);
        $.refresh(this, 'storage', 'terminal', 'powerSpawn', 'nuker', 'observer', 'link', 'towers');
        this.transportRequests.refresh();
        this.observeRoom = undefined;
    }
    spawnMoarOverlords() {
        if (this.link || this.terminal) {
            this.overlord = new CommandCenterOverlord(this);
        }
    }
    get idlePos() {
        if (this.colony.bunker) {
            return this.colony.bunker.anchor;
        }
        if (!this.memory.idlePos || Game.time % 25 == 0) {
            this.memory.idlePos = this.findIdlePos();
        }
        return derefRoomPosition(this.memory.idlePos);
    }
    findIdlePos() {
        const proximateStructures = _.compact([this.link,
            this.terminal,
            this.powerSpawn,
            this.nuker,
            ...this.towers]);
        const numNearbyStructures = (pos) => _.filter(proximateStructures, s => s.pos.isNearTo(pos) && !s.pos.isEqualTo(pos)).length;
        return _.last(_.sortBy(this.storage.pos.neighbors, pos => numNearbyStructures(pos)));
    }
    registerLinkTransferRequests() {
        if (this.link) {
            if (this.link.energy > CommandCenter_1.settings.linksTransmitAt) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    registerRequests() {
        if (this.colony.bunker && this.colony.bunker.coreSpawn) {
            if (this.colony.bunker.coreSpawn.energy < this.colony.bunker.coreSpawn.energyCapacity) {
                this.transportRequests.requestInput(this.colony.bunker.coreSpawn, Priority.Normal);
            }
        }
        if (this.link && this.link.energy > 0) {
            if (this.colony.linkNetwork.receive.length == 0 || this.link.cooldown > 3) {
                this.transportRequests.requestOutput(this.link, Priority.High);
            }
        }
        if (this.colony.state.bootstrapping) {
            return;
        }
        if (this.link && this.link.energy < 0.9 * this.link.energyCapacity && this.link.cooldown <= 1) {
            if (this.colony.linkNetwork.receive.length > 0) {
                this.transportRequests.requestInput(this.link, Priority.Critical);
            }
        }
        const refillTowers = _.filter(this.towers, tower => tower.energy < CommandCenter_1.settings.refillTowersBelow);
        _.forEach(refillTowers, tower => this.transportRequests.requestInput(tower, Priority.High));
        if (this.powerSpawn) {
            if (this.powerSpawn.energy < this.powerSpawn.energyCapacity * .5) {
                this.transportRequests.requestInput(this.powerSpawn, Priority.NormalLow);
            }
            else if (this.powerSpawn.power < this.powerSpawn.powerCapacity * .5 && this.terminal
                && this.terminal.store.power && this.terminal.store.power >= 100) {
                this.transportRequests.requestInput(this.powerSpawn, Priority.NormalLow, { resourceType: RESOURCE_POWER });
            }
        }
        if (this.nuker) {
            if (this.nuker.energy < this.nuker.energyCapacity && (this.storage.energy > 200000 && this.nuker.cooldown
                <= 1000 || this.storage.energy > 800000)) {
                this.transportRequests.requestInput(this.nuker, Priority.Low);
            }
            if (this.nuker.ghodium < this.nuker.ghodiumCapacity
                && this.colony.assets[RESOURCE_GHODIUM] >= LAB_MINERAL_CAPACITY) {
                this.transportRequests.requestInput(this.nuker, Priority.Low, { resourceType: RESOURCE_GHODIUM });
            }
        }
        if (this.storage && this.terminal) {
            if (this.storage.store[RESOURCE_OPS] < 3000 && this.terminal.store[RESOURCE_OPS] > 100) {
                this.transportRequests.requestInput(this.storage, Priority.Normal, { resourceType: RESOURCE_OPS });
            }
        }
    }
    requestRoomObservation(roomName) {
        this.observeRoom = roomName;
    }
    runObserver() {
        if (!this.observer)
            return;
        if (this.observeRoom) {
            this.observer.observeRoom(this.observeRoom);
            return;
        }
        if (CommandCenter_1.settings.enableIdleObservation && Game.time % 1000 < 100) {
            const axisLength = MAX_OBSERVE_DISTANCE * 2 + 1;
            const dx = Game.time % axisLength - MAX_OBSERVE_DISTANCE;
            const dy = Math.floor((Game.time % axisLength ** 2) / axisLength) - MAX_OBSERVE_DISTANCE;
            if (dx == 0 && dy == 0) {
                return;
            }
            const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);
            this.observer.observeRoom(roomToObserve);
        }
    }
    runPowerSpawn() {
        if (this.powerSpawn && this.storage && this.colony.assets.energy > Memory.settings.powerCollection.minEnergy &&
            this.powerSpawn.store.energy >= 50 && this.powerSpawn.store.power > 0) {
            if (Game.time % 20 == 0) {
                log.info(`Processing power in ${this.room.print}`);
            }
            this.powerSpawn.processPower();
        }
    }
    init() {
        this.registerLinkTransferRequests();
        this.registerRequests();
    }
    run() {
        this.runObserver();
        this.runPowerSpawn();
    }
    visuals(coord) {
        let { x, y } = coord;
        const height = this.storage && this.terminal ? 2 : 1;
        const titleCoords = Visualizer.section(`${this.colony.name} Command Center`, { x, y, roomName: this.room.name }, 9.5, height + .1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        if (this.storage) {
            Visualizer.text('Storage', { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph(_.sum(this.storage.store) / this.storage.storeCapacity, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        if (this.terminal) {
            Visualizer.text('Terminal', { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph(_.sum(this.terminal.store) / this.terminal.storeCapacity, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        return { x: x, y: y + .25 };
    }
};
CommandCenter.settings = {
    enableIdleObservation: true,
    linksTransmitAt: LINK_CAPACITY - 100,
    refillTowersBelow: 750,
};
CommandCenter = CommandCenter_1 = __decorate([
    profile
], CommandCenter);

var EvolutionChamber_1;
const LabStatus = {
    Idle: 0,
    AcquiringMinerals: 1,
    LoadingLabs: 2,
    Synthesizing: 3,
    UnloadingLabs: 4,
};
const LabStageTimeouts = {
    Idle: Infinity,
    AcquiringMinerals: 50,
    LoadingLabs: 50,
    Synthesizing: 10000,
    UnloadingLabs: 50,
};
const LAB_USAGE_WINDOW = 100;
const getDefaultEvolutionChamberMemory = () => ({
    status: LabStatus.Idle,
    statusTick: 0,
    activeReaction: undefined,
    stats: {
        totalProduction: {},
        avgUsage: 1,
    }
});
function neighboringLabs(pos) {
    return _.compact(_.map(pos.neighbors, neighbor => neighbor.lookForStructure(STRUCTURE_LAB)));
}
function labsAreEmpty(labs) {
    return _.all(labs, lab => lab.mineralAmount == 0);
}
let EvolutionChamber = EvolutionChamber_1 = class EvolutionChamber extends HiveCluster {
    constructor(colony, terminal) {
        super(colony, terminal, 'evolutionChamber');
        this.memory = Mem.wrap(this.colony.memory, 'evolutionChamber', getDefaultEvolutionChamberMemory);
        this.terminal = terminal;
        this.terminalNetwork = Overmind.terminalNetwork;
        this.labs = colony.labs;
        const restrictedLabs = this.colony.bunker
            ? _.filter(this.labs, lab => lab.pos.findInRange(this.colony.spawns, 1).length > 0)
            : _.take(_.sortBy(this.labs, lab => Pathing.distance(this.terminal.pos, lab.pos)), 1);
        const getReagentLabs = () => {
            if (this.colony.bunker) {
                const reagentLabPositions = _.map(reagentLabSpots, coord => getPosFromBunkerCoord(coord, this.colony));
                const preferredReagentLabs = _.compact(_.map(reagentLabPositions, pos => pos.lookForStructure(STRUCTURE_LAB)));
                if (preferredReagentLabs.length == 2) {
                    return preferredReagentLabs;
                }
            }
            const range2Labs = _.filter(this.labs, lab => _.all(this.labs, otherLab => lab.pos.inRangeTo(otherLab, 2)));
            const reagentLabCandidates = _.filter(range2Labs, lab => !_.any(restrictedLabs, l => l.id == lab.id));
            return _.take(_.sortBy(reagentLabCandidates, lab => -1 * neighboringLabs(lab.pos).length), 2);
        };
        this.reagentLabs = getReagentLabs();
        this.productLabs = _.difference(this.labs, this.reagentLabs);
        const unrestrictedBoostingLabs = _.sortBy(_.difference(this.productLabs, restrictedLabs), lab => Pathing.distance(this.terminal.pos, lab.pos));
        this.boostingLabs = [...restrictedLabs, ...unrestrictedBoostingLabs];
        this.labReservations = {};
        this.neededBoosts = {};
        if (this.colony.commandCenter && this.colony.layout == 'twoPart') {
            this.transportRequests = this.colony.commandCenter.transportRequests;
        }
        else {
            this.transportRequests = this.colony.transportRequests;
        }
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'evolutionChamber', getDefaultEvolutionChamberMemory);
        $.refreshRoom(this);
        $.refresh(this, 'terminal', 'labs', 'boostingLabs', 'reagentLabs', 'productLabs');
        this.labReservations = {};
        this.neededBoosts = {};
    }
    spawnMoarOverlords() {
    }
    initLabStatus() {
        if (!this.memory.activeReaction && this.memory.status != LabStatus.Idle) {
            log.warning(`Unexpected lack of active reaction at ${this.print}! Reverting to idle state.`);
            this.memory.status = LabStatus.Idle;
        }
        const reagents = this.memory.activeReaction
            ? REAGENTS[this.memory.activeReaction.mineralType]
            : [];
        const amount = this.memory.activeReaction ? this.memory.activeReaction.amount : Infinity;
        switch (this.memory.status) {
            case LabStatus.Idle:
                if (this.memory.activeReaction) {
                    log.info(`${this.colony.print}: starting synthesis of ${reagents[0]} + ${reagents[1]} ` +
                        `${rightArrow} ${this.memory.activeReaction.mineralType}`);
                    this.memory.status = LabStatus.AcquiringMinerals;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.AcquiringMinerals:
                if (_.all(reagents, reagent => this.colony.assets[reagent] >= amount)) {
                    this.memory.status = LabStatus.LoadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.LoadingLabs:
                if (_.all(this.reagentLabs, lab => lab.mineralAmount >= amount && _.includes(reagents, lab.mineralType))) {
                    this.memory.status = LabStatus.Synthesizing;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.Synthesizing:
                if (_.any(this.reagentLabs, lab => lab.mineralAmount < LAB_REACTION_AMOUNT)) {
                    this.memory.status = LabStatus.UnloadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.UnloadingLabs:
                const unloadLabs = _.filter(this.labs, lab => !this.labReservations[lab.id]);
                if (_.all(unloadLabs, lab => lab.mineralAmount == 0)) {
                    this.memory.status = LabStatus.Idle;
                    this.memory.statusTick = Game.time;
                }
                break;
            default:
                log.error(`Bad lab state at ${this.print}! State: ${this.memory.status}`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        this.statusTimeoutCheck();
    }
    statusTimeoutCheck() {
        const ticksInStatus = Game.time - this.memory.statusTick;
        let timeout = false;
        switch (this.memory.status) {
            case LabStatus.Idle:
                timeout = ticksInStatus > LabStageTimeouts.Idle;
                break;
            case LabStatus.AcquiringMinerals:
                timeout = ticksInStatus > LabStageTimeouts.AcquiringMinerals;
                break;
            case LabStatus.LoadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.LoadingLabs;
                break;
            case LabStatus.Synthesizing:
                timeout = ticksInStatus > LabStageTimeouts.Synthesizing;
                break;
            case LabStatus.UnloadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.UnloadingLabs;
                break;
            default:
                log.error(`Bad lab state at ${this.print}!`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        if (timeout) {
            log.warning(`${this.print}: stuck in state ${this.memory.status} for ${ticksInStatus} ticks, ` +
                `rebuilding reaction queue and reverting to idle state!`);
            this.memory.status = LabStatus.Idle;
            this.memory.statusTick = Game.time;
            this.memory.activeReaction = undefined;
        }
    }
    registerReagentLabRequests(reagentLabs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            const [ing1, ing2] = REAGENTS[mineralType];
            const [lab1, lab2] = reagentLabs;
            if (!lab1 || !lab2)
                return;
            if (this.memory.status == LabStatus.UnloadingLabs || (lab1.mineralType != ing1 && lab1.mineralAmount > 0)) {
                this.transportRequests.requestOutput(lab1, Priority.Normal, { resourceType: lab1.mineralType });
            }
            else if (this.memory.status == LabStatus.LoadingLabs && lab1.mineralAmount < amount) {
                this.transportRequests.requestInput(lab1, Priority.Normal, {
                    resourceType: ing1,
                    amount: amount - lab1.mineralAmount,
                });
            }
            if (this.memory.status == LabStatus.UnloadingLabs || (lab2.mineralType != ing2 && lab2.mineralAmount > 0)) {
                this.transportRequests.requestOutput(lab2, Priority.Normal, { resourceType: lab2.mineralType });
            }
            else if (this.memory.status == LabStatus.LoadingLabs && lab2.mineralAmount < amount) {
                this.transportRequests.requestInput(lab2, Priority.Normal, {
                    resourceType: ing2,
                    amount: amount - lab2.mineralAmount,
                });
            }
        }
        else {
            for (const lab of reagentLabs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.Normal, { resourceType: lab.mineralType });
                }
            }
        }
    }
    registerProductLabRequests(labs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            for (const lab of labs) {
                const labHasWrongMineral = lab.mineralType != mineralType && lab.mineralAmount > 0;
                const labIsFull = lab.mineralAmount == lab.mineralCapacity;
                if ((this.memory.status == LabStatus.UnloadingLabs && lab.mineralAmount > 0) ||
                    labHasWrongMineral || labIsFull) {
                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });
                }
            }
        }
        else {
            for (const lab of labs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });
                }
            }
        }
    }
    registerBoosterLabRequests(labs) {
        for (const lab of labs) {
            const { mineralType, amount } = this.labReservations[lab.id];
            if (lab.mineralType != mineralType && lab.mineralAmount > 0) {
                this.transportRequests.requestOutput(lab, Priority.High, { resourceType: lab.mineralType });
            }
            else {
                this.transportRequests.requestInput(lab, Priority.High, {
                    resourceType: mineralType,
                    amount: amount - lab.mineralAmount
                });
            }
        }
    }
    registerRequests() {
        if (this.colony.state.bootstrapping) {
            return;
        }
        const [boostingProductLabs, reactionProductLabs] = _.partition(this.productLabs, lab => this.labReservations[lab.id]);
        const boostingRefillLabs = _.filter(boostingProductLabs, lab => lab.energy < lab.energyCapacity);
        _.forEach(boostingRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.High));
        const reactionRefillLabs = _.filter(reactionProductLabs, lab => lab.energy < lab.energyCapacity);
        _.forEach(reactionRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.NormalLow));
        const reagentRefillLabs = _.filter(this.reagentLabs, lab => lab.energy < lab.energyCapacity);
        _.forEach(reagentRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.NormalLow));
        this.registerReagentLabRequests(this.reagentLabs);
        this.registerProductLabRequests(reactionProductLabs);
        this.registerBoosterLabRequests(boostingProductLabs);
    }
    reserveLab(lab, resourceType, amount) {
        this.labReservations[lab.id] = { mineralType: resourceType, amount: Math.min(amount, LAB_MINERAL_CAPACITY) };
    }
    static requiredBoostAmount(body, boostType) {
        const existingBoostCounts = _.countBy(body, part => part.boost);
        const numPartsToBeBoosted = _.filter(body, part => part.type == BOOST_PARTS[boostType]).length;
        return LAB_BOOST_MINERAL * (numPartsToBeBoosted - (existingBoostCounts[boostType] || 0));
    }
    bestBoostAvailable(boostType, amount) {
        if (PHASE != 'run') {
            log.error(`EvolutionChamber.bestBoostAvailable() must be called in the run() phase!`);
        }
        const boosts = BOOST_TIERS[boostType];
        for (const boost of [boosts.T3, boosts.T2, boosts.T1]) {
            if (this.colony.assets[boost] >= amount) {
                return boost;
            }
            else if (this.terminalNetwork.canObtainResource(this.colony, boost, amount)) {
                return boost;
            }
        }
        return undefined;
    }
    requestBoosts(boosts) {
        this.debug(`${JSON.stringify(boosts)} boosts requested!`);
        for (const boostResource in boosts) {
            const boostAmount = boosts[boostResource];
            this.neededBoosts[boostResource] = (this.neededBoosts[boostResource] || 0) + boostAmount;
        }
    }
    lockLabFromTerminalNetwork(lab) {
        if (lab.mineralType && lab.store[lab.mineralType]) {
            this.terminalNetwork.lockResource(this.colony, lab.mineralType, lab.store[lab.mineralType]);
        }
    }
    init() {
        for (const boost in this.neededBoosts) {
            if (this.neededBoosts[boost] == 0)
                continue;
            let boostLab;
            for (const id in this.labReservations) {
                if (this.labReservations[id] && this.labReservations[id].mineralType == boost) {
                    boostLab = deref(id);
                }
            }
            if (!boostLab) {
                boostLab = _.find(this.boostingLabs, lab => !this.labReservations[lab.id]);
            }
            if (boostLab) {
                this.reserveLab(boostLab, boost, this.neededBoosts[boost]);
            }
        }
        this.initLabStatus();
        this.registerRequests();
        for (const boost in this.neededBoosts) {
            const product = this.memory.activeReaction ? this.memory.activeReaction.mineralType : undefined;
            const reagents = this.memory.activeReaction ? REAGENTS[this.memory.activeReaction.mineralType]
                : [undefined, undefined];
            let amountUnavailable = 0;
            if (boost == product) {
                _.forEach(this.productLabs, lab => {
                    if (lab.mineralType == boost &&
                        (!this.labReservations[lab.id] || this.labReservations[lab.id].mineralType != boost)) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            else if (boost == reagents[0]) {
                _.forEach(this.reagentLabs, lab => {
                    if (lab.mineralType == boost &&
                        (!this.labReservations[lab.id] || this.labReservations[lab.id].mineralType != boost)) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            else if (boost == reagents[1]) {
                _.forEach(this.reagentLabs, lab => {
                    if (lab.mineralType == boost &&
                        (!this.labReservations[lab.id] || this.labReservations[lab.id].mineralType != boost)) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            const amountNeeded = this.neededBoosts[boost] + amountUnavailable;
            if (amountNeeded > this.colony.assets[boost]) {
                this.debug(`Requesting boost from terminal network: ${this.neededBoosts[boost]} ${boost}`);
                this.terminalNetwork.requestResource(this.colony, boost, amountNeeded);
            }
            else {
                this.debug(`Locking boost from terminal network: ${this.neededBoosts[boost]} ${boost}`);
                this.terminalNetwork.lockResource(this.colony, boost, amountNeeded);
            }
        }
        if (this.memory.activeReaction) {
            const amount = this.memory.activeReaction.amount;
            const product = this.memory.activeReaction.mineralType;
            const reagents = REAGENTS[this.memory.activeReaction.mineralType];
            switch (this.memory.status) {
                case LabStatus.Idle:
                    break;
                case LabStatus.AcquiringMinerals:
                    _.forEach(reagents, reagent => {
                        if (this.colony.assets[reagent] < amount) {
                            this.terminalNetwork.requestResource(this.colony, reagent, amount);
                        }
                        else {
                            this.terminalNetwork.lockResource(this.colony, reagent, amount);
                        }
                    });
                    break;
                case LabStatus.LoadingLabs:
                    _.forEach(reagents, reagent => this.terminalNetwork.lockResource(this.colony, reagent, amount));
                    break;
                case LabStatus.Synthesizing:
                    _.forEach(this.reagentLabs, lab => {
                        if (lab.mineralType == reagents[0] || lab.mineralType == reagents[1]) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    _.forEach(this.productLabs, lab => {
                        if (lab.mineralType == product) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    break;
                case LabStatus.UnloadingLabs:
                    _.forEach(this.labs, lab => {
                        if (lab.mineralType == product ||
                            lab.mineralType == reagents[0] ||
                            lab.mineralType == reagents[1]) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    break;
            }
        }
    }
    run() {
        if (this.memory.suspendReactionsUntil && Game.time > this.memory.suspendReactionsUntil) {
            delete this.memory.suspendReactionsUntil;
        }
        if (!this.memory.activeReaction && !this.memory.suspendReactionsUntil) {
            const nextReaction = Abathur.getNextReaction(this.colony);
            if (nextReaction) {
                this.memory.activeReaction = nextReaction;
            }
            else {
                const sleepTime = EvolutionChamber_1.settings.sleepTime + randint(0, 20);
                log.info(`${this.print}: no reaction available; sleeping for ${sleepTime} ticks.`);
                this.memory.suspendReactionsUntil = Game.time + sleepTime;
            }
        }
        if (this.memory.status == LabStatus.Synthesizing) {
            const [lab1, lab2] = this.reagentLabs;
            for (const lab of this.productLabs) {
                if (lab.cooldown == 0 && !this.labReservations[lab.id]) {
                    const result = lab.runReaction(lab1, lab2);
                    if (result == OK) {
                        const product = this.memory.activeReaction ? this.memory.activeReaction.mineralType : 'ERROR';
                        if (!this.memory.stats.totalProduction[product]) {
                            this.memory.stats.totalProduction[product] = 0;
                        }
                        this.memory.stats.totalProduction[product] += LAB_REACTION_AMOUNT;
                    }
                    else {
                        log.warning(`${this.print}: couldn't run reaction for lab @ ${lab.pos.print}! (${result})`);
                    }
                }
            }
        }
        this.stats();
    }
    drawLabReport(coord) {
        let { x, y } = coord;
        const height = 2;
        const titleCoords = Visualizer.section(`${this.colony.name} Evolution Chamber`, { x, y, roomName: this.room.name }, 9.5, height + .1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        let status;
        switch (this.memory.status) {
            case LabStatus.Idle:
                status = 'IDLE';
                break;
            case LabStatus.AcquiringMinerals:
                status = 'acquire minerals';
                break;
            case LabStatus.LoadingLabs:
                status = 'loading labs';
                break;
            case LabStatus.Synthesizing:
                status = 'synthesizing';
                break;
            case LabStatus.UnloadingLabs:
                status = 'unloading labs';
                break;
            default:
                status = 'INVALID';
                break;
        }
        const activeReaction = this.memory.activeReaction;
        const mineral = activeReaction ? activeReaction.mineralType : 'NONE';
        Visualizer.text(`Status: ${status}`, { x: boxX, y: y, roomName: this.room.name });
        y += 1;
        if (this.memory.status == LabStatus.Synthesizing && activeReaction) {
            const amountDone = _.sum(_.map(this.productLabs, lab => lab.mineralType == activeReaction.mineralType ? lab.mineralAmount : 0));
            Visualizer.text(activeReaction.mineralType, { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph([amountDone, activeReaction.amount], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        else {
            Visualizer.text(`Active reaction: ${mineral}`, { x: boxX, y: y, roomName: this.room.name });
            y += 1;
        }
        return { x: x, y: y + .25 };
    }
    visuals(coord) {
        const vis = this.room.visual;
        for (const lab of this.labs) {
            if (lab.mineralType) {
                vis.resource(lab.mineralType, lab.pos.x, lab.pos.y);
            }
        }
        return this.drawLabReport(coord);
    }
    stats() {
        const labUsage = _.sum(this.productLabs, lab => lab.cooldown > 0 ? 1 : 0) / this.productLabs.length;
        this.memory.stats.avgUsage = ema(labUsage, this.memory.stats.avgUsage, LAB_USAGE_WINDOW);
        Stats.log(`colonies.${this.colony.name}.evolutionChamber.avgUsage`, this.memory.stats.avgUsage);
    }
};
EvolutionChamber.settings = {
    sleepTime: 100
};
EvolutionChamber = EvolutionChamber_1 = __decorate([
    profile
], EvolutionChamber);

let QueenOverlord = class QueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, 'supply', priority);
        this.hatchery = hatchery;
        this.queenSetup = this.colony.storage && !this.colony.state.isRebuilding ? Setups.queens.default
            : Setups.queens.early;
        this.queens = this.zerg(Roles.queen);
        this.settings = {
            refillTowersBelow: 500,
        };
    }
    init() {
        const amount = 1;
        const prespawn = this.hatchery.spawns.length <= 1 ? 100 : DEFAULT_PRESPAWN;
        this.wishlist(amount, this.queenSetup, { prespawn: prespawn });
    }
    supplyActions(queen) {
        const request = this.hatchery.transportRequests.getPrioritizedClosestRequest(queen.pos, 'supply');
        if (request) {
            queen.task = Tasks.transfer(request.target);
        }
        else {
            this.rechargeActions(queen);
        }
    }
    rechargeActions(queen) {
        if (this.hatchery.link && !this.hatchery.link.isEmpty) {
            queen.task = Tasks.withdraw(this.hatchery.link);
        }
        else if (this.hatchery.batteries.length > 0) {
            const target = queen.pos.findClosestByRange(_.filter(this.hatchery.batteries, b => b.energy > 0));
            if (target) {
                queen.task = Tasks.withdraw(target);
            }
            else {
                queen.task = Tasks.recharge();
            }
        }
        else {
            queen.task = Tasks.recharge();
        }
    }
    idleActions(queen) {
        const battery = queen.pos.findClosestByRange(this.hatchery.batteries);
        if (this.hatchery.link) {
            if (battery && !battery.isFull && !this.hatchery.link.isEmpty) {
                if (queen.carry.energy < queen.carryCapacity) {
                    queen.task = Tasks.withdraw(this.hatchery.link);
                }
                else {
                    queen.task = Tasks.transfer(battery);
                }
            }
            else {
                if (queen.carry.energy < queen.carryCapacity) {
                    if (!this.hatchery.link.isEmpty) {
                        queen.task = Tasks.withdraw(this.hatchery.link);
                    }
                    else if (battery && !battery.isEmpty) {
                        queen.task = Tasks.withdraw(battery);
                    }
                }
            }
        }
        else {
            if (battery && queen.carry.energy < queen.carryCapacity) {
                queen.task = Tasks.withdraw(battery);
            }
        }
    }
    handleQueen(queen) {
        if (queen.carry.energy > 0) {
            this.supplyActions(queen);
        }
        else {
            this.rechargeActions(queen);
        }
        if (queen.isIdle) {
            this.idleActions(queen);
        }
    }
    run() {
        for (const queen of this.queens) {
            this.handleQueen(queen);
            if (queen.hasValidTask) {
                queen.run();
            }
            else {
                if (this.queens.length > 1) {
                    queen.goTo(this.hatchery.idlePos, { range: 1 });
                }
                else {
                    queen.goTo(this.hatchery.idlePos);
                }
            }
        }
    }
};
QueenOverlord = __decorate([
    profile
], QueenOverlord);

function isSupplyStructure(structure) {
    return structure.structureType == STRUCTURE_EXTENSION
        || structure.structureType == STRUCTURE_LAB
        || structure.structureType == STRUCTURE_TOWER
        || structure.structureType == STRUCTURE_SPAWN;
}
function computeQuadrant(colony, quadrant) {
    const positions = _.map(quadrant, coord => getPosFromBunkerCoord(coord, colony));
    const structures = [];
    for (const pos of positions) {
        const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => isSupplyStructure(s));
        if (structure) {
            structures.push(structure);
        }
    }
    return structures;
}
let BunkerQueenOverlord = class BunkerQueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, 'supply', priority);
        this.queenSetup = Setups.queens.default;
        this.queens = this.zerg(Roles.queen);
        this.batteries = _.filter(this.room.containers, container => insideBunkerBounds(container.pos, this.colony));
        this.links = _.filter(this.room.links, link => insideBunkerBounds(link.pos, this.colony));
        this.storeStructures = _.compact([this.colony.terminal,
            this.colony.storage,
            ...this.batteries,
            ...this.links]);
        this.quadrants = {
            lowerRight: $.structures(this, 'LR', () => computeQuadrant(this.colony, quadrantFillOrder.lowerRight)),
            upperLeft: $.structures(this, 'UL', () => computeQuadrant(this.colony, quadrantFillOrder.upperLeft)),
            lowerLeft: $.structures(this, 'LL', () => computeQuadrant(this.colony, quadrantFillOrder.lowerLeft)),
            upperRight: $.structures(this, 'UR', () => computeQuadrant(this.colony, quadrantFillOrder.upperRight)),
        };
        this.computeQueenAssignments();
    }
    static canFunction(colony) {
        return (colony.layout === "bunker"
            && insideBunkerBounds(colony.spawns[0].pos, colony)
            && (!!colony.storage || !!colony.terminal));
    }
    computeQueenAssignments() {
        this.assignments = _.zipObject(_.map(this.queens, queen => [queen.name, {}]));
        const activeQueens = _.filter(this.queens, queen => !queen.spawning);
        this.numActiveQueens = activeQueens.length;
        if (this.numActiveQueens > 0) {
            const quadrantAssignmentOrder = [this.quadrants.lowerRight,
                this.quadrants.upperLeft,
                this.quadrants.lowerLeft,
                this.quadrants.upperRight];
            let i = 0;
            for (const quadrant of quadrantAssignmentOrder) {
                const queen = activeQueens[i % activeQueens.length];
                _.extend(this.assignments[queen.name], _.zipObject(_.map(quadrant, s => [s.id, true])));
                i++;
            }
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'batteries', 'storeStructures');
        $.refreshObject(this, 'quadrants');
        if (_.filter(this.queens, queen => !queen.spawning).length != this.numActiveQueens) {
            this.computeQueenAssignments();
        }
    }
    init() {
        for (const battery of this.batteries) {
            if (hasMinerals(battery.store)) {
                this.colony.logisticsNetwork.requestOutputMinerals(battery);
            }
        }
        const amount = this.colony.room.energyCapacityAvailable > 2000 ? 2 : 1;
        this.wishlist(amount, this.queenSetup);
    }
    buildSupplyTaskManifest(queen) {
        let tasks = [];
        let queenPos = queen.pos;
        if (_.sum(queen.carry) > 0) {
            const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];
            if (transferTarget) {
                tasks.push(Tasks.transferAll(transferTarget));
                queenPos = transferTarget.pos;
            }
            else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        const queenCarry = {};
        const allStore = mergeSum(_.map(this.storeStructures, s => s.store));
        const supplyRequests = [];
        for (const priority in this.colony.transportRequests.supply) {
            for (const request of this.colony.transportRequests.supply[priority]) {
                if (this.assignments[queen.name][request.target.id]) {
                    supplyRequests.push(request);
                }
            }
        }
        const supplyTasks = [];
        for (const request of supplyRequests) {
            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);
            if (remainingAmount == 0)
                break;
            let amount = Math.min(request.amount, remainingAmount);
            amount = Math.min(amount, allStore[request.resourceType] || 0);
            if (amount == 0)
                continue;
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            supplyTasks.push(Tasks.transfer(request.target, request.resourceType, amount));
        }
        const withdrawTasks = [];
        const neededResources = _.keys(queenCarry);
        const targets = _.filter(this.storeStructures, s => _.all(neededResources, resource => (s.store[resource] || 0) >= (queenCarry[resource] || 0)));
        const withdrawTarget = minBy(targets, target => Pathing.distance(queenPos, target.pos) || Infinity);
        if (withdrawTarget) {
            for (const resourceType of neededResources) {
                withdrawTasks.push(Tasks.withdraw(withdrawTarget, resourceType, queenCarry[resourceType]));
            }
        }
        else {
            const closestTarget = minBy(this.storeStructures, target => Pathing.distance(queenPos, target.pos) || Infinity);
            if (!closestTarget) {
                log.error(`Can't seem to find any pathable store structures in ${this.colony.print}`);
            }
            else {
                for (const resourceType of neededResources) {
                    if (closestTarget.store[resourceType] >= queenCarry[resourceType]) {
                        withdrawTasks.push(Tasks.withdraw(closestTarget, resourceType, queenCarry[resourceType]));
                    }
                    else {
                        const hasResource = _.sortBy(_.filter(this.storeStructures, s => s.store[resourceType] > 0), s => -s.store[resourceType]);
                        let collected = 0;
                        for (const storeLoc of hasResource) {
                            withdrawTasks.push(Tasks.withdraw(storeLoc, resourceType, Math.min(queenCarry[resourceType] - collected, storeLoc.store[resourceType])));
                            collected += storeLoc.store[resourceType];
                            if (collected >= queenCarry[resourceType]) {
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (!withdrawTarget && withdrawTasks.length == 0) {
            log.warning(`Could not find adequate withdraw structure for ${queen.print}! (neededResources: 
			${neededResources}, queenCarry: ${JSON.stringify(queenCarry)})`);
            return null;
        }
        tasks = tasks.concat(withdrawTasks, supplyTasks);
        return Tasks.chain(tasks);
    }
    buildWithdrawTaskManifest(queen) {
        const tasks = [];
        const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];
        if (_.sum(queen.carry) > 0) {
            if (transferTarget) {
                tasks.push(Tasks.transferAll(transferTarget));
            }
            else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        const queenCarry = { energy: 0 };
        const withdrawRequests = [];
        for (const priority in this.colony.transportRequests.withdraw) {
            for (const request of this.colony.transportRequests.withdraw[priority]) {
                if (this.assignments[queen.name][request.target.id]) {
                    withdrawRequests.push(request);
                }
            }
        }
        for (const request of withdrawRequests) {
            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);
            if (remainingAmount == 0)
                break;
            const amount = Math.min(request.amount, remainingAmount);
            if (amount == 0)
                continue;
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            tasks.push(Tasks.withdraw(request.target, request.resourceType, amount));
        }
        if (transferTarget) {
            tasks.push(Tasks.transferAll(transferTarget));
        }
        else {
            log.warning(`No transfer targets for ${queen.print}!`);
            return null;
        }
        return Tasks.chain(tasks);
    }
    handleQueen(queen) {
        if (this.colony.transportRequests.needsWithdrawing() &&
            _.any(_.keys(this.assignments[queen.name]), id => this.colony.transportRequests.withdrawByID[id])) {
            queen.task = this.buildWithdrawTaskManifest(queen);
        }
        else if (this.colony.transportRequests.needsSupplying() &&
            _.any(_.keys(this.assignments[queen.name]), id => this.colony.transportRequests.supplyByID[id])) {
            queen.task = this.buildSupplyTaskManifest(queen);
        }
        else if (this.colony.level > 5 && this.colony.controller.safeModeAvailable < 3 &&
            this.colony.terminal && this.colony.terminal.store[RESOURCE_GHODIUM] >= 1000 &&
            queen.carryCapacity >= 1000) {
            if (queen.name == _.first(_.sortBy(this.queens, q => q.name)).name) {
                queen.task = Tasks.chain([
                    Tasks.transferAll(this.colony.terminal),
                    Tasks.withdraw(this.colony.terminal, RESOURCE_GHODIUM, 1000),
                    Tasks.generateSafeMode(this.colony.controller)
                ]);
                log.alert(`${this.colony.print} has ${this.colony.controller.safeModeAvailable} safemodes available, ` +
                    `generating a new one`);
            }
        }
        if (queen.isIdle) {
            delete queen.memory._go;
        }
    }
    run() {
        this.autoRun(this.queens, queen => this.handleQueen(queen));
    }
};
BunkerQueenOverlord = __decorate([
    profile
], BunkerQueenOverlord);

const ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH = -20;
const ERR_SPECIFIED_SPAWN_BUSY = -21;
const getDefaultHatcheryMemory = () => ({
    stats: {
        overload: 0,
        uptime: 0,
        longUptime: 0,
    }
});
let Hatchery = class Hatchery extends HiveCluster {
    constructor(colony, headSpawn) {
        super(colony, headSpawn, 'hatchery');
        this.memory = Mem.wrap(this.colony.memory, 'hatchery', getDefaultHatcheryMemory);
        if (this.colony.layout == 'twoPart')
            this.colony.destinations.push({ pos: this.pos, order: -1 });
        this.spawns = colony.spawns;
        this.availableSpawns = _.filter(this.spawns, spawn => !spawn.spawning);
        this.extensions = colony.extensions;
        this.towers = colony.commandCenter ? _.difference(colony.towers, colony.commandCenter.towers) : colony.towers;
        if (this.colony.layout == 'bunker') {
            this.batteries = _.filter(this.room.containers, cont => insideBunkerBounds(cont.pos, this.colony));
            $.set(this, 'energyStructures', () => this.computeEnergyStructures());
        }
        else {
            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);
            this.colony.linkNetwork.claimLink(this.link);
            const battery = this.pos.findClosestByLimitedRange(this.room.containers, 2);
            this.batteries = battery ? [battery] : [];
            this.energyStructures = [].concat(this.spawns, this.extensions);
        }
        this.productionPriorities = [];
        this.productionQueue = {};
        this.isOverloaded = false;
        this._waitTimes = undefined;
        this.settings = {
            refillTowersBelow: 750,
            linksRequestEnergyBelow: 0,
            suppressSpawning: false,
        };
        this.transportRequests = colony.transportRequests;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'hatchery', getDefaultHatcheryMemory);
        $.refreshRoom(this);
        $.refresh(this, 'spawns', 'extensions', 'energyStructures', 'link', 'towers', 'batteries');
        this.availableSpawns = _.filter(this.spawns, spawn => !spawn.spawning);
        this.productionPriorities = [];
        this.productionQueue = {};
        this.isOverloaded = false;
        this._waitTimes = undefined;
    }
    spawnMoarOverlords() {
        return BunkerQueenOverlord.canFunction(this.colony) ? new BunkerQueenOverlord(this) : new QueenOverlord(this);
    }
    getWaitTimeForPriority(priority) {
        if (!this._waitTimes) {
            const waitTimes = {};
            let waitTime = _.sum(this.spawns, spawn => spawn.spawning ? spawn.spawning.remainingTime : 0) /
                this.spawns.length;
            for (const priority of _.sortBy(this.productionPriorities)) {
                for (const request of this.productionQueue[priority]) {
                    const { body, boosts } = request.setup.create(this.colony, true);
                    waitTime += CREEP_SPAWN_TIME * body.length / this.spawns.length;
                }
                waitTimes[priority] = waitTime;
            }
            this._waitTimes = waitTimes;
        }
        if (this._waitTimes[priority] != undefined) {
            return this._waitTimes[priority];
        }
        const priorities = _.sortBy(this.productionPriorities);
        if (priorities.length == 0) {
            return 0;
        }
        if (priority < _.first(priorities)) {
            return 0;
        }
        const priorityIndex = _.sortedIndex(priorities, priority) - 1;
        const waitTime = this._waitTimes[priorities[priorityIndex]];
        if (waitTime == undefined) {
            log.error(`${this.print}: Undefined wait time in wait times: ${this._waitTimes}!`);
            return 0;
        }
        return waitTime;
    }
    get idlePos() {
        if (this.batteries.length > 0) {
            return _.first(this.batteries).pos;
        }
        else {
            return this.spawns[0].pos.availableNeighbors(true)[0];
        }
    }
    computeEnergyStructures() {
        if (this.colony.layout == 'bunker') {
            const positions = _.map(energyStructureOrder, coord => getPosFromBunkerCoord(coord, this.colony));
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);
            const energyStructures = [];
            for (const pos of positions) {
                const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => s.structureType == STRUCTURE_SPAWN
                    || s.structureType == STRUCTURE_EXTENSION);
                if (structure) {
                    energyStructures.push(_.remove(spawnsAndExtensions, s => s.id == structure.id)[0]);
                }
            }
            return _.compact(energyStructures.concat(spawnsAndExtensions));
        }
        else {
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);
            return _.sortBy(spawnsAndExtensions, structure => structure.pos.getRangeTo(this.idlePos));
        }
    }
    registerEnergyRequests() {
        if (this.link && this.link.isEmpty) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        if (this.batteries.length > 0) {
            for (const battery of this.batteries) {
                const threshold = this.colony.stage == ColonyStage.Larva ? 0.75 : 0.5;
                if (battery.energy < threshold * battery.store.getCapacity()) {
                    this.colony.logisticsNetwork.requestInput(battery, { multiplier: 1.5 });
                }
                if (hasMinerals(battery.store)) {
                    this.colony.logisticsNetwork.requestOutputMinerals(battery);
                }
            }
        }
        else {
            _.forEach(this.energyStructures, struct => this.colony.logisticsNetwork.requestInput(struct, { multiplier: 1.5 }));
        }
        _.forEach(this.energyStructures, struct => this.transportRequests.requestInput(struct, Priority.Normal));
        const refillTowers = _.filter(this.towers, tower => tower.energy < this.settings.refillTowersBelow);
        _.forEach(refillTowers, tower => this.transportRequests.requestInput(tower, Priority.NormalLow));
    }
    generateCreepName(roleName) {
        let i = 0;
        while (Game.creeps[(roleName + '_' + i)]) {
            i++;
        }
        return (roleName + '_' + i);
    }
    spawnCreep(protoCreep, options = {}) {
        if (bodyCost(protoCreep.body) > this.room.energyCapacityAvailable) {
            return ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH;
        }
        let spawnToUse;
        if (options.spawn) {
            spawnToUse = options.spawn;
            if (spawnToUse.spawning) {
                return ERR_SPECIFIED_SPAWN_BUSY;
            }
            else {
                _.remove(this.availableSpawns, spawn => spawn.id == spawnToUse.id);
            }
        }
        else {
            spawnToUse = this.availableSpawns.shift();
        }
        if (spawnToUse) {
            if (this.colony.bunker && this.colony.bunker.coreSpawn
                && spawnToUse.id == this.colony.bunker.coreSpawn.id && !options.directions) {
                options.directions = [TOP, RIGHT];
            }
            protoCreep.name = this.generateCreepName(protoCreep.name);
            protoCreep.memory.data.origin = spawnToUse.pos.roomName;
            const result = spawnToUse.spawnCreep(protoCreep.body, protoCreep.name, {
                memory: protoCreep.memory,
                energyStructures: this.energyStructures,
                directions: options.directions
            });
            if (result == OK) {
                const overlordRef = protoCreep.memory["O"];
                const overlord = Overmind.overlords[overlordRef];
                if (overlord) {
                    if (overlord.memory["S"]) {
                        overlord.memory["S"].spawnCost += bodyCost(protoCreep.body);
                    }
                }
                else {
                    log.error(`No overlord for protocreep ${protoCreep.name} at hatchery ${this.print}!`);
                }
                return result;
            }
            else {
                this.availableSpawns.unshift(spawnToUse);
                return result;
            }
        }
        else {
            return ERR_BUSY;
        }
    }
    canSpawn(body) {
        return bodyCost(body) <= this.room.energyCapacityAvailable;
    }
    canSpawnZerg(zerg) {
        return this.canSpawn(_.map(zerg.body, part => part.type));
    }
    generateProtoCreep(setup, overlord) {
        const creepMemory = {
            ["C"]: overlord.colony.name,
            ["O"]: overlord.ref,
            role: setup.role,
            task: null,
            data: {
                origin: '',
            },
        };
        const { body, boosts } = setup.create(this.colony);
        if (boosts.length > 0) {
            creepMemory.needBoosts = boosts;
        }
        const protoCreep = {
            body: body,
            name: setup.role,
            memory: creepMemory,
        };
        return protoCreep;
    }
    enqueue(request) {
        const priority = request.priority;
        this._waitTimes = undefined;
        if (!this.productionQueue[priority]) {
            this.productionQueue[priority] = [];
            this.productionPriorities.push(priority);
        }
        this.productionQueue[priority].push(request);
    }
    spawnHighestPriorityCreep() {
        const sortedKeys = _.sortBy(this.productionPriorities);
        for (const priority of sortedKeys) {
            const request = this.productionQueue[priority].shift();
            if (request) {
                const protoCreep = this.generateProtoCreep(request.setup, request.overlord);
                if (this.canSpawn(protoCreep.body) && protoCreep.body.length > 0) {
                    const result = this.spawnCreep(protoCreep, request.options);
                    if (result == OK) {
                        return result;
                    }
                    else if (result == ERR_SPECIFIED_SPAWN_BUSY) {
                        return result;
                    }
                    else {
                        if (result != ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH) {
                            this.productionQueue[priority].unshift(request);
                            return result;
                        }
                    }
                }
                else {
                    log.debug(`${this.room.print}: cannot spawn creep ${protoCreep.name} with body ` +
                        `${JSON.stringify(protoCreep.body)} from overlord ${request.overlord.name}!`);
                }
            }
        }
    }
    init() {
        this.registerEnergyRequests();
    }
    run() {
        if (!this.settings.suppressSpawning) {
            while (this.availableSpawns.length > 0) {
                const result = this.spawnHighestPriorityCreep();
                if (result == ERR_NOT_ENOUGH_ENERGY) {
                    this.isOverloaded = true;
                }
                if (result != OK && result != ERR_SPECIFIED_SPAWN_BUSY) {
                    break;
                }
            }
            for (const spawn of this.spawns) {
                if (spawn.spawning && spawn.spawning.remainingTime <= 1
                    && spawn.pos.findInRange(FIND_MY_CREEPS, 1).length > 0) {
                    let directions;
                    if (spawn.spawning.directions) {
                        directions = spawn.spawning.directions;
                    }
                    else {
                        directions = _.map(spawn.pos.availableNeighbors(true), pos => spawn.pos.getDirectionTo(pos));
                    }
                    const exitPos = Pathing.positionAtDirection(spawn.pos, _.first(directions));
                    Movement.vacatePos(exitPos);
                }
            }
        }
        this.recordStats();
    }
    recordStats() {
        const spawnUsageThisTick = _.filter(this.spawns, spawn => spawn.spawning).length / this.spawns.length;
        const uptime = ema(spawnUsageThisTick, this.memory.stats.uptime, CREEP_LIFE_TIME);
        const longUptime = ema(spawnUsageThisTick, this.memory.stats.longUptime, 3 * CREEP_LIFE_TIME);
        const overload = ema(this.isOverloaded ? 1 : 0, this.memory.stats.overload, CREEP_LIFE_TIME);
        Stats.log(`colonies.${this.colony.name}.hatchery.uptime`, uptime);
        Stats.log(`colonies.${this.colony.name}.hatchery.overload`, overload);
        this.memory.stats = { overload, uptime, longUptime };
    }
    visuals(coord) {
        let { x, y } = coord;
        const spawning = [];
        const spawnProgress = [];
        _.forEach(this.spawns, function (spawn) {
            if (spawn.spawning) {
                spawning.push(spawn.spawning.name.split('_')[0]);
                const timeElapsed = spawn.spawning.needTime - spawn.spawning.remainingTime;
                spawnProgress.push([timeElapsed, spawn.spawning.needTime]);
            }
        });
        const boxCoords = Visualizer.section(`${this.colony.name} Hatchery`, { x, y, roomName: this.room.name }, 9.5, 3 + spawning.length + .1);
        const boxX = boxCoords.x;
        y = boxCoords.y + 0.25;
        Visualizer.text('Energy', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph([this.room.energyAvailable, this.room.energyCapacityAvailable], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        const uptime = this.memory.stats.uptime;
        Visualizer.text('Uptime', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(uptime, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        const overload = this.memory.stats.overload;
        Visualizer.text('Overload', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(overload, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        for (const i in spawning) {
            Visualizer.text(spawning[i], { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph(spawnProgress[i], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        return { x: x, y: y + .25 };
    }
};
Hatchery.restrictedRange = 6;
Hatchery = __decorate([
    profile
], Hatchery);

var SporeCrawler_1;
let SporeCrawler = SporeCrawler_1 = class SporeCrawler extends HiveCluster {
    constructor(colony, tower) {
        super(colony, tower, 'sporeCrawler');
        this.memory = Mem.wrap(this.colony.memory, 'sporeCrawler');
        this.towers = this.colony.towers;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'sporeCrawler');
        $.refreshRoom(this);
        $.refresh(this, 'towers');
    }
    spawnMoarOverlords() {
    }
    registerEnergyRequests() {
        for (const tower of this.towers) {
            if (tower.energy < SporeCrawler_1.settings.requestThreshold) {
                const multiplier = tower.energy < SporeCrawler_1.settings.criticalEnergyThreshold ? 2 : 1;
                const dAmountdt = this.room.hostiles.length > 0 ? 10 : 0;
                this.colony.logisticsNetwork.requestInput(tower, { multiplier: multiplier, dAmountdt: dAmountdt });
            }
        }
    }
    init() {
        this.registerEnergyRequests();
    }
    attack(target) {
        for (const tower of this.towers) {
            const result = tower.attack(target);
            if (result == OK) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.singleTowerDamage(target.pos.getRangeTo(tower));
            }
        }
    }
    scatterShot(targets) {
        if (!targets)
            return;
        for (const tower of this.towers) {
            const target = _.sample(targets);
            const result = tower.attack(target);
            if (result == OK) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.singleTowerDamage(target.pos.getRangeTo(tower));
            }
        }
    }
    preventStructureDecay(includeRoads = true) {
        if (this.towers.length < 1)
            return;
        const dyingRamparts = _.filter(this.room.ramparts, rampart => rampart.hits < WorkerOverlord.settings.barrierHits.critical
            && this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(rampart.pos));
        if (dyingRamparts.length > 0) {
            for (const tower of this.towers) {
                tower.repair(tower.pos.findClosestByRange(dyingRamparts));
            }
            return;
        }
        if (includeRoads) {
            const decayingRoads = _.filter(this.room.roads, road => road.hits < 0.2 * road.hitsMax && this.colony.roomPlanner.roadPlanner.roadShouldBeHere(road.pos));
            if (decayingRoads.length > 0) {
                const roadsToRepair = _.sample(decayingRoads, this.towers.length);
                for (const i in roadsToRepair) {
                    this.towers[i].repair(roadsToRepair[i]);
                }
            }
        }
    }
    run() {
        if (this.room.hostiles.length > 0) {
            const myDefenders = _.filter(this.room.creeps, creep => creep.getActiveBodyparts(ATTACK) > 1);
            const myRangedDefenders = _.filter(this.room.creeps, creep => creep.getActiveBodyparts(RANGED_ATTACK) > 1);
            const myCreepDamage = ATTACK_POWER * _.sum(myDefenders, creep => CombatIntel.getAttackPotential(creep)) +
                RANGED_ATTACK_POWER * _.sum(myRangedDefenders, creep => CombatIntel.getRangedAttackPotential(creep));
            const HEAL_FUDGE_FACTOR = 1.0;
            const avgHealing = HEAL_FUDGE_FACTOR * CombatIntel.avgHostileHealingTo(this.room.hostiles);
            let possibleTargets = _.filter(this.room.hostiles, hostile => {
                const damageTaken = CombatIntel.towerDamageAtPos(hostile.pos) + myCreepDamage;
                const damageMultiplier = CombatIntel.minimumDamageTakenMultiplier(hostile);
                return damageTaken * damageMultiplier > avgHealing;
            });
            possibleTargets = _.filter(possibleTargets, hostile => {
                if (CombatIntel.isEdgeDancing(hostile)) {
                    const netDPS = CombatIntel.towerDamageAtPos(hostile.pos) + myCreepDamage
                        - (HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile));
                    const isKillable = netDPS * hostile.pos.rangeToEdge > hostile.hits;
                    if (isKillable) {
                        return true;
                    }
                    else {
                        if (this.colony.bunker && this.colony.bunker.anchor &&
                            hostile.pos.getRangeTo(this.colony.bunker.anchor) <= 6 + 2) {
                            return true;
                        }
                    }
                }
                else {
                    return true;
                }
            });
            if (Game.time % 21 == 0 && _.filter(possibleTargets, target => target.hits < target.hitsMax / 2).length == 0) {
                return this.scatterShot(possibleTargets);
            }
            possibleTargets = possibleTargets.filter(enemy => enemy.hits < enemy.hitsMax / 2
                || enemy.pos.findInRange(FIND_MY_CREEPS, 3).length > 0);
            const target = CombatTargeting.findBestCreepTargetForTowers(this.room, possibleTargets);
            if (target) {
                return this.attack(target);
            }
        }
        const closestDamagedAlly = this.pos.findClosestByRange(_.filter(this.room.friendlies, creep => creep.hits < creep.hitsMax));
        if (closestDamagedAlly) {
            for (const tower of this.towers) {
                tower.heal(closestDamagedAlly);
            }
            return;
        }
        const nearbyNukeRamparts = _.filter(this.colony.overlords.work.nukeDefenseRamparts, rampart => this.pos.getRangeTo(rampart) <= TOWER_OPTIMAL_RANGE);
        if (nearbyNukeRamparts.length > 0 && this.colony.terminal && !this.colony.state.isRebuilding) {
            const nukes = this.colony.room.find(FIND_NUKES);
            const timeToImpact = _.min(_.map(nukes, nuke => nuke.timeToLand));
            if (timeToImpact) {
                const repairHitsRemaining = _.sum(_.values(this.colony.overlords.work.nukeDefenseHitsRemaining));
                const hitsRepairedPerTick = this.towers.length * TOWER_POWER_REPAIR;
                if (repairHitsRemaining > 0.9 * hitsRepairedPerTick * timeToImpact) {
                    for (const tower of this.towers) {
                        tower.repair(nearbyNukeRamparts[0]);
                    }
                    return;
                }
            }
            else {
                log.warning(`No time to impact! (Why?)`);
            }
        }
        this.preventStructureDecay();
    }
    visuals() {
    }
};
SporeCrawler.settings = {
    requestThreshold: 500,
    criticalEnergyThreshold: 250,
};
SporeCrawler = SporeCrawler_1 = __decorate([
    profile
], SporeCrawler);

let UpgradingOverlord = class UpgradingOverlord extends Overlord {
    constructor(upgradeSite, priority = OverlordPriority.upgrading.upgrade) {
        super(upgradeSite, 'upgrade', priority);
        this.upgradeSite = upgradeSite;
        this.upgraders = this.zerg(Roles.upgrader);
    }
    init() {
        if (this.colony.level < 3) {
            return;
        }
        let setup = Setups.upgraders.default;
        if (this.colony.assets.energy > UpgradeSite.settings.energyBuffer
            || this.upgradeSite.controller.ticksToDowngrade < 500) {
            if (this.colony.level == 8) {
                setup = Setups.upgraders.rcl8;
                if (this.colony.labs.length == 10 &&
                    this.colony.assets[RESOURCE_CATALYZED_GHODIUM_ACID] >= 4 * LAB_BOOST_MINERAL) {
                    setup = Setups.upgraders.rcl8_boosted;
                }
            }
            if (this.colony.level == 8) {
                this.wishlist(1, setup);
                return;
            }
            const upgradePowerEach = setup.getBodyPotential(WORK, this.colony);
            const upgradersNeeded = Math.ceil(this.upgradeSite.upgradePowerNeeded / upgradePowerEach);
            this.wishlist(upgradersNeeded, setup);
        }
        this.wishlist(0, setup);
    }
    handleUpgrader(upgrader) {
        if (upgrader.carry.energy > 0) {
            if (this.upgradeSite.link && this.upgradeSite.link.hits < this.upgradeSite.link.hitsMax) {
                upgrader.task = Tasks.repair(this.upgradeSite.link);
                return;
            }
            if (this.upgradeSite.battery && this.upgradeSite.battery.hits < this.upgradeSite.battery.hitsMax) {
                upgrader.task = Tasks.repair(this.upgradeSite.battery);
                return;
            }
            const inputSite = this.upgradeSite.findInputConstructionSite();
            if (inputSite) {
                upgrader.task = Tasks.build(inputSite);
                return;
            }
            if (!this.upgradeSite.controller.signedByMe &&
                !this.upgradeSite.controller.signedByScreeps) {
                upgrader.task = Tasks.signController(this.upgradeSite.controller);
                return;
            }
            upgrader.task = Tasks.upgrade(this.upgradeSite.controller);
        }
        else {
            if (this.upgradeSite.link && this.upgradeSite.link.energy > 0) {
                upgrader.task = Tasks.withdraw(this.upgradeSite.link);
            }
            else if (this.upgradeSite.battery && this.upgradeSite.battery.energy > 0) {
                upgrader.task = Tasks.withdraw(this.upgradeSite.battery);
            }
            else {
                if (this.upgradeSite.battery && this.upgradeSite.battery.targetedBy.length == 0) {
                    upgrader.task = Tasks.recharge();
                }
            }
        }
    }
    run() {
        this.autoRun(this.upgraders, upgrader => this.handleUpgrader(upgrader));
    }
};
UpgradingOverlord = __decorate([
    profile
], UpgradingOverlord);

var UpgradeSite_1;
let UpgradeSite = UpgradeSite_1 = class UpgradeSite extends HiveCluster {
    constructor(colony, controller) {
        super(colony, controller, 'upgradeSite');
        this.controller = controller;
        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');
        this.upgradePowerNeeded = this.getUpgradePowerNeeded();
        $.set(this, 'battery', () => {
            const allowableContainers = _.filter(this.room.containers, container => container.pos.findInRange(FIND_SOURCES, 1).length == 0);
            return this.pos.findClosestByLimitedRange(allowableContainers, 3);
        });
        this.batteryPos = $.pos(this, 'batteryPos', () => {
            if (this.battery) {
                return this.battery.pos;
            }
            const inputSite = this.findInputConstructionSite();
            if (inputSite) {
                return inputSite.pos;
            }
            return this.calculateBatteryPos() || log.alert(`Upgrade site at ${this.pos.print}: no batteryPos!`);
        });
        if (this.batteryPos)
            this.colony.destinations.push({ pos: this.batteryPos, order: 0 });
        $.set(this, 'link', () => this.pos.findClosestByLimitedRange(colony.availableLinks, 3));
        this.colony.linkNetwork.claimLink(this.link);
        this.stats();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');
        $.refreshRoom(this);
        $.refresh(this, 'controller', 'battery', 'link');
    }
    spawnMoarOverlords() {
        this.overlord = new UpgradingOverlord(this);
    }
    findInputConstructionSite() {
        const nearbyInputSites = this.pos.findInRange(this.room.constructionSites, 4, {
            filter: (s) => s.structureType == STRUCTURE_CONTAINER ||
                s.structureType == STRUCTURE_LINK,
        });
        return _.first(nearbyInputSites);
    }
    getUpgradePowerNeeded() {
        return $.number(this, 'upgradePowerNeeded', () => {
            if (!this.room.storage)
                return 0;
            const amountOver = Math.max(this.colony.assets.energy - UpgradeSite_1.settings.energyBuffer, 0);
            let upgradePower = 1 + Math.floor(amountOver / UpgradeSite_1.settings.energyPerBodyUnit);
            if (amountOver > 800000) {
                upgradePower *= 4;
            }
            else if (amountOver > 500000) {
                upgradePower *= 2;
            }
            if (this.controller.level == 8) {
                if (this.colony.assets.energy < 30000) {
                    upgradePower = 0;
                }
                else {
                    upgradePower = Math.min(upgradePower, 15);
                }
            }
            else if (this.controller.level >= 6) {
                upgradePower = this.memory.speedFactor != undefined ? upgradePower * this.memory.speedFactor : upgradePower;
            }
            return upgradePower;
        });
    }
    init() {
        if (this.link && this.link.energy < UpgradeSite_1.settings.linksRequestBelow) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        const inThreshold = this.colony.stage == ColonyStage.Larva ? 0.75 : 0.5;
        if (this.battery) {
            if (this.colony.stage == ColonyStage.Larva) {
                if (this.battery.energy < inThreshold * this.battery.storeCapacity) {
                    const workers = this.colony.overlords.work.workers;
                    const energyPerTick = UPGRADE_CONTROLLER_POWER * _.sum(workers, worker => worker.getBodyparts(WORK));
                    this.colony.logisticsNetwork.requestInput(this.battery, { dAmountdt: energyPerTick });
                }
            }
            else {
                if (this.battery.energy < inThreshold * this.battery.storeCapacity) {
                    const energyPerTick = UPGRADE_CONTROLLER_POWER * this.upgradePowerNeeded;
                    this.colony.logisticsNetwork.requestInput(this.battery, { dAmountdt: energyPerTick });
                }
            }
            if (hasMinerals(this.battery.store)) {
                this.colony.logisticsNetwork.requestOutputMinerals(this.battery);
            }
        }
    }
    calculateBatteryPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        else {
            return;
        }
        let inputLocations = [];
        for (const pos of this.pos.getPositionsAtRange(2)) {
            if (pos.isWalkable(true)) {
                inputLocations.push(pos);
            }
        }
        const maxNeighbors = _.max(_.map(inputLocations, pos => pos.availableNeighbors(true).length));
        inputLocations = _.filter(inputLocations, pos => pos.availableNeighbors(true).length >= maxNeighbors);
        const inputPos = originPos.findClosestByPath(inputLocations);
        if (inputPos) {
            return inputPos;
        }
    }
    buildBatteryIfMissing() {
        if (!this.battery && !this.findInputConstructionSite()) {
            const buildHere = this.batteryPos;
            if (buildHere) {
                const result = buildHere.createConstructionSite(STRUCTURE_CONTAINER);
                if (result == OK) {
                    return;
                }
                else {
                    log.warning(`Upgrade site at ${this.pos.print}: cannot build battery! Result: ${result}`);
                }
            }
        }
    }
    stats() {
        const defaults = {
            downtime: 0,
        };
        if (!this.memory.stats)
            this.memory.stats = defaults;
        _.defaults(this.memory.stats, defaults);
        this.memory.stats.downtime = (this.memory.stats.downtime * (CREEP_LIFE_TIME - 1) +
            (this.battery ? +this.battery.isEmpty : 0)) / CREEP_LIFE_TIME;
        Stats.log(`colonies.${this.colony.name}.upgradeSite.downtime`, this.memory.stats.downtime);
    }
    run() {
        if (Game.time % 25 == 7 && this.colony.level >= 2) {
            this.buildBatteryIfMissing();
        }
    }
    visuals() {
    }
};
UpgradeSite.settings = {
    energyBuffer: 100000,
    energyPerBodyUnit: 20000,
    minLinkDistance: 10,
    linksRequestBelow: 200,
};
UpgradeSite = UpgradeSite_1 = __decorate([
    profile
], UpgradeSite);

let LinkNetwork = class LinkNetwork {
    constructor(colony) {
        this.colony = colony;
        this.receive = [];
        this.transmit = [];
        this.settings = {
            linksTransmitAt: LINK_CAPACITY - 100,
        };
    }
    refresh() {
        this.receive = [];
        this.transmit = [];
    }
    claimLink(link) {
        if (link) {
            _.remove(this.colony.availableLinks, l => l.id == link.id);
        }
    }
    requestReceive(link) {
        this.receive.push(link);
    }
    requestTransmit(link) {
        this.transmit.push(link);
    }
    getDropoffAvailability(link) {
        const dest = this.colony.commandCenter ? this.colony.commandCenter.pos : this.colony.pos;
        const usualCooldown = link.pos.getRangeTo(dest);
        if (link.energy > this.settings.linksTransmitAt) {
            return link.cooldown + usualCooldown;
        }
        else {
            return link.cooldown;
        }
    }
    init() {
    }
    run() {
        for (const receiveLink of this.receive) {
            const closestTransmitLink = receiveLink.pos.findClosestByRange(this.transmit);
            if (closestTransmitLink) {
                const amountToSend = _.min([closestTransmitLink.energy, receiveLink.energyCapacity - receiveLink.energy]);
                closestTransmitLink.transferEnergy(receiveLink, amountToSend);
                _.remove(this.transmit, link => link == closestTransmitLink);
            }
        }
        if (this.colony.commandCenter && this.colony.commandCenter.link) {
            let free = this.colony.commandCenter.link.store.getFreeCapacity(RESOURCE_ENERGY);
            for (const transmitLink of this.transmit) {
                if (free <= 0)
                    break;
                const available = transmitLink.store.getUsedCapacity(RESOURCE_ENERGY);
                if (free >= available) {
                    transmitLink.transferEnergy(this.colony.commandCenter.link);
                    free -= available;
                }
            }
        }
    }
};
LinkNetwork = __decorate([
    profile
], LinkNetwork);

'use strict';
var ansiRegex$1 = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

'use strict';
var ansiRegex = ansiRegex$1();

var stripAnsi = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

var clone_1 = createCommonjsModule(function (module) {
var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
};
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
};
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
};
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
};
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if ('object' === 'object' && module.exports) {
  module.exports = clone;
}
});

var defaults = function(options, defaults) {
  options = options || {};

  Object.keys(defaults).forEach(function(key) {
    if (typeof options[key] === 'undefined') {
      options[key] = clone_1(defaults[key]);
    }
  });

  return options;
};

var combining = [
    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],
    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],
    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],
    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],
    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],
    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],
    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],
    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],
    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],
    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],
    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],
    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],
    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],
    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],
    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],
    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],
    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],
    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],
    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],
    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],
    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],
    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],
    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],
    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],
    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],
    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],
    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],
    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],
    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],
    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],
    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],
    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],
    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],
    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],
    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],
    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],
    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],
    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],
    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],
    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],
    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],
    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],
    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],
    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],
    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],
    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],
    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],
    [ 0xE0100, 0xE01EF ]
];

"use strict";




var DEFAULTS$1 = {
  nul: 0,
  control: 0
};

var wcwidth_1 = function wcwidth(str) {
  return wcswidth(str, DEFAULTS$1)
};

var config = function(opts) {
  opts = defaults(opts || {}, DEFAULTS$1);
  return function wcwidth(str) {
    return wcswidth(str, opts)
  }
};

/*
 *  The following functions define the column width of an ISO 10646
 *  character as follows:
 *  - The null character (U+0000) has a column width of 0.
 *  - Other C0/C1 control characters and DEL will lead to a return value
 *    of -1.
 *  - Non-spacing and enclosing combining characters (general category
 *    code Mn or Me in the
 *    Unicode database) have a column width of 0.
 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
 *  - Other format characters (general category code Cf in the Unicode
 *    database) and ZERO WIDTH
 *    SPACE (U+200B) have a column width of 0.
 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *    have a column width of 0.
 *  - Spacing characters in the East Asian Wide (W) or East Asian
 *    Full-width (F) category as
 *    defined in Unicode Technical Report #11 have a column width of 2.
 *  - All remaining characters (including all printable ISO 8859-1 and
 *    WGL4 characters, Unicode control characters, etc.) have a column
 *    width of 1.
 *  This implementation assumes that characters are encoded in ISO 10646.
*/

function wcswidth(str, opts) {
  if (typeof str !== 'string') return wcwidth(str, opts)

  var s = 0;
  for (var i = 0; i < str.length; i++) {
    var n = wcwidth(str.charCodeAt(i), opts);
    if (n < 0) return -1
    s += n;
  }

  return s
}

function wcwidth(ucs, opts) {
  // test for 8-bit control characters
  if (ucs === 0) return opts.nul
  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control

  // binary search in table of non-spacing characters
  if (bisearch(ucs)) return 0

  // if we arrive here, ucs is not a combining or C0/C1 control character
  return 1 +
      (ucs >= 0x1100 &&
       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants
        ucs == 0x2329 || ucs == 0x232a ||
        (ucs >= 0x2e80 && ucs <= 0xa4cf &&
         ucs != 0x303f) ||                     // CJK ... Yi
        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs
        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms
        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
        (ucs >= 0xffe0 && ucs <= 0xffe6) ||
        (ucs >= 0x20000 && ucs <= 0x2fffd) ||
        (ucs >= 0x30000 && ucs <= 0x3fffd)));
}

function bisearch(ucs) {
  var min = 0;
  var max = combining.length - 1;
  var mid;

  if (ucs < combining[0][0] || ucs > combining[max][1]) return false

  while (max >= min) {
    mid = Math.floor((min + max) / 2);
    if (ucs > combining[mid][1]) min = mid + 1;
    else if (ucs < combining[mid][0]) max = mid - 1;
    else return true
  }

  return false
}
wcwidth_1.config = config;

var width = function(str) {
  return wcwidth_1(stripAnsi(str))
};

"use strict";



/**
 * repeat string `str` up to total length of `len`
 *
 * @param String str string to repeat
 * @param Number len total length of output string
 */

function repeatString(str, len) {
  return Array.apply(null, {length: len + 1}).join(str).slice(0, len)
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padRight$1(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - width(str);
  if (length <= 0) return str
  return str + repeatString(chr || ' ', length)
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padCenter will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padCenter$1(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - width(str);
  if (length <= 0) return str
  var lengthLeft = Math.floor(length/2);
  var lengthRight = length - lengthLeft;
  return repeatString(chr || ' ', lengthLeft) + str + repeatString(chr || ' ', lengthRight)
}

/**
 * Pad `str` up to total length `max` with `chr`, on the left.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padLeft$1(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - width(str);
  if (length <= 0) return str
  return repeatString(chr || ' ', length) + str
}

/**
 * Split a String `str` into lines of maxiumum length `max`.
 * Splits on word boundaries. Preserves existing new lines.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @return Array Array containing lines.
 */

function splitIntoLines$1(str, max) {
  function _splitIntoLines(str, max) {
    return str.trim().split(' ').reduce(function(lines, word) {
      var line = lines[lines.length - 1];
      if (line && width(line.join(' ')) + width(word) < max) {
        lines[lines.length - 1].push(word); // add to line
      }
      else lines.push([word]); // new line
      return lines
    }, []).map(function(l) {
      return l.join(' ')
    })
  }
  return str.split('\n').map(function(str) {
    return _splitIntoLines(str, max)
  }).reduce(function(lines, line) {
    return lines.concat(line)
  }, [])
}

/**
 * Add spaces and `truncationChar` between words of
 * `str` which are longer than `max`.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @param Number truncationChar character to append to split words
 * @return String
 */

function splitLongWords$1(str, max, truncationChar) {
  str = str.trim();
  var result = [];
  var words = str.split(' ');
  var remainder = '';

  var truncationWidth = width(truncationChar);

  while (remainder || words.length) {
    if (remainder) {
      var word = remainder;
      remainder = '';
    } else {
      var word = words.shift();
    }

    if (width(word) > max) {
      // slice is based on length no wcwidth
      var i = 0;
      var wwidth = 0;
      var limit = max - truncationWidth;
      while (i < word.length) {
        var w = width(word.charAt(i));
        if (w + wwidth > limit) {
          break
        }
        wwidth += w;
        ++i;
      }

      remainder = word.slice(i); // get remainder
      // save remainder for next loop

      word = word.slice(0, i); // grab truncated word
      word += truncationChar; // add trailing … or whatever
    }
    result.push(word);
  }

  return result.join(' ')
}


/**
 * Truncate `str` into total width `max`
 * If `str` is shorter than `max`,  will return `str` unaltered.
 *
 * @param String str string to truncated
 * @param Number max total wcwidth of output string
 * @return String truncated str
 */

function truncateString$1(str, max) {

  str = str != null ? str : '';
  str = String(str);

  if(max == Infinity) return str

  var i = 0;
  var wwidth = 0;
  while (i < str.length) {
    var w = width(str.charAt(i));
    if(w + wwidth > max)
      break
    wwidth += w;
    ++i;
  }
  return str.slice(0, i)
}



/**
 * Exports
 */

var padRight_1 = padRight$1;
var padCenter_1 = padCenter$1;
var padLeft_1 = padLeft$1;
var splitIntoLines_1 = splitIntoLines$1;
var splitLongWords_1 = splitLongWords$1;
var truncateString_1 = truncateString$1;

var utils = {
	padRight: padRight_1,
	padCenter: padCenter_1,
	padLeft: padLeft_1,
	splitIntoLines: splitIntoLines_1,
	splitLongWords: splitLongWords_1,
	truncateString: truncateString_1
};

"use strict";





var padRight = utils.padRight;
var padCenter = utils.padCenter;
var padLeft = utils.padLeft;
var splitIntoLines = utils.splitIntoLines;
var splitLongWords = utils.splitLongWords;
var truncateString = utils.truncateString;

var DEFAULT_HEADING_TRANSFORM = function DEFAULT_HEADING_TRANSFORM(key) {
  return key.toUpperCase();
};

var DEFAULT_DATA_TRANSFORM = function DEFAULT_DATA_TRANSFORM(cell, column, index) {
  return cell;
};

var DEFAULTS = Object.freeze({
  maxWidth: Infinity,
  minWidth: 0,
  columnSplitter: ' ',
  truncate: false,
  truncateMarker: '…',
  preserveNewLines: false,
  paddingChr: ' ',
  showHeaders: true,
  headingTransform: DEFAULT_HEADING_TRANSFORM,
  dataTransform: DEFAULT_DATA_TRANSFORM
});

var columnify = function (items) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var columnConfigs = options.config || {};
  delete options.config; // remove config so doesn't appear on every column.

  var maxLineWidth = options.maxLineWidth || Infinity;
  if (maxLineWidth === 'auto') maxLineWidth = process.stdout.columns || Infinity;
  delete options.maxLineWidth; // this is a line control option, don't pass it to column

  // Option defaults inheritance:
  // options.config[columnName] => options => DEFAULTS
  options = mixin({}, DEFAULTS, options);

  options.config = options.config || Object.create(null);

  options.spacing = options.spacing || '\n'; // probably useless
  options.preserveNewLines = !!options.preserveNewLines;
  options.showHeaders = !!options.showHeaders;
  options.columns = options.columns || options.include; // alias include/columns, prefer columns if supplied
  var columnNames = options.columns || []; // optional user-supplied columns to include

  items = toArray(items, columnNames);

  // if not suppled column names, automatically determine columns from data keys
  if (!columnNames.length) {
    items.forEach(function (item) {
      for (var columnName in item) {
        if (columnNames.indexOf(columnName) === -1) columnNames.push(columnName);
      }
    });
  }

  // initialize column defaults (each column inherits from options.config)
  var columns = columnNames.reduce(function (columns, columnName) {
    var column = Object.create(options);
    columns[columnName] = mixin(column, columnConfigs[columnName]);
    return columns;
  }, Object.create(null));

  // sanitize column settings
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.name = columnName;
    column.maxWidth = Math.ceil(column.maxWidth);
    column.minWidth = Math.ceil(column.minWidth);
    column.truncate = !!column.truncate;
    column.align = column.align || 'left';
  });

  // sanitize data
  items = items.map(function (item) {
    var result = Object.create(null);
    columnNames.forEach(function (columnName) {
      // null/undefined -> ''
      result[columnName] = item[columnName] != null ? item[columnName] : '';
      // toString everything
      result[columnName] = '' + result[columnName];
      if (columns[columnName].preserveNewLines) {
        // merge non-newline whitespace chars
        result[columnName] = result[columnName].replace(/[^\S\n]/gmi, ' ');
      } else {
        // merge all whitespace chars
        result[columnName] = result[columnName].replace(/\s/gmi, ' ');
      }
    });
    return result;
  });

  // transform data cells
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item, index) {
      var col = Object.create(column);
      item[columnName] = column.dataTransform(item[columnName], col, index);

      var changedKeys = Object.keys(col);
      // disable default heading transform if we wrote to column.name
      if (changedKeys.indexOf('name') !== -1) {
        if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM) return;
        column.headingTransform = function (heading) {
          return heading;
        };
      }
      changedKeys.forEach(function (key) {
        return column[key] = col[key];
      });
      return item;
    });
  });

  // add headers
  var headers = {};
  if (options.showHeaders) {
    columnNames.forEach(function (columnName) {
      var column = columns[columnName];

      if (!column.showHeaders) {
        headers[columnName] = '';
        return;
      }

      headers[columnName] = column.headingTransform(column.name);
    });
    items.unshift(headers);
  }
  // get actual max-width between min & max
  // based on length of data in columns
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.width = items.map(function (item) {
      return item[columnName];
    }).reduce(function (min, cur) {
      // if already at maxWidth don't bother testing
      if (min >= column.maxWidth) return min;
      return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, width(cur))));
    }, 0);
  });

  // split long words so they can break onto multiple lines
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item) {
      item[columnName] = splitLongWords(item[columnName], column.width, column.truncateMarker);
      return item;
    });
  });

  // wrap long lines. each item is now an array of lines.
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item, index) {
      var cell = item[columnName];
      item[columnName] = splitIntoLines(cell, column.width);

      // if truncating required, only include first line + add truncation char
      if (column.truncate && item[columnName].length > 1) {
        item[columnName] = splitIntoLines(cell, column.width - width(column.truncateMarker));
        var firstLine = item[columnName][0];
        if (!endsWith(firstLine, column.truncateMarker)) item[columnName][0] += column.truncateMarker;
        item[columnName] = item[columnName].slice(0, 1);
      }
      return item;
    });
  });

  // recalculate column widths from truncated output/lines
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.width = items.map(function (item) {
      return item[columnName].reduce(function (min, cur) {
        if (min >= column.maxWidth) return min;
        return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, width(cur))));
      }, 0);
    }).reduce(function (min, cur) {
      if (min >= column.maxWidth) return min;
      return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, cur)));
    }, 0);
  });

  var rows = createRows(items, columns, columnNames, options.paddingChr); // merge lines into rows
  // conceive output
  return rows.reduce(function (output, row) {
    return output.concat(row.reduce(function (rowOut, line) {
      return rowOut.concat(line.join(options.columnSplitter));
    }, []));
  }, []).map(function (line) {
    return truncateString(line, maxLineWidth);
  }).join(options.spacing);
};

/**
 * Convert wrapped lines into rows with padded values.
 *
 * @param Array items data to process
 * @param Array columns column width settings for wrapping
 * @param Array columnNames column ordering
 * @return Array items wrapped in arrays, corresponding to lines
 */

function createRows(items, columns, columnNames, paddingChr) {
  return items.map(function (item) {
    var row = [];
    var numLines = 0;
    columnNames.forEach(function (columnName) {
      numLines = Math.max(numLines, item[columnName].length);
    });
    // combine matching lines of each rows

    var _loop = function _loop(i) {
      row[i] = row[i] || [];
      columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        var val = item[columnName][i] || ''; // || '' ensures empty columns get padded
        if (column.align === 'right') row[i].push(padLeft(val, column.width, paddingChr));else if (column.align === 'center' || column.align === 'centre') row[i].push(padCenter(val, column.width, paddingChr));else row[i].push(padRight(val, column.width, paddingChr));
      });
    };

    for (var i = 0; i < numLines; i++) {
      _loop(i);
    }
    return row;
  });
}

/**
 * Object.assign
 *
 * @return Object Object with properties mixed in.
 */

function mixin() {
  var _Object;

  if (Object.assign) return (_Object = Object).assign.apply(_Object, arguments);
  return ObjectAssign.apply(undefined, arguments);
}

function ObjectAssign(target, firstSource) {
  "use strict";

  if (target === undefined || target === null) throw new TypeError("Cannot convert first argument to object");

  var to = Object(target);

  var hasPendingException = false;
  var pendingException;

  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) continue;

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      try {
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
      } catch (e) {
        if (!hasPendingException) {
          hasPendingException = true;
          pendingException = e;
        }
      }
    }

    if (hasPendingException) throw pendingException;
  }
  return to;
}

/**
 * Adapted from String.prototype.endsWith polyfill.
 */

function endsWith(target, searchString, position) {
  position = position || target.length;
  position = position - searchString.length;
  var lastIndex = target.lastIndexOf(searchString);
  return lastIndex !== -1 && lastIndex === position;
}

function toArray(items, columnNames) {
  if (Array.isArray(items)) return items;
  var rows = [];
  for (var key in items) {
    var item = {};
    item[columnNames[0] || 'key'] = key;
    item[columnNames[1] || 'value'] = items[key];
    rows.push(item);
  }
  return rows;
}
var columnify_1 = columnify.columnify;

let Matcher = class Matcher {
    constructor(menPrefs, womenPrefs) {
        this.menPrefs = menPrefs;
        this.womenPrefs = womenPrefs;
        this.men = _.keys(menPrefs);
        this.women = _.keys(womenPrefs);
        this.menFree = _.zipObject(this.men, _.map(this.men, man => true));
        this.womenFree = _.zipObject(this.women, _.map(this.women, woman => true));
        this.couples = {};
    }
    prefers(woman, man1, man2) {
        return _.indexOf(this.womenPrefs[woman], man1) < _.indexOf(this.womenPrefs[woman], man2);
    }
    engage(man, woman) {
        this.menFree[man] = false;
        this.womenFree[woman] = false;
        _.remove(this.menPrefs[man], w => w == woman);
        this.couples[man] = woman;
    }
    breakup(man, woman) {
        this.menFree[man] = true;
        this.womenFree[woman] = true;
        delete this.couples[man];
    }
    nextMan() {
        return _.find(this.men, man => this.menFree[man] && this.menPrefs[man].length > 0);
    }
    match() {
        const MAX_ITERATIONS = 1000;
        let count = 0;
        let man = this.nextMan();
        while (man) {
            if (count > MAX_ITERATIONS) {
                console.log('Stable matching timed out!');
                return this.couples;
            }
            const woman = _.first(this.menPrefs[man]);
            if (this.womenFree[woman]) {
                this.engage(man, woman);
            }
            else {
                const currentMan = _.findKey(this.couples, w => w == woman);
                if (this.prefers(woman, man, currentMan)) {
                    this.breakup(currentMan, woman);
                    this.engage(man, woman);
                }
                else {
                    _.remove(this.menPrefs[man], w => w == woman);
                }
            }
            man = this.nextMan();
            count++;
        }
        return this.couples;
    }
};
Matcher = __decorate([
    profile
], Matcher);

var LogisticsNetwork_1;
const ALL_RESOURCE_TYPE_ERROR = `Improper logistics request: 'all' can only be used for store structure, tombstone or ruin!`;
const getDefaultLogisticsMemory = () => ({
    transporterCache: {},
});
let LogisticsNetwork = LogisticsNetwork_1 = class LogisticsNetwork {
    constructor(colony) {
        this.memory = Mem.wrap(colony.memory, 'logisticsNetwork', getDefaultLogisticsMemory);
        this.requests = [];
        this.targetToRequest = {};
        this.colony = colony;
        this.buffers = _.compact([colony.storage, colony.terminal]);
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {}
        };
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'logisticsNetwork', getDefaultLogisticsMemory);
        this.requests = [];
        this.targetToRequest = {};
        this._matching = undefined;
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {}
        };
    }
    requestInput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });
        if (target.room != this.colony.room) {
            log.warning(`${target.ref} at ${target.pos.print} is outside colony room; shouldn't request!`);
            return;
        }
        if (opts.resourceType == 'all') {
            log.warning(`Logistics request error: 'all' can only be used for output requests`);
            return;
        }
        if (!opts.amount) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    requestOutput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });
        if (opts.resourceType == 'all' && !isResource(target)) {
            if (_.sum(target.store) == target.store.energy) {
                opts.resourceType = RESOURCE_ENERGY;
            }
        }
        if (!opts.amount) {
            opts.amount = this.getOutputAmount(target, opts.resourceType);
        }
        opts.amount *= -1;
        (opts.dAmountdt) *= -1;
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    requestOutputMinerals(target, opts = {}) {
        for (const [resourceType, amount] of target.store.contents) {
            if (resourceType == RESOURCE_ENERGY)
                continue;
            if (amount > 0) {
                opts.resourceType = resourceType;
                this.requestOutput(target, opts);
            }
        }
    }
    getInputAmount(target, resourceType) {
        if (isResource(target) || isTombstone(target) || isRuin(target)) {
            log.error(`Improper logistics request: should not request input for resource or tombstone!`);
            return 0;
        }
        else if (isDirective(target)) {
            return target.memory.amount - target.store[resourceType];
        }
        else {
            return target.store.getFreeCapacity(resourceType) || 0;
        }
    }
    getOutputAmount(target, resourceType) {
        if (resourceType == 'all') {
            if (isResource(target)) {
                log.error(ALL_RESOURCE_TYPE_ERROR);
                return 0;
            }
            else {
                return target.store.getUsedCapacity() || 0;
            }
        }
        else {
            if (isResource(target)) {
                return target.amount;
            }
            else {
                return target.store.getUsedCapacity(resourceType) || 0;
            }
        }
    }
    computeNextAvailability(transporter) {
        if (transporter.task) {
            let approximateDistance = transporter.task.eta;
            const targetPositions = transporter.task.targetPosManifest;
            let pos = targetPositions.shift();
            if (approximateDistance) {
                for (const targetPos of targetPositions) {
                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos)
                        * LogisticsNetwork_1.settings.rangeToPathHeuristic);
                    pos = targetPos;
                }
            }
            else {
                approximateDistance = 0;
                for (const targetPos of targetPositions) {
                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos)
                        * LogisticsNetwork_1.settings.rangeToPathHeuristic);
                    pos = targetPos;
                }
            }
            return [approximateDistance, pos];
        }
        else {
            return [0, transporter.pos];
        }
    }
    nextAvailability(transporter) {
        if (!this.cache.nextAvailability[transporter.name]) {
            this.cache.nextAvailability[transporter.name] = this.computeNextAvailability(transporter);
        }
        return this.cache.nextAvailability[transporter.name];
    }
    static targetingTransporters(target, excludedTransporter) {
        const targetingZerg = _.map(target.targetedBy, name => Overmind.zerg[name]);
        const targetingTransporters = _.filter(targetingZerg, zerg => zerg.roleName == Roles.transport);
        if (excludedTransporter) {
            _.remove(targetingTransporters, transporter => transporter.name == excludedTransporter.name);
        }
        return targetingTransporters;
    }
    computePredictedTransporterCarry(transporter, nextAvailability) {
        if (transporter.task && transporter.task.target) {
            const requestID = this.targetToRequest[transporter.task.target.ref];
            if (requestID) {
                const request = this.requests[requestID];
                if (request) {
                    const carry = transporter.carry;
                    const remainingCapacity = transporter.carryCapacity - _.sum(carry);
                    const resourceAmount = -1 * this.predictedRequestAmount(transporter, request, nextAvailability);
                    if (request.resourceType == 'all') {
                        if (isResource(request.target)) {
                            log.error(ALL_RESOURCE_TYPE_ERROR);
                            return { energy: 0 };
                        }
                        for (const [resourceType, storeAmt] of request.target.store.contents) {
                            const resourceFraction = storeAmt / _.sum(request.target.store);
                            if (carry[resourceType]) {
                                carry[resourceType] += resourceAmount * resourceFraction;
                                carry[resourceType] = minMax(carry[resourceType], 0, remainingCapacity);
                            }
                            else {
                                carry[resourceType] = minMax(resourceAmount, 0, remainingCapacity);
                            }
                        }
                    }
                    else {
                        if (carry[request.resourceType]) {
                            carry[request.resourceType] += resourceAmount;
                            carry[request.resourceType] = minMax(carry[request.resourceType], 0, remainingCapacity);
                        }
                        else {
                            carry[request.resourceType] = minMax(resourceAmount, 0, remainingCapacity);
                        }
                    }
                    return carry;
                }
            }
        }
        return transporter.carry;
    }
    predictedTransporterCarry(transporter) {
        if (!this.cache.predictedTransporterCarry[transporter.name]) {
            this.cache.predictedTransporterCarry[transporter.name] = this.computePredictedTransporterCarry(transporter);
        }
        return this.cache.predictedTransporterCarry[transporter.name];
    }
    predictedRequestAmount(transporter, request, nextAvailability) {
        let busyUntil;
        let newPos;
        if (!nextAvailability) {
            [busyUntil, newPos] = this.nextAvailability(transporter);
        }
        else {
            [busyUntil, newPos] = nextAvailability;
        }
        const eta = busyUntil + LogisticsNetwork_1.settings.rangeToPathHeuristic *
            newPos.getMultiRoomRangeTo(request.target.pos);
        const predictedDifference = request.dAmountdt * eta;
        const otherTargetingTransporters = LogisticsNetwork_1.targetingTransporters(request.target, transporter);
        if (request.amount > 0) {
            let predictedAmount = request.amount + predictedDifference;
            if (!isResource(request.target)) {
                predictedAmount = minMax(predictedAmount, 0, request.target.store.getCapacity(request.resourceType));
            }
            const resourceInflux = _.sum(_.map(otherTargetingTransporters, other => (other.carry[request.resourceType] || 0)));
            predictedAmount = Math.max(predictedAmount - resourceInflux, 0);
            return predictedAmount;
        }
        else {
            let predictedAmount = request.amount + predictedDifference;
            if (!isResource(request.target)) {
                predictedAmount = minMax(predictedAmount, -1 * request.target.store.getCapacity(request.resourceType), 0);
            }
            const resourceOutflux = _.sum(_.map(otherTargetingTransporters, other => other.carryCapacity - _.sum(other.carry)));
            predictedAmount = Math.min(predictedAmount + resourceOutflux, 0);
            return predictedAmount;
        }
    }
    bufferChoices(transporter, request) {
        const [ticksUntilFree, newPos] = this.nextAvailability(transporter);
        const choices = [];
        const amount = this.predictedRequestAmount(transporter, request, [ticksUntilFree, newPos]);
        let carry;
        if (!transporter.task || transporter.task.target != request.target) {
            carry = this.predictedTransporterCarry(transporter);
        }
        else {
            carry = transporter.carry;
        }
        if (amount > 0) {
            if (request.resourceType == 'all') {
                log.warning(`Improper resourceType in bufferChoices! Type 'all' is only allowable for outputs!`);
                return [];
            }
            const dQ_direct = Math.min(amount, carry[request.resourceType] || 0);
            const dt_direct = ticksUntilFree + newPos.getMultiRoomRangeTo(request.target.pos)
                * LogisticsNetwork_1.settings.rangeToPathHeuristic;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref
            });
            if ((carry[request.resourceType] || 0) > amount || _.sum(carry) == transporter.carryCapacity) {
                return choices;
            }
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(amount, transporter.carryCapacity, buffer.store[request.resourceType] || 0);
                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) * LogisticsNetwork_1.settings.rangeToPathHeuristic
                    + (Pathing.distance(buffer.pos, request.target.pos) || Infinity) + ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref
                });
            }
        }
        else if (amount < 0) {
            const remainingCarryCapacity = transporter.carryCapacity - _.sum(carry);
            const dQ_direct = Math.min(Math.abs(amount), remainingCarryCapacity);
            const dt_direct = newPos.getMultiRoomRangeTo(request.target.pos)
                * LogisticsNetwork_1.settings.rangeToPathHeuristic + ticksUntilFree;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref
            });
            if (remainingCarryCapacity >= Math.abs(amount) || remainingCarryCapacity == transporter.carryCapacity) {
                return choices;
            }
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(Math.abs(amount), transporter.carryCapacity, buffer.storeCapacity - _.sum(buffer.store));
                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) * LogisticsNetwork_1.settings.rangeToPathHeuristic
                    + (Pathing.distance(buffer.pos, request.target.pos) || Infinity) + ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref
                });
            }
        }
        return choices;
    }
    resourceChangeRate(transporter, request) {
        if (!this.cache.resourceChangeRate[request.id]) {
            this.cache.resourceChangeRate[request.id] = {};
        }
        if (!this.cache.resourceChangeRate[request.id][transporter.name]) {
            const choices = this.bufferChoices(transporter, request);
            const dQ_dt = _.map(choices, choice => request.multiplier * choice.dQ / Math.max(choice.dt, 0.1));
            this.cache.resourceChangeRate[request.id][transporter.name] = _.max(dQ_dt);
        }
        return this.cache.resourceChangeRate[request.id][transporter.name];
    }
    requestPreferences(request, transporters) {
        return _.sortBy(transporters, transporter => -1 * this.resourceChangeRate(transporter, request));
    }
    transporterPreferences(transporter) {
        return _.sortBy(this.requests, request => -1 * this.resourceChangeRate(transporter, request));
    }
    invalidateCache(transporter, request) {
        delete this.cache.nextAvailability[transporter.name];
        delete this.cache.predictedTransporterCarry[transporter.name];
        delete this.cache.resourceChangeRate[request.id][transporter.name];
    }
    summarizeMatching() {
        const requests = this.requests.slice();
        const transporters = _.filter(this.colony.getCreepsByRole(Roles.transport), creep => !creep.spawning);
        const unmatchedTransporters = _.remove(transporters, transporter => !_.keys(this._matching).includes(transporter.name));
        const unmatchedRequests = _.remove(requests, request => !_.values(this._matching).includes(request));
        console.log(`Stable matching for ${this.colony.name} at ${Game.time}`);
        for (const transporter of transporters) {
            const transporterStr = transporter.name + ' ' + transporter.pos;
            const request = this._matching[transporter.name];
            const requestStr = request.target.ref + ' ' + request.target.pos.print;
            console.log(`${transporterStr.padRight(35)} : ${requestStr}`);
        }
        for (const transporter of unmatchedTransporters) {
            const transporterStr = transporter.name + ' ' + transporter.pos;
            console.log(`${transporterStr.padRight(35)} : ${''}`);
        }
        for (const request of unmatchedRequests) {
            const requestStr = request.target.ref + ' ' + request.target.pos;
            console.log(`${''.padRight(35)} : ${requestStr}`);
        }
        console.log();
    }
    summarize() {
        let info = [];
        for (const request of this.requests) {
            let targetType;
            if (isDirective(request.target)) {
                targetType = 'directive';
            }
            else if (isAnyZerg(request.target)) {
                targetType = 'zerg';
            }
            else if (isResource(request.target)) {
                targetType = 'resource';
            }
            else if (isTombstone(request.target)) {
                targetType = 'tombstone';
            }
            else if (isRuin(request.target)) {
                targetType = 'ruin';
            }
            else {
                targetType = request.target.structureType;
            }
            let amount = 0;
            if (isResource(request.target)) {
                amount = request.target.amount;
            }
            else {
                if (request.resourceType == 'all') {
                    if (!isResource(request.target)) {
                        amount = _.sum(request.target.store);
                    }
                    else {
                        amount = -0.001;
                    }
                }
                else {
                    if (isResource(request.target)) {
                        amount = request.target.amount;
                    }
                    else {
                        amount = request.target.store[request.resourceType];
                    }
                }
            }
            const targetingTprtrNames = _.map(LogisticsNetwork_1.targetingTransporters(request.target), c => c.name);
            info.push({
                target: targetType,
                resourceType: request.resourceType,
                requestAmount: request.amount,
                currentAmount: amount,
                targetedBy: targetingTprtrNames,
                pos: request.target.pos.print,
            });
        }
        console.log('Requests: \n' + columnify(info) + '\n');
        info = [];
        for (const transporter of this.colony.overlords.logistics.transporters) {
            const task = transporter.task ? transporter.task.name : 'none';
            const target = transporter.task ?
                transporter.task.proto._target.ref + ' ' + transporter.task.targetPos.printPlain : 'none';
            const nextAvailability = this.nextAvailability(transporter);
            info.push({
                creep: transporter.name,
                pos: transporter.pos.printPlain,
                task: task,
                target: target,
                availability: `available in ${nextAvailability[0]} ticks at ${nextAvailability[1].print}`,
            });
        }
        console.log('Transporters: \n' + columnify(info) + '\n');
    }
    get matching() {
        if (!this._matching) {
            this._matching = this.stableMatching(this.colony.overlords.logistics.transporters);
        }
        return this._matching;
    }
    stableMatching(transporters) {
        const tPrefs = {};
        for (const transporter of transporters) {
            tPrefs[transporter.name] = _.map(this.transporterPreferences(transporter), request => request.id);
        }
        const rPrefs = {};
        for (const request of this.requests) {
            rPrefs[request.id] = _.map(this.requestPreferences(request, transporters), transporter => transporter.name);
        }
        const stableMatching = new Matcher(tPrefs, rPrefs).match();
        const requestMatch = _.mapValues(stableMatching, reqID => _.find(this.requests, request => request.id == reqID));
        return requestMatch;
    }
};
LogisticsNetwork.settings = {
    flagDropAmount: 1000,
    rangeToPathHeuristic: 1.1,
    carryThreshold: 800,
    droppedEnergyThreshold: 200,
};
LogisticsNetwork = LogisticsNetwork_1 = __decorate([
    profile
], LogisticsNetwork);

var RoadLogistics_1;
const ROAD_CACHE_TIMEOUT = 25;
let RoadLogistics = RoadLogistics_1 = class RoadLogistics {
    constructor(colony) {
        this.colony = colony;
        this.ref = this.colony.name + ':roadLogistics';
        this._assignedWorkers = {};
    }
    refresh() {
        this._assignedWorkers = {};
    }
    workerShouldRepaveRoom(worker, room) {
        const otherAssignedWorkers = _.filter(this.assignedWorkers(room), name => name != worker.name);
        if (otherAssignedWorkers.length < RoadLogistics_1.settings.allowedPaversPerRoom) {
            if (this.assignedWorkers(room).includes(worker.name)) {
                return this.repairableRoads(room).length > 0;
            }
            else {
                return this.criticalRoads(room).length > 0 || this.energyToRepave(room.name) >= worker.carryCapacity;
            }
        }
        else {
            return false;
        }
    }
    workerShouldRepave(worker) {
        if (worker.task && worker.task.name == repairTaskName) {
            const room = Game.rooms[worker.task.targetPos.roomName];
            if (room && this.assignedWorkers(room).includes(worker.name)
                && this.workerShouldRepaveRoom(worker, room)) {
                return room;
            }
        }
        for (const room of this.colony.rooms) {
            if (this.colony.isRoomActive(room.name) && room.isSafe && this.workerShouldRepaveRoom(worker, room)) {
                return room;
            }
        }
    }
    criticalRoads(room) {
        return $.structures(this, 'criticalRoads:' + room.name, () => {
            const criticalRoads = _.filter(room.roads, road => road.hits < road.hitsMax * RoadLogistics_1.settings.criticalThreshold
                && this.colony.roomPlanner.roadShouldBeHere(road.pos));
            return _.sortBy(criticalRoads, road => road.pos.getMultiRoomRangeTo(this.colony.pos));
        }, ROAD_CACHE_TIMEOUT);
    }
    repairableRoads(room) {
        return $.structures(this, 'repairableRoads:' + room.name, () => {
            const repairRoads = _.filter(room.roads, road => road.hits < road.hitsMax * RoadLogistics_1.settings.repairThreshold
                && this.colony.roomPlanner.roadShouldBeHere(road.pos));
            return _.sortBy(repairRoads, road => road.pos.getMultiRoomRangeTo(this.colony.pos));
        }, ROAD_CACHE_TIMEOUT);
    }
    unbuiltRoads(room) {
        return $.list(this, 'repairableRoads:' + room.name, () => {
            const roadPositions = this.colony.roomPlanner.roadPlanner.getRoadPositions(room.name);
            const unbuiltPositions = _.filter(roadPositions, pos => !pos.lookForStructure(STRUCTURE_ROAD));
            return _.sortBy(unbuiltPositions, pos => pos.getMultiRoomRangeTo(this.colony.pos));
        }, ROAD_CACHE_TIMEOUT);
    }
    energyToRepave(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return $.number(this, 'energyToRepave:' + room.name, () => {
                const repairEnergy = _.sum(this.repairableRoads(room), road => (road.hitsMax - road.hits))
                    / REPAIR_POWER;
                const terrain = room.getTerrain();
                const buildEnergy = _.sum(this.unbuiltRoads(room), pos => {
                    if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP) {
                        return CONSTRUCTION_COST.road * CONSTRUCTION_COST_ROAD_SWAMP_RATIO;
                    }
                    else if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {
                        return CONSTRUCTION_COST.road * CONSTRUCTION_COST_ROAD_WALL_RATIO;
                    }
                    else {
                        return CONSTRUCTION_COST.road;
                    }
                }) / BUILD_POWER;
                return repairEnergy + buildEnergy;
            }, ROAD_CACHE_TIMEOUT);
        }
        else {
            const cached = $.numberRecall(this, 'energyToRepave:' + roomName);
            if (cached) {
                return cached;
            }
            else {
                return 0;
            }
        }
    }
    registerWorkerAssignment(worker, room) {
        if (this._assignedWorkers[room.name]) {
            if (!this._assignedWorkers[room.name].includes(worker.name)) {
                this._assignedWorkers[room.name].push(worker.name);
            }
        }
        else {
            this._assignedWorkers[room.name] = [worker.name];
        }
    }
    assignedWorkers(room) {
        return this._assignedWorkers[room.name] || [];
    }
    init() {
        const workers = this.colony.overlords.work.workers;
        for (const worker of workers) {
            if (worker.task && worker.task.name == repairTaskName) {
                const roomName = worker.task.targetPos.roomName;
                if (!this._assignedWorkers[roomName]) {
                    this._assignedWorkers[roomName] = [];
                }
                this._assignedWorkers[roomName].push(worker.name);
            }
        }
    }
    buildPavingManifest(worker, room) {
        let energy = worker.carry.energy;
        const targetRefs = {};
        const tasks = [];
        let target;
        let previousPos;
        while (true) {
            if (energy <= 0)
                break;
            if (previousPos) {
                target = _.find(this.repairableRoads(room), road => road.hits < road.hitsMax && !targetRefs[road.id]
                    && road.pos.getRangeTo(previousPos) <= 1);
            }
            else {
                target = _.find(this.repairableRoads(room), road => road.hits < road.hitsMax && !targetRefs[road.id]);
            }
            if (target) {
                previousPos = target.pos;
                targetRefs[target.id] = true;
                energy -= (target.hitsMax - target.hits) / REPAIR_POWER;
                tasks.push(Tasks.repair(target));
            }
            else {
                break;
            }
        }
        return Tasks.chain(tasks);
    }
    run() {
    }
};
RoadLogistics.settings = {
    allowedPaversPerRoom: 1,
    criticalThreshold: 0.25,
    repairThreshold: 0.9
};
RoadLogistics = RoadLogistics_1 = __decorate([
    profile
], RoadLogistics);

let DefaultOverlord = class DefaultOverlord extends Overlord {
    constructor(colony) {
        super(colony, 'default', OverlordPriority.default);
        this.idleZerg = [];
    }
    init() {
        const idleCreeps = _.filter(this.colony.creeps, creep => !getOverlord(creep));
        this.idleZerg = _.map(idleCreeps, creep => Overmind.zerg[creep.name] || new Zerg(creep));
        for (const zerg of this.idleZerg) {
            zerg.refresh();
        }
    }
    refresh() {
    }
    run() {
    }
};
DefaultOverlord = __decorate([
    profile
], DefaultOverlord);

const MAX_TRANSPORTER = 10;
const getDefaultTransportOverlordMemory = () => ({
    transporterSaturation: .1,
});
let TransportOverlord = class TransportOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.transport) {
        super(colony, 'logistics', priority, getDefaultTransportOverlordMemory);
        this.transporters = this.zerg(Roles.transport);
    }
    neededTransportPower() {
        var _a;
        let transportPower = 0;
        const scaling = this.colony.stage == ColonyStage.Larva ? 1.5 : 2.0;
        for (const flagName in this.colony.miningSites) {
            const miningOverlord = this.colony.miningSites[flagName].overlords.mine;
            if (!miningOverlord.isSuspended && miningOverlord.miners.length > 0) {
                if ((miningOverlord.container && !miningOverlord.link) || miningOverlord.allowDropMining) {
                    transportPower += miningOverlord.energyPerTick * scaling * miningOverlord.distance;
                }
            }
        }
        if (this.colony.upgradeSite.battery) {
            transportPower += UPGRADE_CONTROLLER_POWER * this.colony.upgradeSite.upgradePowerNeeded * scaling *
                ((_a = Pathing.distance(this.colony.pos, this.colony.upgradeSite.battery.pos)) !== null && _a !== void 0 ? _a : 0);
        }
        if (this.colony.state.lowPowerMode) {
            transportPower *= 0.5;
        }
        var minTransportPower = 6;
        if (!this.colony.storage
            && !(this.colony.hatchery && this.colony.hatchery.batteries.length > 0)
            && !this.colony.upgradeSite.battery) {
            return minTransportPower;
        }
        return transportPower / CARRY_CAPACITY;
    }
    init() {
        const ROAD_COVERAGE_THRESHOLD = 0.75;
        const setup = this.colony.roomPlanner.roadPlanner.roadCoverage < ROAD_COVERAGE_THRESHOLD
            ? Setups.transporters.early : Setups.transporters.default;
        const transportPowerEach = setup.getBodyPotential(CARRY, this.colony);
        const neededTransportPower = this.neededTransportPower();
        const currentTransportPower = _.sum(this.transporters, t => t.bodypartCounts[CARRY]);
        this.memory.transporterSaturation = currentTransportPower / neededTransportPower;
        let numTransporters = transportPowerEach ? Math.ceil(neededTransportPower / transportPowerEach) : 0;
        numTransporters = Math.min(numTransporters, MAX_TRANSPORTER);
        if (this.transporters.length == 0) {
            this.wishlist(numTransporters, setup, { priority: OverlordPriority.ownedRoom.firstTransport });
        }
        else {
            this.wishlist(numTransporters, setup);
        }
    }
    handleTransporter(transporter, request) {
        if (request) {
            const choices = this.colony.logisticsNetwork.bufferChoices(transporter, request);
            const bestChoice = _.last(_.sortBy(choices, choice => request.multiplier * choice.dQ
                / Math.max(choice.dt, 0.5)));
            let task = null;
            const amount = this.colony.logisticsNetwork.predictedRequestAmount(transporter, request);
            if (amount > 0) {
                if (isResource(request.target) || isTombstone(request.target) || isRuin(request.target)) {
                    log.warning(`Improper logistics request: should not request input for resource or tombstone or ruin!`);
                    return;
                }
                else if (request.resourceType == 'all') {
                    log.error(`${this.print}: cannot request 'all' as input!`);
                    return;
                }
                else if (isDirective(request.target)) {
                    task = Tasks.drop(request.target, request.resourceType);
                }
                else if (isAnyZerg(request.target)) {
                    task = Tasks.transfer(request.target.creep, request.resourceType);
                }
                else {
                    task = Tasks.transfer(request.target, request.resourceType);
                }
                if (bestChoice.targetRef != request.target.ref) {
                    const buffer = deref(bestChoice.targetRef);
                    const withdrawAmount = Math.min(buffer.store[request.resourceType] || 0, transporter.carryCapacity - _.sum(transporter.carry), amount);
                    task = task.fork(Tasks.withdraw(buffer, request.resourceType, withdrawAmount));
                    if (transporter.hasMineralsInCarry && request.resourceType == RESOURCE_ENERGY) {
                        task = task.fork(Tasks.transferAll(buffer));
                    }
                }
            }
            else if (amount < 0) {
                if (isResource(request.target)) {
                    task = Tasks.pickup(request.target);
                }
                else {
                    if (isDirective(request.target)) {
                        log.error(`Directive ${request.target} cannot be used for output request`);
                    }
                    else if (isAnyZerg(request.target)) {
                        log.error(`Zerg ${request.target} cannot be used for output request (WIP, maybe future)`);
                    }
                    else {
                        if (request.resourceType == 'all') {
                            if (isResource(request.target)) {
                                log.error(this.print + ALL_RESOURCE_TYPE_ERROR);
                                return;
                            }
                            task = Tasks.withdrawAll(request.target);
                        }
                        else {
                            task = Tasks.withdraw(request.target, request.resourceType);
                        }
                    }
                }
                if (task && bestChoice.targetRef != request.target.ref) {
                    const buffer = deref(bestChoice.targetRef);
                    task = task.fork(Tasks.transferAll(buffer));
                }
            }
            else {
                transporter.park();
            }
            transporter.task = task;
            this.colony.logisticsNetwork.invalidateCache(transporter, request);
        }
        else {
            if (_.sum(transporter.carry) > 0) {
                if (transporter.hasMineralsInCarry) {
                    const target = this.colony.terminal || this.colony.storage;
                    if (target) {
                        transporter.task = Tasks.transferAll(target);
                    }
                }
                else {
                    const dropoffPoints = _.compact([this.colony.storage]);
                    const bestDropoffPoint = transporter.pos.findClosestByMultiRoomRange(dropoffPoints);
                    if (bestDropoffPoint)
                        transporter.task = Tasks.transfer(bestDropoffPoint);
                }
            }
            else {
                let parkingSpot = transporter.pos;
                if (this.colony.storage) {
                    parkingSpot = this.colony.storage.pos;
                }
                else if (this.colony.roomPlanner.storagePos) {
                    parkingSpot = this.colony.roomPlanner.storagePos;
                }
                transporter.park(parkingSpot);
            }
        }
    }
    handleBigTransporter(bigTransporter) {
        const bestRequestViaStableMatching = this.colony.logisticsNetwork.matching[bigTransporter.name];
        this.handleTransporter(bigTransporter, bestRequestViaStableMatching);
    }
    handleSmolTransporter(smolTransporter) {
        const bestRequestViaGreedy = _.first(this.colony.logisticsNetwork.transporterPreferences(smolTransporter));
        this.handleTransporter(smolTransporter, bestRequestViaGreedy);
    }
    pickupDroppedResources(transporter) {
        const droppedResource = transporter.pos.lookFor(LOOK_RESOURCES)[0];
        if (droppedResource) {
            transporter.pickup(droppedResource);
            return;
        }
        const tombstone = transporter.pos.lookFor(LOOK_TOMBSTONES)[0];
        if (tombstone) {
            const resourceType = _.last(_.sortBy(_.keys(tombstone.store), resourceType => (tombstone.store[resourceType] || 0)));
            transporter.withdraw(tombstone, resourceType);
        }
    }
    run() {
        this.autoRun(this.transporters, transporter => this.handleSmolTransporter(transporter), transporter => transporter.avoidDanger({ timer: 5, dropEnergy: true }));
    }
};
TransportOverlord = __decorate([
    profile
], TransportOverlord);

const DEFAULT_NUM_SCOUTS$1 = 1;
var zoneController = true;
let RandomWalkerScoutOverlord = class RandomWalkerScoutOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.scouting.randomWalker) {
        super(colony, 'scout', priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        if (!zoneController && this.room && this.hasIndestrucibleWalls(this.room)) {
            return;
        }
        this.wishlist(DEFAULT_NUM_SCOUTS$1, Setups.scout);
    }
    handleScout(scout) {
        var _a;
        if (!zoneController && this.hasIndestrucibleWalls(scout.room)) {
            log.debug(`suiciding scout since newbie room discovered: ${(_a = this.room) === null || _a === void 0 ? void 0 : _a.print}`);
            scout.retire();
            return;
        }
        const neighboringRooms = _.values(Game.map.describeExits(scout.pos.roomName));
        const roomName = _.sample(neighboringRooms);
        if (RoomIntel.isRoomAccessible(roomName)) {
            scout.task = Tasks.goToRoom(roomName);
        }
    }
    hasIndestrucibleWalls(room) {
        const indestructibleWalls = _.filter(room.walls, wall => wall.hits == undefined);
        return indestructibleWalls.length > 0;
    }
    run() {
        this.autoRun(this.scouts, scout => this.handleScout(scout));
    }
};
RandomWalkerScoutOverlord = __decorate([
    profile
], RandomWalkerScoutOverlord);

var ColonyStage;
(function (ColonyStage) {
    ColonyStage[ColonyStage["Larva"] = 0] = "Larva";
    ColonyStage[ColonyStage["Pupa"] = 1] = "Pupa";
    ColonyStage[ColonyStage["Adult"] = 2] = "Adult";
})(ColonyStage || (ColonyStage = {}));
var DEFCON;
(function (DEFCON) {
    DEFCON[DEFCON["safe"] = 0] = "safe";
    DEFCON[DEFCON["invasionNPC"] = 1] = "invasionNPC";
    DEFCON[DEFCON["boostedInvasionNPC"] = 2] = "boostedInvasionNPC";
    DEFCON[DEFCON["playerInvasion"] = 2] = "playerInvasion";
    DEFCON[DEFCON["bigPlayerInvasion"] = 3] = "bigPlayerInvasion";
})(DEFCON || (DEFCON = {}));
function getAllColonies() {
    return _.values(Overmind.colonies);
}
var OutpostDisableReason;
(function (OutpostDisableReason) {
    OutpostDisableReason["active"] = "active";
    OutpostDisableReason["inactiveCPU"] = "i_cpu";
    OutpostDisableReason["inactiveUpkeep"] = "i_upkeep";
    OutpostDisableReason["inactiveHarassment"] = "i_harassment";
    OutpostDisableReason["inactiveStronghold"] = "i_stronghold";
})(OutpostDisableReason || (OutpostDisableReason = {}));
const getDefaultColonyMemory = () => ({
    defcon: {
        level: DEFCON.safe,
        tick: -Infinity
    },
    expansionData: {
        possibleExpansions: {},
        expiration: 0,
    },
    maxLevel: 0,
    outposts: {},
});
let Colony = class Colony {
    constructor(id, roomName, outposts) {
        this.id = id;
        this.name = roomName;
        this.ref = roomName;
        this.memory = Mem.wrap(Memory.colonies, roomName, getDefaultColonyMemory);
        _.forEach(outposts, outpost => {
            if (!this.memory.outposts[outpost]) {
                this.memory.outposts[outpost] = { active: true };
            }
        });
        _.forEach(_.keys(_.clone(this.memory.outposts)), roomName => {
            if (!outposts.includes(roomName)) {
                delete this.memory.outposts[roomName];
            }
        });
        global[this.name] = this;
        global[this.name.toLowerCase()] = this;
        this.build(roomName, outposts);
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.room.name + '">[' + this.name + ']</a>';
    }
    get printAligned() {
        const msg = '<a href="#!/room/' + Game.shard.name + '/' + this.room.name + '">[' + this.name + ']</a>';
        const extraSpaces = 'E12S34'.length - this.room.name.length;
        return msg + ' '.repeat(extraSpaces);
    }
    toString() {
        return this.print;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    build(roomName, outposts) {
        this.room = Game.rooms[roomName];
        this.roomNames = [roomName].concat(outposts);
        this.outposts = _.compact(_.map(outposts, outpost => Game.rooms[outpost]));
        this.rooms = [this.room].concat(this.outposts);
        this.miningSites = {};
        this.extractionSites = {};
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(this.creeps, creep => creep.memory.role);
        this.registerRoomObjects();
        this.registerOperationalState();
        this.registerUtilities();
        this.registerHiveClusters();
    }
    refresh() {
        this.memory = Memory.colonies[this.room.name];
        this.room = Game.rooms[this.room.name];
        const outpostRoomNames = _.filter(this.roomNames, roomName => this.room.name != roomName);
        this.outposts = _.compact(_.map(outpostRoomNames, outpost => Game.rooms[outpost]));
        this.rooms = [this.room].concat(this.outposts);
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(this.creeps, creep => creep.memory.role);
        this.refreshRoomObjects();
        this.registerOperationalState();
        this.refreshUtilities();
        _.forEachRight(this.hiveClusters, h => h.refresh());
    }
    registerRoomObjects() {
        this.flags = [];
        this.destinations = [];
        this.controller = this.room.controller;
        this.extensions = this.room.extensions;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.towers = this.room.towers;
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        $.set(this, 'spawns', () => _.sortBy(_.filter(this.room.spawns, spawn => spawn.my && spawn.isActive()), spawn => spawn.ref));
        $.set(this, 'storage', () => this.room.storage && this.room.storage.isActive() ? this.room.storage : undefined);
        $.set(this, 'terminal', () => this.room.terminal && this.room.terminal.isActive() ? this.room.terminal : undefined);
        $.set(this, 'factory', () => this.room.factory && this.room.factory.isActive() ? this.room.factory : undefined);
        $.set(this, 'labs', () => _.sortBy(_.filter(this.room.labs, lab => lab.my && lab.isActive()), lab => 50 * lab.pos.y + lab.pos.x));
        this.pos = (this.storage || this.terminal || this.spawns[0] || this.controller).pos;
        $.set(this, 'sources', () => _.sortBy(_.flatten(_.map(this.rooms, room => room.sources)), source => source.pos.getMultiRoomRangeTo(this.pos)));
        $.set(this, 'extractors', () => _(this.rooms)
            .map(room => room.extractor)
            .compact()
            .filter(e => (e.my && e.room.my)
            || Cartographer.roomType(e.room.name) != ROOMTYPE_CONTROLLER)
            .sortBy(e => e.pos.getMultiRoomRangeTo(this.pos)).value());
        $.set(this, 'repairables', () => _.flatten(_.map(this.rooms, room => room.repairables)));
        $.set(this, 'rechargeables', () => _.flatten(_.map(this.rooms, room => room.rechargeables)));
        this.constructionSites = _.flatten(_.map(this.rooms, room => room.constructionSites));
        this.tombstones = _.flatten(_.map(this.rooms, room => room.tombstones));
        this.drops = _.merge(_.map(this.rooms, room => room.drops));
        this.ruins = _.flatten(_.map(this.rooms, room => room.ruins));
        this.assets = this.computeAssets();
    }
    refreshRoomObjects() {
        $.refresh(this, 'controller', 'extensions', 'links', 'towers', 'powerSpawn', 'nuker', 'observer', 'spawns', 'storage', 'terminal', 'factory', 'labs', 'sources', 'extractors', 'repairables', 'rechargeables');
        this.constructionSites = _.flatten(_.map(this.rooms, room => room.constructionSites));
        this.tombstones = _.flatten(_.map(this.rooms, room => room.tombstones));
        this.drops = _.merge(_.map(this.rooms, room => room.drops));
        this.ruins = _.flatten(_.map(this.rooms, room => room.ruins));
        this.assets = this.computeAssets();
    }
    registerOperationalState() {
        this.level = this.controller.level;
        if (this.storage && this.spawns[0]) {
            if (this.controller.level == 8) {
                this.stage = ColonyStage.Adult;
            }
            else {
                this.stage = ColonyStage.Pupa;
            }
        }
        else {
            this.stage = ColonyStage.Larva;
        }
        let defcon = DEFCON.safe;
        const defconDecayTime = 200;
        if (this.room.dangerousHostiles.length > 0 && !this.controller.safeMode) {
            const effectiveHostileCount = _.sum(this.room.dangerousHostiles, hostile => CombatIntel.uniqueBoosts(hostile).length > 0 ? 2 : 1);
            if (effectiveHostileCount >= 3) {
                defcon = DEFCON.boostedInvasionNPC;
            }
            else {
                defcon = DEFCON.invasionNPC;
            }
        }
        if (this.memory.defcon) {
            if (defcon < this.memory.defcon.level) {
                if (this.memory.defcon.tick + defconDecayTime < Game.time) {
                    this.memory.defcon.level = defcon;
                    this.memory.defcon.tick = Game.time;
                }
            }
            else if (defcon > this.memory.defcon.level) {
                this.memory.defcon.level = defcon;
                this.memory.defcon.tick = Game.time;
            }
        }
        else {
            this.memory.defcon = {
                level: defcon,
                tick: Game.time
            };
        }
        this.defcon = this.memory.defcon.level;
        this.state = {};
        if (Energetics.lowPowerMode(this)) {
            this.state.lowPowerMode = true;
        }
    }
    registerUtilities() {
        this.linkNetwork = new LinkNetwork(this);
        this.logisticsNetwork = new LogisticsNetwork(this);
        this.transportRequests = new TransportRequestGroup();
        this.roomPlanner = new RoomPlanner(this);
        if (this.roomPlanner.memory.bunkerData && this.roomPlanner.memory.bunkerData.anchor) {
            this.layout = 'bunker';
            const anchor = derefRoomPosition(this.roomPlanner.memory.bunkerData.anchor);
            const spawnPositions = _.map(bunkerLayout[8].buildings.spawn.pos, c => getPosFromBunkerCoord(c, this));
            const rightSpawnPos = maxBy(spawnPositions, pos => pos.x);
            const topSpawnPos = minBy(spawnPositions, pos => pos.y);
            const coreSpawnPos = anchor.findClosestByRange(spawnPositions);
            this.bunker = {
                anchor: anchor,
                topSpawn: topSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                coreSpawn: coreSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                rightSpawn: rightSpawnPos.lookForStructure(STRUCTURE_SPAWN),
            };
        }
        else {
            this.layout = 'twoPart';
        }
        this.roadLogistics = new RoadLogistics(this);
        if (this.terminal) {
            Overmind.terminalNetwork.addColony(this);
        }
    }
    refreshUtilities() {
        this.linkNetwork.refresh();
        this.logisticsNetwork.refresh();
        this.transportRequests.refresh();
        this.roomPlanner.refresh();
        if (this.bunker) {
            if (this.bunker.topSpawn) {
                this.bunker.topSpawn = Game.getObjectById(this.bunker.topSpawn.id);
            }
            if (this.bunker.coreSpawn) {
                this.bunker.coreSpawn = Game.getObjectById(this.bunker.coreSpawn.id);
            }
            if (this.bunker.rightSpawn) {
                this.bunker.rightSpawn = Game.getObjectById(this.bunker.rightSpawn.id);
            }
        }
        this.roadLogistics.refresh();
    }
    registerHiveClusters() {
        this.hiveClusters = [];
        if (this.storage) {
            this.commandCenter = new CommandCenter(this, this.storage);
        }
        if (this.spawns[0]) {
            this.hatchery = new Hatchery(this, this.spawns[0]);
        }
        if (this.terminal && _.filter(this.labs, lab => _.all(this.labs, otherLab => lab.pos.inRangeTo(otherLab, 2))).length >= 3) {
            this.evolutionChamber = new EvolutionChamber(this, this.terminal);
        }
        this.upgradeSite = new UpgradeSite(this, this.controller);
        if (this.towers[0]) {
            this.sporeCrawler = new SporeCrawler(this, this.towers[0]);
        }
        this.hiveClusters.reverse();
    }
    isRoomActive(roomName) {
        if (roomName == this.room.name) {
            return true;
        }
        else if (!this.roomNames.includes(roomName)) {
            return false;
        }
        else {
            return this.memory.outposts[roomName] && this.memory.outposts[roomName].active;
        }
    }
    suspendOutpost(roomName, reason, duration) {
        this.memory.outposts[roomName] = {
            active: false,
            suspendReason: reason,
            ["X"]: Game.time + duration
        };
    }
    handleReactivatingOutposts() {
        for (const roomName in this.memory.outposts) {
            const outpostData = this.memory.outposts[roomName];
            if (!outpostData.active && Game.time >= (outpostData["X"] || Infinity)) {
                this.memory.outposts[roomName] = { active: true };
            }
        }
    }
    spawnMoarOverlords() {
        this.overlords = {
            default: new DefaultOverlord(this),
            work: new WorkerOverlord(this),
            logistics: new TransportOverlord(this),
        };
        if (!this.observer) {
            this.overlords.scout = new RandomWalkerScoutOverlord(this);
        }
        for (const hiveCluster of this.hiveClusters) {
            hiveCluster.spawnMoarOverlords();
        }
    }
    getCreepsByRole(roleName) {
        return this.creepsByRole[roleName] || [];
    }
    getZergByRole(roleName) {
        return _.compact(_.map(this.getCreepsByRole(roleName), creep => Overmind.zerg[creep.name]));
    }
    computeAssets(verbose = false) {
        const assetStructures = _.compact([this.storage, this.terminal, this.factory, ...this.labs]);
        const assetCreeps = [...this.getCreepsByRole(Roles.queen), ...this.getCreepsByRole(Roles.manager)];
        const assetStores = _.map([...assetStructures, ...assetCreeps], thing => thing.store);
        const allAssets = mergeSum([...assetStores, ALL_ZERO_ASSETS]);
        if (verbose)
            log.debug(`${this.room.print} assets: ` + JSON.stringify(allAssets));
        return allAssets;
    }
    init() {
        _.forEach(this.hiveClusters, hiveCluster => hiveCluster.init());
        this.roadLogistics.init();
        this.linkNetwork.init();
        this.roomPlanner.init();
        if (Game.time % EXPANSION_EVALUATION_FREQ == 5 * this.id) {
            log.debug(`refreshExpansionData: ${this.room.name}`);
            ExpansionEvaluator.refreshExpansionData(this.memory.expansionData, this.room.name);
        }
    }
    run() {
        _.forEach(this.hiveClusters, hiveCluster => hiveCluster.run());
        this.linkNetwork.run();
        this.roadLogistics.run();
        this.roomPlanner.run();
        this.stats();
    }
    stats() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            Stats.log(`colonies.${this.name}.storage.energy`, this.storage ? this.storage.energy : undefined);
            Stats.log(`colonies.${this.name}.rcl.level`, this.controller.level);
            Stats.log(`colonies.${this.name}.rcl.progress`, this.controller.progress);
            Stats.log(`colonies.${this.name}.rcl.progressTotal`, this.controller.progressTotal);
            const numSites = _.keys(this.miningSites).length;
            const avgDowntime = _.sum(this.miningSites, site => site.memory["d"]) / numSites;
            const avgUsage = _.sum(this.miningSites, site => site.memory["u"]) / numSites;
            const energyInPerTick = _.sum(this.miningSites, site => site.overlords.mine.energyPerTick * site.memory["u"]);
            Stats.log(`colonies.${this.name}.miningSites.avgDowntime`, avgDowntime);
            Stats.log(`colonies.${this.name}.miningSites.avgUsage`, avgUsage);
            Stats.log(`colonies.${this.name}.miningSites.energyInPerTick`, energyInPerTick);
            Stats.log(`colonies.${this.name}.assets`, this.assets);
            Stats.log(`colonies.${this.name}.defcon`, this.defcon);
            Stats.log(`colonies.${this.name}.threatLevel`, this.room.threatLevel);
            const avgBarrierHits = _.sum(this.room.barriers, barrier => barrier.hits) / this.room.barriers.length;
            Stats.log(`colonies.${this.name}.avgBarrierHits`, avgBarrierHits);
            const report = Overmind.overseer.getCreepReport(this);
            for (const [role, [current, needed]] of Object.entries(report)) {
                Stats.log(`colonies.${this.name}.creeps.${role}.current`, current);
                Stats.log(`colonies.${this.name}.creeps.${role}.needed`, needed);
            }
        }
    }
    drawCreepReport(coord) {
        const report = Overmind.overseer.getCreepReport(this);
        const roledata = [];
        for (const role in report) {
            const [current, needed] = report[role];
            roledata.push([role, `${current}/${needed}`]);
        }
        let { x, y } = coord;
        const tablePos = new RoomPosition(x, y, this.room.name);
        y = Visualizer.infoBox(`${this.name} Creeps`, roledata, tablePos, 7);
        return { x, y };
    }
    visuals() {
        let x = 1;
        let y = 11.5;
        let coord;
        coord = this.drawCreepReport({ x, y });
        x = coord.x;
        y = coord.y;
        for (const hiveCluster of _.compact([this.hatchery, this.commandCenter, this.evolutionChamber])) {
            coord = hiveCluster.visuals({ x, y });
            x = coord.x;
            y = coord.y;
        }
    }
};
Colony.settings = {
    remoteSourcesByLevel: {
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 9,
    },
    maxSourceDistance: 100
};
Colony = __decorate([
    profile
], Colony);

const rechargeTaskName = 'recharge';
let TaskRecharge = class TaskRecharge extends Task {
    constructor(minEnergy = 0, options = {}) {
        super(rechargeTaskName, { ref: '', pos: { x: -1, y: -1, roomName: '' } }, options);
        this.data.minEnergy = minEnergy;
    }
    rechargeRateForCreep(creep, obj) {
        if (creep.colony && creep.colony.hatchery && creep.colony.hatchery.batteries.length > 0
            && creep.roleName != 'queen') {
            if (creep.colony.stage == ColonyStage.Larva) {
                const MINIMUM_BATTERY_THRESHOLD = 1500;
                if (_.any(creep.colony.hatchery.batteries, battery => battery.id == obj.id && battery.energy < MINIMUM_BATTERY_THRESHOLD)) {
                    return false;
                }
            }
            else {
                if (_.any(creep.colony.hatchery.batteries, battery => battery.id == obj.id)) {
                    return false;
                }
            }
        }
        if (creep.colony && creep.colony.stage == ColonyStage.Larva && creep.roleName == 'worker') {
            const miningSiteContainers = _.compact(_.map(creep.colony.miningSites, site => site.overlords.mine.container));
            const CONTAINER_THRESHOLD = 1000;
            if (_.any(miningSiteContainers, (c) => c.id == obj.id && c.energy < CONTAINER_THRESHOLD)) {
                return false;
            }
        }
        let amount = isResource(obj) ? obj.amount : obj.store[RESOURCE_ENERGY];
        if (amount < this.data.minEnergy) {
            return false;
        }
        const otherTargeters = _.filter(_.map(obj.targetedBy, name => Overmind.zerg[name]), zerg => !!zerg && zerg.task
            && (zerg.task.name == withdrawTaskName || zerg.task.name == pickupTaskName));
        const resourceOutflux = _.sum(_.map(otherTargeters, other => other.store.getFreeCapacity()));
        amount = minMax(amount - resourceOutflux, 0, creep.carryCapacity);
        const effectiveAmount = amount / (creep.pos.getMultiRoomRangeTo(obj.pos) + 1);
        if (effectiveAmount <= 0) {
            return false;
        }
        else {
            return effectiveAmount;
        }
    }
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
        const possibleTargets = creep.colony && creep.inColonyRoom ? creep.colony.rechargeables
            : creep.room.rechargeables;
        const target = maxBy(possibleTargets, o => this.rechargeRateForCreep(creep, o));
        if (!target || creep.pos.getMultiRoomRangeTo(target.pos) > 40) {
            const canHarvest = creep.getActiveBodyparts(WORK) > 0 && creep.roleName != 'worker';
            if (canHarvest) {
                const availableSources = _.filter(creep.room.sources, function (source) {
                    const filledSource = source.energy > 0 || source.ticksToRegeneration < 20;
                    const isSurrounded = source.pos.availableNeighbors(false).length == 0;
                    return filledSource && (!isSurrounded || creep.pos.isNearTo(source));
                });
                const availableSource = creep.pos.findClosestByMultiRoomRange(availableSources);
                if (availableSource) {
                    creep.task = new TaskHarvest(availableSource);
                    return;
                }
            }
        }
        if (target) {
            if (isResource(target)) {
                creep.task = new TaskPickup(target);
                return;
            }
            else {
                creep.task = new TaskWithdraw(target);
                return;
            }
        }
        else {
            creep.task = null;
        }
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    work() {
        log.warning(`BAD RESULT: Should not get here...`);
        return ERR_INVALID_TARGET;
    }
};
TaskRecharge = __decorate([
    profile
], TaskRecharge);

function initializeTask(protoTask) {
    const taskName = protoTask.name;
    const target = deref(protoTask._target.ref);
    let task;
    switch (taskName) {
        case attackTaskName:
            task = new TaskAttack(target);
            break;
        case buildTaskName:
            task = new TaskBuild(target);
            break;
        case claimTaskName:
            task = new TaskClaim(target);
            break;
        case dismantleTaskName:
            task = new TaskDismantle(target);
            break;
        case dropTaskName:
            task = new TaskDrop({ ref: '', pos: derefRoomPosition(protoTask._target._pos) });
            break;
        case fortifyTaskName:
            task = new TaskFortify(target);
            break;
        case getBoostedTaskName:
            task = new TaskGetBoosted(target, protoTask.data.resourceType);
            break;
        case getRenewedTaskName:
            task = new TaskGetRenewed(target);
            break;
        case goToTaskName:
            task = new TaskInvalid();
            break;
        case goToRoomTaskName:
            task = new TaskGoToRoom({ ref: '', pos: derefRoomPosition(protoTask._target._pos) });
            break;
        case harvestTaskName:
            task = new TaskHarvest(target);
            break;
        case healTaskName:
            task = new TaskHeal(target);
            break;
        case meleeAttackTaskName:
            task = new TaskMeleeAttack(target);
            break;
        case pickupTaskName:
            task = new TaskPickup(target);
            break;
        case rangedAttackTaskName:
            task = new TaskRangedAttack(target);
            break;
        case rechargeTaskName:
            task = new TaskRecharge();
            break;
        case repairTaskName:
            task = new TaskRepair(target);
            break;
        case reserveTaskName:
            task = new TaskReserve(target);
            break;
        case signControllerTaskName:
            task = new TaskSignController(target);
            break;
        case transferTaskName:
            task = new TaskTransfer(target);
            break;
        case transferAllTaskName:
            task = new TaskTransferAll(target);
            break;
        case upgradeTaskName:
            task = new TaskUpgrade(target);
            break;
        case withdrawTaskName:
            task = new TaskWithdraw(target);
            break;
        case withdrawAllTaskName:
            task = new TaskWithdrawAll(target);
            break;
        case generateSafeModeTaskName:
            task = new TaskGenerateSafeMode(target);
            break;
        default:
            log.error(`Invalid task name: ${taskName}! task.creep: ${protoTask._creep.name}. Deleting from memory!`);
            task = new TaskInvalid();
            break;
    }
    task.proto = protoTask;
    return task;
}
screepsProfiler.registerFN(initializeTask, 'initializeTask');

const getDefaultSpawnGroupMemory = () => ({
    colonies: [],
    distances: {},
    expiration: 0,
});
const MAX_LINEAR_DISTANCE = 10;
const DEFAULT_RECACHE_TIME = onPublicServer() ? 2000 : 1000;
const defaultSettings = {
    maxPathDistance: 4 * 50,
    requiredRCL: 7,
    maxLevelDifference: 0,
};
let SpawnGroup = class SpawnGroup {
    constructor(initializer, settings = {}) {
        this.roomName = initializer.pos.roomName;
        if (!Memory.rooms[this.roomName]) {
            Memory.rooms[this.roomName] = {};
        }
        this.memory = Mem.wrap(Memory.rooms[this.roomName], 'spawnGroup', getDefaultSpawnGroupMemory);
        this.ref = initializer.ref + ':SG';
        this.stats = {
            avgDistance: (_.sum(this.memory.distances) / _.keys(this.memory.distances).length) || 100,
        };
        this.requests = [];
        this.settings = _.defaults(settings, defaultSettings);
        if (Game.time >= this.memory.expiration) {
            this.recalculateColonies();
        }
        this.colonyNames = _.filter(this.memory.colonies, roomName => this.memory.distances[roomName] <= this.settings.maxPathDistance &&
            Game.rooms[roomName] && Game.rooms[roomName].my &&
            Game.rooms[roomName].controller.level >= this.settings.requiredRCL);
        if (this.colonyNames.length == 0) {
            log.warning(`No colonies meet the requirements for SpawnGroup: ${this.ref}`);
        }
        this.energyCapacityAvailable = _.max(_.map(this.colonyNames, roomName => Game.rooms[roomName].energyCapacityAvailable));
        this._colonies = undefined;
        Overmind.spawnGroups[this.ref] = this;
    }
    get colonies() {
        if (!this._colonies) {
            this._colonies = _.compact(_.map(this.colonyNames, roomName => Overmind.colonies[roomName]));
        }
        return this._colonies;
    }
    refresh() {
        this.memory = Mem.wrap(Memory.rooms[this.roomName], 'spawnGroup', getDefaultSpawnGroupMemory);
        this.requests = [];
        this._colonies = undefined;
    }
    recalculateColonies() {
        let coloniesInRange = _.filter(getAllColonies(), colony => Game.map.getRoomLinearDistance(colony.room.name, this.roomName) <= MAX_LINEAR_DISTANCE);
        const maxColonyLevel = _.max(_.map(coloniesInRange, colony => colony.level));
        coloniesInRange = _.filter(coloniesInRange, colony => maxColonyLevel - colony.level <= this.settings.maxLevelDifference);
        const colonyNames = [];
        const distances = {};
        for (const colony of coloniesInRange) {
            const spawn = colony.room.spawns[0];
            if (!spawn)
                continue;
            const path = Pathing.findPathToRoom(spawn.pos, this.roomName, { useFindRoute: true });
            if (!path.incomplete && path.path.length <= DEFAULT_MAX_PATH_LENGTH + 25) {
                colonyNames.push(colony.room.name);
                distances[colony.room.name] = path.path.length;
            }
        }
        this.memory.colonies = colonyNames;
        this.memory.distances = distances;
        this.memory.expiration = getCacheExpiration(DEFAULT_RECACHE_TIME, 25);
    }
    enqueue(request) {
        this.requests.push(request);
    }
    init() {
        const colonies = _.compact(_.map(this.colonyNames, name => Overmind.colonies[name]));
        const hatcheries = _.compact(_.map(colonies, colony => colony.hatchery));
        const distanceTo = (hatchery) => this.memory.distances[hatchery.pos.roomName] + 25;
        for (const request of this.requests) {
            const bestHatchery = minBy(hatcheries, hatchery => hatchery.getWaitTimeForPriority(request.priority) +
                distanceTo(hatchery));
            if (bestHatchery) {
                bestHatchery.enqueue(request);
            }
            else {
                log.error(`Could not enqueue creep with role ${request.setup.role} in ${this.roomName} ` +
                    `for Overlord ${request.overlord.print}!`);
            }
        }
    }
    run() {
    }
};
SpawnGroup = __decorate([
    profile
], SpawnGroup);

const getDefaultCombatOverlordMemory = () => ({
    ["T"]: Game.time,
});
let CombatOverlord = class CombatOverlord extends Overlord {
    constructor(directive, name, priority, requiredRCL, maxPathDistance) {
        super(directive, name, priority, getDefaultCombatOverlordMemory);
        this.directive = directive;
        this.requiredRCL = requiredRCL;
        this.spawnGroup = new SpawnGroup(this, { requiredRCL: this.requiredRCL, maxPathDistance: maxPathDistance });
    }
    get age() {
        return Game.time - this.memory["T"];
    }
    finish(successful) {
        for (const zerg of this.getAllZerg()) {
            zerg.reassign(this.colony.overlords.default);
        }
    }
};
CombatOverlord = __decorate([
    profile
], CombatOverlord);

var SourceReaperOverlord_1;
let SourceReaperOverlord = SourceReaperOverlord_1 = class SourceReaperOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.remoteSKRoom.sourceReaper) {
        super(directive, 'sourceReaper', priority, SourceReaperOverlord_1.requiredRCL);
        this.priority += this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.reapers = this.combatZerg(Roles.melee);
        this.defenders = this.combatZerg(Roles.ranged);
        this.memory = Mem.wrap(this.directive.memory, 'sourceReaper');
        this.computeTargetLair();
    }
    computeTargetLair() {
        this.targetLair = this.memory.targetLairID ? deref(this.memory.targetLairID) : undefined;
        if (!this.targetLair || (this.targetLair.ticksToSpawn || Infinity) >= 299) {
            if (this.room) {
                const activeLair = _.find(this.room.keeperLairs, lair => lair.pos.findInRange(lair.room.sourceKeepers, 5).length > 0);
                if (activeLair) {
                    this.targetLair = activeLair;
                }
                else {
                    this.targetLair = minBy(this.room.keeperLairs, lair => lair.ticksToSpawn || Infinity);
                }
            }
        }
    }
    refresh() {
        super.refresh();
        this.computeTargetLair();
    }
    init() {
        const defenderAmount = this.room && (this.room.invaders.length > 0
            || RoomIntel.isInvasionLikely(this.room)) ? 1 : 0;
        this.wishlist(1, CombatSetups.zerglings.sourceKeeper);
        this.wishlist(defenderAmount, CombatSetups.hydralisks.sourceKeeper);
    }
    handleReaper(reaper) {
        const moveOpts = { pathOpts: { avoidSK: false } };
        if (!this.targetLair || !this.room || reaper.room != this.room || reaper.pos.isEdge) {
            reaper.healSelfIfPossible();
            reaper.goTo(this.pos, moveOpts);
            return;
        }
        moveOpts.pathOpts.blockExits = true;
        const nonStrongholdInvaders = this.room.invaders.filter(creep => !creep.inRampart);
        if (nonStrongholdInvaders.length > 0) {
            if (reaper.hits >= reaper.hitsMax * .5) {
                const result = reaper.autoMelee(this.room.invaders);
                if (result == undefined) {
                    reaper.autoHeal();
                }
            }
            else {
                reaper.healSelfIfPossible();
            }
            if (this.room.invaders.length > 2 && _.filter(this.defenders, def => def.room == this.room).length == 0) {
                reaper.kite(_.filter(this.room.hostiles, h => h.getActiveBodyparts(RANGED_ATTACK) > 0), moveOpts);
                reaper.healSelfIfPossible();
            }
            else {
                const target = CombatTargeting.findTarget(reaper, this.room.invaders);
                if (target) {
                    Movement.invasionMove(reaper, target);
                }
                else {
                    log.warning(`KeeperReaper@${reaper.pos.print}: no invader target!`);
                }
            }
        }
        else {
            const nearestHostile = reaper.pos.findClosestByRange(this.room.hostiles);
            if (nearestHostile && reaper.pos.isNearTo(nearestHostile)) {
                reaper.attack(nearestHostile);
                reaper.move(reaper.pos.getDirectionTo(nearestHostile));
            }
            else {
                const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);
                if (keeper) {
                    const approachRange = (reaper.hits == reaper.hitsMax || reaper.pos.getRangeTo(keeper) <= 3) ? 1 : 4;
                    reaper.goTo(keeper, { range: approachRange, pathOpts: moveOpts.pathOpts });
                }
                else {
                    reaper.goTo(this.targetLair, { range: 1, pathOpts: moveOpts.pathOpts });
                }
            }
            reaper.healSelfIfPossible();
        }
    }
    handleDefender(defender) {
        if (!this.targetLair || !this.room || defender.room != this.room || defender.pos.isEdge) {
            debug(defender, `Going to room!`);
            defender.healSelfIfPossible();
            defender.goToRoom(this.pos.roomName, { pathOpts: { avoidSK: false } });
            return;
        }
        if (this.room.invaders.length > 0) {
            debug(defender, `AutoCombat`);
            defender.autoSkirmish(this.room.name);
        }
        else {
            debug(defender, `Standard duty`);
            const minKeepersToHelp = this.reapers.length == 0 ? 1 : 2;
            if (this.room.sourceKeepers.length >= minKeepersToHelp) {
                defender.autoRanged();
                defender.autoHeal(false);
                const reaper = defender.pos.findClosestByRange(this.reapers);
                if (reaper) {
                    defender.goTo(reaper, {
                        movingTarget: defender.pos.getRangeTo(reaper) > 8,
                        repathChance: 0.1,
                        pathOpts: {
                            maxRooms: 1,
                            avoidSK: false,
                            blockExits: true,
                        }
                    });
                }
                else {
                    const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);
                    if (keeper) {
                        const range = defender.pos.getRangeTo(keeper);
                        const keepAtRange = defender.hits < defender.hitsMax * .9 ? 4 : 3;
                        if (range < keepAtRange) {
                            defender.kite(this.room.hostiles, {
                                range: keepAtRange, pathOpts: {
                                    avoidSK: false,
                                    blockExits: true,
                                }
                            });
                        }
                        else if (range > keepAtRange) {
                            defender.goTo(keeper, {
                                range: keepAtRange, pathOpts: {
                                    avoidSK: false,
                                    blockExits: true
                                }
                            });
                        }
                    }
                    else {
                        defender.goTo(this.targetLair, {
                            range: 5, pathOpts: {
                                avoidSK: false,
                                blockExits: true
                            }
                        });
                    }
                }
            }
            else {
                debug(defender, `Medic actions`);
                defender.doMedicActions(this.room.name);
            }
        }
    }
    run() {
        this.autoRun(this.reapers, reaper => this.handleReaper(reaper));
        this.autoRun(this.defenders, defender => this.handleDefender(defender));
    }
    visuals() {
        if (this.room && this.targetLair) {
            Visualizer.marker(this.targetLair.pos);
        }
    }
};
SourceReaperOverlord.requiredRCL = 7;
SourceReaperOverlord = SourceReaperOverlord_1 = __decorate([
    profile
], SourceReaperOverlord);

let DirectiveSKOutpost = class DirectiveSKOutpost extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= SourceReaperOverlord.requiredRCL);
        this.refresh();
    }
    refresh() {
        super.refresh();
    }
    spawnMoarOverlords() {
        this.overlords.sourceReaper = new SourceReaperOverlord(this);
    }
    init() {
    }
    run() {
    }
};
DirectiveSKOutpost.directiveName = 'outpostSK';
DirectiveSKOutpost.color = COLOR_PURPLE;
DirectiveSKOutpost.secondaryColor = COLOR_YELLOW;
DirectiveSKOutpost = __decorate([
    profile
], DirectiveSKOutpost);

let EmpireAnalysis = class EmpireAnalysis {
    static empireMineralDistribution() {
        const colonies = getAllColonies();
        const minedSKRooms = DirectiveSKOutpost.find(Object.values(Game.flags));
        const mineralDistribution = {};
        for (const colony of colonies) {
            const mineral = colony.room.find(FIND_MINERALS)[0];
            if (!mineralDistribution[mineral.mineralType]) {
                mineralDistribution[mineral.mineralType] = 0;
            }
            mineralDistribution[mineral.mineralType] += 1;
        }
        for (const skRoomFlag of minedSKRooms) {
            if (!skRoomFlag.room) {
                continue;
            }
            const mineral = skRoomFlag.room.find(FIND_MINERALS)[0];
            if (!mineralDistribution[mineral.mineralType]) {
                mineralDistribution[mineral.mineralType] = 0;
            }
            mineralDistribution[mineral.mineralType] += 1;
        }
        return mineralDistribution;
    }
};
EmpireAnalysis = __decorate([
    profile
], EmpireAnalysis);

class OvermindConsole {
    static init() {
        global.help = this.help();
        global.info = this.info;
        global.notifications = this.notifications;
        global.debug = this.debug;
        global.stopDebug = this.stopDebug;
        global.setMode = this.setMode;
        global.setSignature = this.setSignature;
        global.print = this.print;
        global.timeit = this.timeit;
        global.profileOverlord = this.profileOverlord;
        global.finishProfilingOverlord = this.finishProfilingOverlord;
        global.setLogLevel = log.setLogLevel;
        global.suspendColony = this.suspendColony;
        global.unsuspendColony = this.unsuspendColony;
        global.listSuspendedColonies = this.listSuspendedColonies;
        global.openRoomPlanner = this.openRoomPlanner;
        global.closeRoomPlanner = this.closeRoomPlanner;
        global.cancelRoomPlanner = this.cancelRoomPlanner;
        global.listActiveRoomPlanners = this.listActiveRoomPlanners;
        global.destroyErrantStructures = this.destroyErrantStructures;
        global.destroyAllHostileStructures = this.destroyAllHostileStructures;
        global.destroyAllBarriers = this.destroyAllBarriers;
        global.listConstructionSites = this.listConstructionSites;
        global.removeUnbuiltConstructionSites = this.removeUnbuiltConstructionSites;
        global.listDirectives = this.listDirectives;
        global.listPersistentDirectives = this.listPersistentDirectives;
        global.removeAllLogisticsDirectives = this.removeAllLogisticsDirectives;
        global.removeFlagsByColor = this.removeFlagsByColor;
        global.removeErrantFlags = this.removeErrantFlags;
        global.deepCleanMemory = this.deepCleanMemory;
        global.profileMemory = this.profileMemory;
        global.cancelMarketOrders = this.cancelMarketOrders;
        global.setRoomUpgradeRate = this.setRoomUpgradeRate;
        global.getEmpireMineralDistribution = this.getEmpireMineralDistribution;
        global.listPortals = this.listPortals;
        global.evaluateOutpostEfficiencies = this.evaluateOutpostEfficiencies;
        global.evaluatePotentialOutpostEfficiencies = this.evaluatePotentialOutpostEfficiencies;
    }
    static help() {
        let msg = '\n<font color="#ff00ff">';
        for (const line of asciiLogoSmall) {
            msg += line + '\n';
        }
        msg += '</font>';
        const descr = {};
        descr.help = 'show this message';
        descr['info()'] = 'display version and operation information';
        descr['notifications()'] = 'print a list of notifications with hyperlinks to the console';
        descr['setMode(mode)'] = 'set the operational mode to "manual", "semiautomatic", or "automatic"';
        descr['setSignature(newSignature)'] = 'set your controller signature; no argument sets to default';
        descr['print(...args[])'] = 'log stringified objects to the console';
        descr['debug(thing)'] = 'enable debug logging for a game object or process';
        descr['stopDebug(thing)'] = 'disable debug logging for a game object or process';
        descr['timeit(function, repeat=1)'] = 'time the execution of a snippet of code';
        descr['profileOverlord(overlord, ticks?)'] = 'start profiling on an overlord instance or name';
        descr['finishProfilingOverlord(overlord)'] = 'stop profiling on an overlord';
        descr['setLogLevel(int)'] = 'set the logging level from 0 - 4';
        descr['suspendColony(roomName)'] = 'suspend operations within a colony';
        descr['unsuspendColony(roomName)'] = 'resume operations within a suspended colony';
        descr['listSuspendedColonies()'] = 'Prints all suspended colonies';
        descr['openRoomPlanner(roomName)'] = 'open the room planner for a room';
        descr['closeRoomPlanner(roomName)'] = 'close the room planner and save changes';
        descr['cancelRoomPlanner(roomName)'] = 'close the room planner and discard changes';
        descr['listActiveRoomPlanners()'] = 'display a list of colonies with open room planners';
        descr['destroyErrantStructures(roomName)'] = 'destroys all misplaced structures within an owned room';
        descr['destroyAllHostileStructures(roomName)'] = 'destroys all hostile structures in an owned room';
        descr['destroyAllBarriers(roomName)'] = 'destroys all ramparts and barriers in a room';
        descr['listConstructionSites(filter?)'] = 'list all construction sites matching an optional filter';
        descr['removeUnbuiltConstructionSites()'] = 'removes all construction sites with 0 progress';
        descr['listDirectives(filter?)'] = 'list directives, matching a filter if specified';
        descr['listPersistentDirectives()'] = 'print type, name, pos of every persistent directive';
        descr['removeFlagsByColor(color, secondaryColor)'] = 'remove flags that match the specified colors';
        descr['removeErrantFlags()'] = 'remove all flags which don\'t match a directive';
        descr['deepCleanMemory()'] = 'deletes all non-critical portions of memory (be careful!)';
        descr['profileMemory(root=Memory, depth=1)'] = 'scan through memory to get the size of various objects';
        descr['cancelMarketOrders(filter?)'] = 'cancels all market orders matching filter (if provided)';
        descr['setRoomUpgradeRate(room, upgradeRate)'] = 'changes the rate which a room upgrades at, default is 1';
        descr['getEmpireMineralDistribution()'] = 'returns current census of colonies and mined sk room minerals';
        descr['getPortals(rangeFromColonies)'] = 'returns active portals within colony range';
        descr['evaluateOutpostEfficiencies()'] = 'prints all colony outposts efficiency';
        descr['evaluatePotentialOutpostEfficiencies()'] = 'prints all nearby unmined outposts';
        const descrMsg = toColumns(descr, { justify: true, padChar: '.' });
        const maxLineLength = _.max(_.map(descrMsg, line => line.length)) + 2;
        msg += 'Console Commands: '.padRight(maxLineLength, '=') + '\n' + descrMsg.join('\n');
        msg += '\n\nRefer to the repository for more information\n';
        return msg;
    }
    static printUpdateMessage(aligned = false) {
        const joinChar = aligned ? alignedNewline : '\n';
        const msg = `Codebase updated or global reset. Type "help" for a list of console commands.` + joinChar +
            color(asciiLogoSmall.join(joinChar), '#ff00ff') + joinChar +
            OvermindConsole.info(aligned);
        log.alert(msg);
    }
    static printTrainingMessage() {
        console.log('\n' + asciiLogoRL.join('\n') + '\n');
    }
    static info(aligned = false) {
        const b = bullet;
        const baseInfo = [
            `${b}Version:        Overmind v${__VERSION__}`,
            `${b}Operating mode: ${Memory.settings.operationMode}`,
        ];
        const joinChar = aligned ? alignedNewline : '\n';
        return baseInfo.join(joinChar);
    }
    static notifications() {
        const notifications = Overmind.overseer.notifier.generateNotificationsList(true);
        return _.map(notifications, msg => bullet + msg).join('\n');
    }
    static setMode(mode) {
        switch (mode) {
            case 'manual':
                Memory.settings.operationMode = 'manual';
                return `Operational mode set to manual. Only defensive directives will be placed automatically; ` +
                    `remove harvesting, claiming, room planning, and raiding must be done manually.`;
            case 'semiautomatic':
                Memory.settings.operationMode = 'semiautomatic';
                return `Operational mode set to semiautomatic. Claiming, room planning, and raiding must be done ` +
                    `manually; everything else is automatic.`;
            case 'automatic':
                Memory.settings.operationMode = 'automatic';
                return `Operational mode set to automatic. All actions are done automatically, but manually placed ` +
                    `directives will still be responded to.`;
            default:
                return `Invalid mode: please specify 'manual', 'semiautomatic', or 'automatic'.`;
        }
    }
    static setSignature(signature) {
        const sig = signature ? signature : DEFAULT_OVERMIND_SIGNATURE;
        if (sig.length > 100) {
            throw new Error(`Invalid signature: ${signature}; length is over 100 chars.`);
        }
        else if (sig.toLowerCase().includes('overmind') || sig.includes(DEFAULT_OVERMIND_SIGNATURE)) {
            Memory.settings.signature = sig;
            return `Controller signature set to ${sig}`;
        }
        else {
            throw new Error(`Invalid signature: ${signature}; must contain the string "Overmind" or ` +
                `${DEFAULT_OVERMIND_SIGNATURE} (accessible on global with __DEFAULT_OVERMIND_SIGNATURE__)`);
        }
    }
    static debug(thing) {
        thing.memory.debug = true;
        return `Enabled debugging for ${thing.name || thing.ref || '(no name or ref)'}.`;
    }
    static stopDebug(thing) {
        delete thing.memory.debug;
        return `Disabled debugging for ${thing.name || thing.ref || '(no name or ref)'}.`;
    }
    static print(...args) {
        let message = '';
        for (const arg of args) {
            let cache = [];
            const msg = JSON.stringify(arg, function (key, value) {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) {
                        try {
                            return JSON.parse(JSON.stringify(value));
                        }
                        catch (error) {
                            return;
                        }
                    }
                    cache.push(value);
                }
                return value;
            }, '\t');
            cache = null;
            message += '\n' + msg;
        }
        return message;
    }
    static timeit(callback, repeat = 1) {
        let start, used, i;
        start = Game.cpu.getUsed();
        for (i = 0; i < repeat; i++) {
            callback();
        }
        used = Game.cpu.getUsed() - start;
        return `CPU used: ${used}. Repetitions: ${repeat} (${used / repeat} each).`;
    }
    static profileOverlord(overlord, ticks) {
        const overlordInstance = typeof overlord == 'string' ? Overmind.overlords[overlord]
            : overlord;
        if (!overlordInstance) {
            return `No overlord found for ${overlord}!`;
        }
        else {
            overlordInstance.startProfiling(ticks);
            return `Profiling ${overlordInstance.print} for ${ticks || 'indefinite'} ticks.`;
        }
    }
    static finishProfilingOverlord(overlord, ticks) {
        const overlordInstance = typeof overlord == 'string' ? Overmind.overlords[overlord]
            : overlord;
        if (!overlordInstance) {
            return `No overlord found for ${overlord}!`;
        }
        else {
            overlordInstance.finishProfiling();
            return `Profiling ${overlordInstance.print} stopped.`;
        }
    }
    static suspendColony(roomName) {
        if (Overmind.colonies[roomName]) {
            const colonyMemory = Memory.colonies[roomName];
            if (colonyMemory) {
                colonyMemory.suspend = true;
                Overmind.shouldBuild = true;
                return `Colony ${roomName} suspended.`;
            }
            else {
                return `No colony memory for ${roomName}!`;
            }
        }
        else {
            return `Colony ${roomName} is not a valid colony!`;
        }
    }
    static unsuspendColony(roomName) {
        const colonyMemory = Memory.colonies[roomName];
        if (colonyMemory) {
            if (!colonyMemory.suspend) {
                return `Colony ${roomName} is not suspended!`;
            }
            else {
                delete colonyMemory.suspend;
                Overmind.shouldBuild = true;
                return `Colony ${roomName} unsuspended.`;
            }
        }
        else {
            return `No colony memory for ${roomName}!`;
        }
    }
    static listSuspendedColonies() {
        let msg = 'Colonies currently suspended: \n';
        for (const i in Memory.colonies) {
            const colonyMemory = Memory.colonies[i];
            if (colonyMemory && colonyMemory.suspend == true) {
                msg += 'Colony ' + i + ' \n';
            }
        }
        return msg;
    }
    static openRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active != true) {
                Overmind.colonies[roomName].roomPlanner.active = true;
                return '';
            }
            else {
                return `RoomPlanner for ${roomName} is already active!`;
            }
        }
        else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static closeRoomPlanner(roomName, ignoreRoads = false) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active) {
                Overmind.colonies[roomName].roomPlanner.finalize(ignoreRoads);
                return '';
            }
            else {
                return `RoomPlanner for ${roomName} is not active!`;
            }
        }
        else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static cancelRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active) {
                Overmind.colonies[roomName].roomPlanner.active = false;
                return `RoomPlanner for ${roomName} has been deactivated without saving changes`;
            }
            else {
                return `RoomPlanner for ${roomName} is not active!`;
            }
        }
        else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static listActiveRoomPlanners() {
        const coloniesWithActiveRoomPlanners = _.filter(_.map(_.keys(Overmind.colonies), colonyName => Overmind.colonies[colonyName]), (colony) => colony.roomPlanner.active);
        const names = _.map(coloniesWithActiveRoomPlanners, colony => colony.room.print);
        if (names.length > 0) {
            console.log('Colonies with active room planners: ' + names);
            return '';
        }
        else {
            return `No colonies with active room planners`;
        }
    }
    static listConstructionSites(filter) {
        let msg = `${_.keys(Game.constructionSites).length} construction sites currently present: \n`;
        for (const id in Game.constructionSites) {
            const site = Game.constructionSites[id];
            if (!filter || filter(site)) {
                msg += `${bullet}Type: ${site.structureType}`.padRight(20) +
                    `Pos: ${site.pos.print}`.padRight(65) +
                    `Progress: ${site.progress} / ${site.progressTotal} \n`;
            }
        }
        return msg;
    }
    static listDirectives(filter) {
        let msg = '';
        for (const i in Overmind.directives) {
            const dir = Overmind.directives[i];
            if (!filter || filter(dir)) {
                msg += `${bullet}Name: ${dir.print}`.padRight(70) +
                    `Colony: ${dir.colony.print}`.padRight(55) +
                    `Pos: ${dir.pos.print}\n`;
            }
        }
        return msg;
    }
    static removeAllLogisticsDirectives() {
        const logisticsFlags = _.filter(Game.flags, flag => flag.color == COLOR_YELLOW &&
            flag.secondaryColor == COLOR_YELLOW);
        for (const dir of logisticsFlags) {
            dir.remove();
        }
        return `Removed ${logisticsFlags.length} logistics directives.`;
    }
    static listPersistentDirectives() {
        let msg = '';
        for (const i in Overmind.directives) {
            const dir = Overmind.directives[i];
            if (dir.memory.persistent) {
                msg += `Type: ${dir.directiveName}`.padRight(20) +
                    `Name: ${dir.name}`.padRight(15) +
                    `Pos: ${dir.pos.print}\n`;
            }
        }
        return msg;
    }
    static removeFlagsByColor(color, secondaryColor) {
        const removeFlags = _.filter(Game.flags, flag => flag.color == color && flag.secondaryColor == secondaryColor);
        for (const flag of removeFlags) {
            flag.remove();
        }
        return `Removed ${removeFlags.length} flags.`;
    }
    static removeErrantFlags() {
        if (USE_SCREEPS_PROFILER) {
            return `ERROR: should not be run while profiling is enabled!`;
        }
        let count = 0;
        for (const name in Game.flags) {
            if (!Overmind.directives[name]) {
                Game.flags[name].remove();
                count += 1;
            }
        }
        return `Removed ${count} flags.`;
    }
    static destroyErrantStructures(roomName) {
        const colony = Overmind.colonies[roomName];
        if (!colony)
            return `${roomName} is not a valid colony!`;
        const room = colony.room;
        const allStructures = room.find(FIND_STRUCTURES);
        let i = 0;
        for (const s of allStructures) {
            if (s.structureType == STRUCTURE_CONTROLLER)
                continue;
            if (!colony.roomPlanner.structureShouldBeHere(s.structureType, s.pos)) {
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
        }
        return `Destroyed ${i} misplaced structures in ${roomName}.`;
    }
    static destroyAllHostileStructures(roomName) {
        const room = Game.rooms[roomName];
        if (!room)
            return `${roomName} is undefined! (No vision?)`;
        if (!room.my)
            return `${roomName} is not owned by you!`;
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        for (const structure of hostileStructures) {
            structure.destroy();
        }
        return `Destroyed ${hostileStructures.length} hostile structures.`;
    }
    static destroyAllBarriers(roomName) {
        const room = Game.rooms[roomName];
        if (!room)
            return `${roomName} is undefined! (No vision?)`;
        if (!room.my)
            return `${roomName} is not owned by you!`;
        for (const barrier of room.barriers) {
            barrier.destroy();
        }
        return `Destroyed ${room.barriers.length} barriers.`;
    }
    static removeUnbuiltConstructionSites() {
        let msg = '';
        for (const id in Game.constructionSites) {
            const csite = Game.constructionSites[id];
            if (csite.progress == 0) {
                const ret = csite.remove();
                msg += `Removing construction site for ${csite.structureType} with 0% progress at ` +
                    `${csite.pos.print}; response: ${ret}\n`;
            }
        }
        return msg;
    }
    static setRoomUpgradeRate(roomName, rate) {
        const colony = Overmind.colonies[roomName];
        colony.upgradeSite.memory.speedFactor = rate;
        return `Colony ${roomName} is now upgrading at a rate of ${rate}.`;
    }
    static getEmpireMineralDistribution() {
        const minerals = EmpireAnalysis.empireMineralDistribution();
        let ret = 'Empire Mineral Distribution \n';
        for (const mineral in minerals) {
            ret += `${mineral}: ${minerals[mineral]} \n`;
        }
        return ret;
    }
    static listPortals(rangeFromColonies = 5, includeIntershard = false) {
        const colonies = getAllColonies();
        const allPortals = colonies.map(colony => RoomIntel.findPortalsInRange(colony.name, rangeFromColonies));
        let ret = `Empire Portal Census \n`;
        for (const colonyId in allPortals) {
            const portals = allPortals[colonyId];
            if (_.keys(portals).length > 0) {
                ret += `Colony ${colonies[colonyId].print}: \n`;
            }
            for (const portalRoomName of _.keys(portals)) {
                const samplePortal = _.first(portals[portalRoomName]);
                ret += `\t\t Room ${printRoomName(portalRoomName)} Destination ${samplePortal.dest} ` +
                    `Expiration ${samplePortal["X"] - Game.time}] \n`;
            }
        }
        return ret;
    }
    static evaluateOutpostEfficiencies() {
        const colonies = getAllColonies();
        const outpostEfficiencies = {};
        let avgEnergyPerCPU = 0;
        colonies.forEach(colony => {
            if (colony.bunker) {
                colony.outposts.forEach(outpost => {
                    const res = ExpansionEvaluator.computeTheoreticalMiningEfficiency(colony.bunker.anchor, outpost.name);
                    if (typeof res === 'boolean') {
                        log.error(`Failed on outpost ${outpost.print}`);
                    }
                    else {
                        outpostEfficiencies[outpost.name] = res;
                        avgEnergyPerCPU += res;
                    }
                });
            }
        });
        avgEnergyPerCPU = avgEnergyPerCPU / Object.keys(outpostEfficiencies).length;
        let ret = `Suspect Outposts +25% below avg efficiency of ${avgEnergyPerCPU}: \n`;
        for (const outpost in outpostEfficiencies) {
            if (outpostEfficiencies[outpost] < avgEnergyPerCPU * 0.75) {
                ret += `${outpost} ${outpostEfficiencies[outpost]} \n`;
            }
        }
        return ret;
    }
    static evaluatePotentialOutpostEfficiencies() {
        const colonies = getAllColonies();
        const outpostEfficiencies = {};
        let avgEnergyPerCPU = 0;
        colonies.forEach(colony => {
            if (colony.bunker) {
                Cartographer.findRoomsInRange(colony.name, 2).forEach(outpost => {
                    if (!colony.outposts.map(room => room.name).includes(outpost)) {
                        const res = ExpansionEvaluator.computeTheoreticalMiningEfficiency(colony.bunker.anchor, outpost);
                        if (typeof res === 'boolean') {
                            log.error(`Failed on outpost ${outpost}`);
                        }
                        else {
                            outpostEfficiencies[outpost] = res;
                            avgEnergyPerCPU += res;
                        }
                    }
                });
            }
        });
        avgEnergyPerCPU = avgEnergyPerCPU / Object.keys(outpostEfficiencies).length;
        let ret = `Possible new outposts above avg efficiency of ${avgEnergyPerCPU}: \n`;
        for (const outpost in outpostEfficiencies) {
            if (outpostEfficiencies[outpost] > avgEnergyPerCPU * 1.25 || outpostEfficiencies[outpost] > 20) {
                ret += `${outpost} ${outpostEfficiencies[outpost]} \n`;
            }
        }
        return ret;
    }
    static deepCleanMemory() {
        const protectedColonyKeys = ['defcon', 'roomPlanner', 'roadPlanner', 'barrierPlanner'];
        for (const colName in Memory.colonies) {
            for (const key in Memory.colonies[colName]) {
                if (!protectedColonyKeys.includes(key)) {
                    delete Memory.colonies[colName][key];
                }
            }
        }
        for (const i in Game.creeps) {
            if (_.isEmpty(Game.creeps[i].memory)) {
                Game.creeps[i].suicide();
            }
        }
        delete Memory.screepsProfiler;
        for (const i in Memory.flags) {
            if (Memory.flags[i].overlords) {
                delete Memory.flags[i].overlords;
            }
        }
        for (const i in Memory.creeps) {
            if (Memory.creeps[i].task) {
                Memory.creeps[i].task = null;
            }
        }
        return `Memory has been cleaned.`;
    }
    static recursiveMemoryProfile(memoryObject, sizes, currentDepth) {
        for (const key in memoryObject) {
            if (currentDepth == 0 || !_.keys(memoryObject[key]) || _.keys(memoryObject[key]).length == 0) {
                sizes[key] = JSON.stringify(memoryObject[key]).length;
            }
            else {
                sizes[key] = {};
                OvermindConsole.recursiveMemoryProfile(memoryObject[key], sizes[key], currentDepth - 1);
            }
        }
    }
    static profileMemory(root = Memory, depth = 1) {
        const sizes = {};
        console.log(`Profiling memory...`);
        const start = Game.cpu.getUsed();
        OvermindConsole.recursiveMemoryProfile(root, sizes, depth);
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        return JSON.stringify(sizes, undefined, '\t');
    }
    static cancelMarketOrders(filter) {
        const ordersToCancel = !!filter ? _.filter(Game.market.orders, order => filter(order)) : Game.market.orders;
        _.forEach(_.values(ordersToCancel), (order) => Game.market.cancelOrder(order.id));
        return `Canceled ${_.values(ordersToCancel).length} orders.`;
    }
}

let ReservingOverlord = class ReservingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.remoteRoom.reserve) {
        super(directive, 'reserve', priority);
        this.priority += this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.reserveBuffer = 2000;
        this.reservers = this.zerg(Roles.claim);
    }
    init() {
        let amount = 0;
        if (this.room) {
            if (this.room.controller.needsReserving(this.reserveBuffer)) {
                amount = 1;
            }
            else if (this.room.controller.reservation && !this.room.controller.reservedByMe) {
                amount = Math.min(this.room.controller.pos.availableNeighbors(true).length, 2);
            }
        }
        else if (RoomIntel.roomReservedBy(this.pos.roomName) == MY_USERNAME &&
            RoomIntel.roomReservationRemaining(this.pos.roomName) < 1000) {
            amount = 1;
        }
        this.wishlist(amount, Setups.infestors.reserve, { reassignIdle: true });
    }
    handleReserver(reserver) {
        if (reserver.avoidDanger())
            return;
        if (reserver.room == this.room && !reserver.pos.isEdge) {
            if (!this.room.controller.signedByMe) {
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    reserver.task = Tasks.reserve(this.room.controller);
                }
                else {
                    reserver.task = Tasks.signController(this.room.controller);
                }
            }
            else {
                reserver.task = Tasks.reserve(this.room.controller);
            }
        }
        else {
            reserver.goTo(this.pos);
        }
    }
    run() {
        this.autoRun(this.reservers, reserver => this.handleReserver(reserver));
    }
};
ReservingOverlord = __decorate([
    profile
], ReservingOverlord);

let StationaryScoutOverlord = class StationaryScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.stationary) {
        super(directive, 'scout', priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(1, Setups.scout);
    }
    run() {
        for (const scout of this.scouts) {
            if (!(scout.pos.inRangeTo(this.pos, 3) && !scout.pos.isEdge)) {
                scout.goTo(this.pos, { range: 3 });
            }
        }
    }
};
StationaryScoutOverlord = __decorate([
    profile
], StationaryScoutOverlord);

var DirectiveOutpost_1;
let DirectiveOutpost = DirectiveOutpost_1 = class DirectiveOutpost extends Directive {
    spawnMoarOverlords() {
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CONTROLLER &&
            this.colony.level >= DirectiveOutpost_1.settings.canSpawnReserversAtRCL &&
            patternCost(Setups.infestors.reserve) <= this.colony.room.energyCapacityAvailable) {
            this.overlords.reserve = new ReservingOverlord(this);
            return;
        }
        this.overlords.scout = new StationaryScoutOverlord(this);
    }
    init() {
    }
    run() {
        if (RoomIntel.roomOwnedBy(this.pos.roomName)) {
            log.warning(`Removing ${this.print} since room is owned!`);
            this.remove();
        }
        if (Game.time % 10 == 3 && this.room && this.room.controller
            && !this.pos.isEqualTo(this.room.controller.pos) && !this.memory.setPos) {
            this.setPosition(this.room.controller.pos);
        }
    }
};
DirectiveOutpost.directiveName = 'outpost';
DirectiveOutpost.color = COLOR_PURPLE;
DirectiveOutpost.secondaryColor = COLOR_PURPLE;
DirectiveOutpost.settings = {
    canSpawnReserversAtRCL: 3,
};
DirectiveOutpost = DirectiveOutpost_1 = __decorate([
    profile
], DirectiveOutpost);

let GameCache = class GameCache {
    constructor() {
        this.overlords = {};
        this.creepsByColony = {};
        this.targets = {};
        this.outpostFlags = _.filter(Game.flags, flag => DirectiveOutpost.filter(flag)
            || DirectiveSKOutpost.filter(flag));
    }
    cacheCreepsByColony() {
        this.creepsByColony = _.groupBy(Game.creeps, creep => creep.memory["C"]);
    }
    cacheOverlords() {
        this.overlords = {};
        const creepNamesByOverlord = _.groupBy(_.keys(Game.creeps), name => Game.creeps[name].memory["O"]);
        const powerCreepNamesByOverlord = _.groupBy(_.keys(Game.powerCreeps), name => Game.powerCreeps[name].memory["O"]);
        for (const ref in creepNamesByOverlord) {
            this.overlords[ref] = _.groupBy(creepNamesByOverlord[ref], name => (Game.creeps[name] || Game.powerCreeps[name]).memory.role);
        }
    }
    cacheTargets() {
        this.targets = {};
        for (const i in Game.creeps) {
            const creep = Game.creeps[i];
            let task = creep.memory.task;
            while (task) {
                if (!this.targets[task._target.ref])
                    this.targets[task._target.ref] = [];
                this.targets[task._target.ref].push(creep.name);
                task = task._parent;
            }
        }
    }
    build() {
        this.cacheCreepsByColony();
        this.cacheOverlords();
        this.cacheTargets();
    }
    refresh() {
        this.cacheCreepsByColony();
        this.cacheOverlords();
        this.cacheTargets();
    }
};
GameCache = __decorate([
    profile
], GameCache);

let PioneerOverlord = class PioneerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.pioneer) {
        super(directive, 'pioneer', priority);
        this.directive = directive;
        this.pioneers = this.zerg(Roles.pioneer);
        this.spawnSite = this.room ? _.filter(this.room.constructionSites, s => s.structureType == STRUCTURE_SPAWN)[0] : undefined;
    }
    refresh() {
        super.refresh();
        this.spawnSite = this.room ? _.filter(this.room.constructionSites, s => s.structureType == STRUCTURE_SPAWN)[0] : undefined;
    }
    init() {
        var type = this.directive.type;
        this.wishlist(4, Setups.pioneers[type]);
    }
    findStructureBlockingController(pioneer) {
        const blockingPos = Pathing.findBlockingPos(pioneer.pos, pioneer.room.controller.pos, _.filter(pioneer.room.structures, s => !s.isWalkable));
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            return structure || log.error(`${this.print}: no structure at blocking pos ${blockingPos.print}!`);
        }
    }
    handlePioneer(pioneer) {
        var viable = true;
        if (pioneer.getActiveBodyparts(WORK) <= 0 || !viable)
            pioneer.retire();
        if (pioneer.room != this.room || pioneer.pos.isEdge) {
            pioneer.goTo(this.pos, { pathOpts: { ensurePath: true, avoidSK: true } });
            return;
        }
        if (!this.room.controller && this.directive.directiveName == DirectiveColonizeShard.directiveName) {
            pioneer.goToSameRoom(this.pos);
            return;
        }
        if (!this.room.my && this.room.structures.length > 0) {
            const dismantleTarget = this.findStructureBlockingController(pioneer);
            if (dismantleTarget) {
                pioneer.task = Tasks.dismantle(dismantleTarget);
                return;
            }
        }
        if (pioneer.carry.energy == 0) {
            pioneer.task = Tasks.recharge();
            if (!pioneer.task.isValidTask()) {
                viable = false;
            }
        }
        else if (this.room && this.room.controller && (this.room.controller.ticksToDowngrade <
            (0.1 * CONTROLLER_DOWNGRADE[this.room.controller.level])
            || !this.spawnSite)
            && !(this.room.controller.upgradeBlocked > 0)) {
            pioneer.task = Tasks.upgrade(this.room.controller);
            if (!pioneer.task.isValidTask()) {
                viable = false;
            }
        }
        else if (this.spawnSite) {
            pioneer.task = Tasks.build(this.spawnSite);
            if (!pioneer.task.isValidTask()) {
                viable = false;
            }
        }
    }
    run() {
        this.autoRun(this.pioneers, pioneer => this.handlePioneer(pioneer));
    }
};
PioneerOverlord = __decorate([
    profile
], PioneerOverlord);

var DirectiveColonizeShard_1;
let DirectiveColonizeShard = DirectiveColonizeShard_1 = class DirectiveColonizeShard extends Directive {
    constructor(flag) {
        flag.memory.allowPortals = true;
        super(flag, colony => colony.level >= DirectiveColonizeShard_1.requiredRCL
            && colony.name != Directive.getPos(flag).roomName && colony.spawns.length > 0);
        const roomType = Cartographer.roomType(this.pos.roomName);
        if (roomType != ROOMTYPE_CONTROLLER && roomType != ROOMTYPE_CROSSROAD) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller or crossroad (portal) room; ` +
                `removing directive!`);
            this.remove(true);
            return;
        }
        if (roomType == ROOMTYPE_CROSSROAD) {
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.pioneer = new PioneerOverlord(this);
    }
    init() {
        this.alert(`Colonization on new shard in progress`);
    }
    run() {
    }
};
DirectiveColonizeShard.directiveName = 'colonizeShard';
DirectiveColonizeShard.color = COLOR_PURPLE;
DirectiveColonizeShard.secondaryColor = COLOR_BLUE;
DirectiveColonizeShard.requiredRCL = 3;
DirectiveColonizeShard = DirectiveColonizeShard_1 = __decorate([
    profile
], DirectiveColonizeShard);

let ClaimingOverlord = class ClaimingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.claim) {
        super(directive, 'claim', priority);
        this.directive = directive;
        this.claimers = this.zerg(Roles.claim);
    }
    init() {
        const amount = $.number(this, 'claimerAmount', () => {
            if (!this.room)
                return 1;
            if (this.room.my)
                return 0;
            const pathablePos = this.room.creeps[0] ? this.room.creeps[0].pos
                : Pathing.findPathablePosition(this.room.name);
            const pathDestination = this.room.controller ? this.room.controller.pos : this.pos;
            if (!Pathing.isReachable(pathablePos, pathDestination, _.filter(this.room.structures, s => !s.isWalkable))) {
                log.warning(`Path for Directive ${this.directive.name} is not pathable`);
                return 0;
            }
            return 1;
        });
        const setup = this.colony.level > 4 ? Setups.infestors.fastClaim : Setups.infestors.claim;
        this.wishlist(amount, setup, { reassignIdle: true });
    }
    handleClaimer(claimer) {
        if (claimer.room != this.room || claimer.pos.isEdge) {
            claimer.goTo(this.pos, { pathOpts: { ensurePath: true, avoidSK: true } });
            return;
        }
        if (!this.room.controller && this.directive.directiveName == DirectiveColonizeShard.directiveName) {
            claimer.goToSameRoom(this.pos);
            return;
        }
        if (this.room.controller.signedByMe || (!this.room.my && this.room.controller.signedByScreeps)) {
            claimer.task = Tasks.claim(this.room.controller);
            return;
        }
        claimer.task = Tasks.signController(this.room.controller);
    }
    run() {
        this.autoRun(this.claimers, claimer => this.handleClaimer(claimer));
    }
};
ClaimingOverlord = __decorate([
    profile
], ClaimingOverlord);

let HaulingOverlord = class HaulingOverlord extends Overlord {
    constructor(directive, priority = directive.hasDrops ? OverlordPriority.collectionUrgent.haul :
        OverlordPriority.tasks.haul) {
        super(directive, 'haul', priority);
        this.directive = directive;
        this.haulers = this.zerg(Roles.transport);
    }
    init() {
        if (!this.colony.storage || _.sum(this.colony.storage.store) > Energetics.settings.storage.total.cap) {
            return;
        }
        const MAX_HAULERS = 5;
        const tripDistance = 2 * (Pathing.distance((this.colony.storage || this.colony).pos, this.directive.pos) || 0);
        const haulingPowerNeeded = Math.min(this.directive.totalResources, this.colony.storage.storeCapacity
            - _.sum(this.colony.storage.store)) * tripDistance;
        const haulerCarryParts = Setups.transporters.early.getBodyPotential(CARRY, this.colony);
        const haulingPowerPerLifetime = CREEP_LIFE_TIME * haulerCarryParts * CARRY_CAPACITY;
        const numHaulers = Math.min(Math.ceil(haulingPowerNeeded / haulingPowerPerLifetime), MAX_HAULERS);
        this.wishlist(numHaulers, Setups.transporters.early);
    }
    handleHauler(hauler) {
        if (_.sum(hauler.carry) == 0) {
            if (hauler.inSameRoomAs(this.directive)) {
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop = _.find(allDrops, drop => drop.resourceType != 'energy') || allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    }
                }
                if (this.directive.storeStructure) {
                    const store = this.directive.store;
                    let totalDrawn = 0;
                    for (const resourceType in store) {
                        if (store[resourceType] > 0) {
                            if (hauler.task) {
                                hauler.task = Tasks.withdraw(this.directive.storeStructure, resourceType).fork(hauler.task);
                            }
                            else {
                                hauler.task = Tasks.withdraw(this.directive.storeStructure, resourceType);
                            }
                            totalDrawn += store[resourceType];
                            if (totalDrawn >= hauler.carryCapacity) {
                                return;
                            }
                        }
                    }
                    if (hauler.task) {
                        return;
                    }
                }
                log.warning(`${hauler.name} in ${hauler.room.print}: nothing to collect!`);
            }
            else {
                hauler.goTo(this.directive, { pathOpts: { avoidSK: true } });
            }
        }
        else {
            if (hauler.inSameRoomAs(this.colony)) {
                for (const [resourceType, amount] of hauler.carry.contents) {
                    if (amount == 0)
                        continue;
                    if (resourceType == RESOURCE_ENERGY) {
                        if (this.colony.storage && _.sum(this.colony.storage.store) < STORAGE_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.storage, resourceType);
                            return;
                        }
                        else if (this.colony.terminal && _.sum(this.colony.terminal.store) < TERMINAL_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                    }
                    else {
                        if (this.colony.terminal && this.colony.terminal.my
                            && _.sum(this.colony.terminal.store) < TERMINAL_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                        else if (this.colony.storage && _.sum(this.colony.storage.store) < STORAGE_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.storage, resourceType);
                            return;
                        }
                    }
                }
                log.warning(`${hauler.name} in ${hauler.room.print}: nowhere to put resources!`);
            }
            else {
                hauler.task = Tasks.goToRoom(this.colony.room.name);
            }
        }
    }
    run() {
        for (const hauler of this.haulers) {
            if (hauler.isIdle) {
                this.handleHauler(hauler);
            }
            hauler.run();
        }
        if (this.directive.memory.totalResources == 0 && this.haulers.filter(hauler => _.sum(hauler.carry) > 0).length == 0) {
            this.directive.remove();
        }
    }
};
HaulingOverlord = __decorate([
    profile
], HaulingOverlord);

var DirectiveHaul_1;
let DirectiveHaul = DirectiveHaul_1 = class DirectiveHaul extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= DirectiveHaul_1.requiredRCL);
    }
    spawnMoarOverlords() {
        this.overlords.haul = new HaulingOverlord(this);
    }
    get targetedBy() {
        return Overmind.cache.targets[this.ref];
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops) {
            const drops = (this.pos.lookFor(LOOK_RESOURCES) || []);
            this._drops = _.groupBy(drops, drop => drop.resourceType);
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get storeStructure() {
        if (this.pos.isVisible) {
            return this.pos.lookForStructure(STRUCTURE_STORAGE) ||
                this.pos.lookForStructure(STRUCTURE_TERMINAL) ||
                this.pos.lookForStructure(STRUCTURE_NUKER) ||
                this.pos.lookForStructure(STRUCTURE_CONTAINER) ||
                this.pos.lookFor(LOOK_RUINS).filter(ruin => ruin.store.getUsedCapacity() > 0)[0] ||
                this.pos.lookFor(LOOK_TOMBSTONES).filter(tombstone => tombstone.store.getUsedCapacity() > 0)[0];
        }
        return undefined;
    }
    get store() {
        if (!this._store) {
            let store = {};
            if (this.storeStructure) {
                store = this.storeStructure.store;
            }
            else {
                store = { energy: 0 };
            }
            for (const resourceType of _.keys(this.drops)) {
                const totalResourceAmount = _.sum(this.drops[resourceType], drop => drop.amount);
                if (store[resourceType]) {
                    store[resourceType] += totalResourceAmount;
                }
                else {
                    store[resourceType] = totalResourceAmount;
                }
            }
            this._store = store;
        }
        return this._store;
    }
    get totalResources() {
        if (this.pos.isVisible && this.store) {
            this.memory.totalResources = _.sum(this.store);
        }
        else {
            if (this.memory.totalResources == undefined) {
                return 1000;
            }
        }
        return this.memory.totalResources;
    }
    refresh() {
        super.refresh();
        this._store = undefined;
    }
    init() {
        this.alert(`Haul directive active - ${this.totalResources}`);
    }
    run() {
        if (this.pos.isVisible && _.sum(this.store) == 0) {
            this._finishAtTime = this._finishAtTime || (Game.time + 300);
        }
        if (Game.time >= this._finishAtTime || (this.totalResources == 0 &&
            this.overlords.haul.haulers.length == 0)) {
        }
    }
};
DirectiveHaul.directiveName = 'haul';
DirectiveHaul.color = COLOR_YELLOW;
DirectiveHaul.secondaryColor = COLOR_BLUE;
DirectiveHaul.requiredRCL = 4;
DirectiveHaul = DirectiveHaul_1 = __decorate([
    profile
], DirectiveHaul);

let DirectiveDismantle = class DirectiveDismantle extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {
        const target = this.getTarget();
        if (target && !this.colony.overlords.work.dismantleStructures.includes(target)) {
            this.colony.overlords.work.dismantleStructures.push(target);
        }
    }
    run() {
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'yellow' });
    }
};
DirectiveDismantle.directiveName = 'dismantle';
DirectiveDismantle.color = COLOR_GREY;
DirectiveDismantle.secondaryColor = COLOR_YELLOW;
DirectiveDismantle = __decorate([
    profile
], DirectiveDismantle);

let DirectiveClearRoom = class DirectiveClearRoom extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 3);
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller room; ` +
                `removing directive!`);
            this.remove(true);
        }
        if (Memory.settings.resourceCollectionMode && Memory.settings.resourceCollectionMode >= 1) {
            this.memory.keepStorageStructures = true;
        }
        this.memory.preexistingFlags = _.filter(Game.flags, testingflag => testingflag.pos.roomName == flag.pos.roomName && testingflag.name != flag.name)
            .map(testingFlag => testingFlag.name);
        console.log('Existing flags in clear room are ' + JSON.stringify(this.memory.preexistingFlags));
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
    }
    init() {
        this.alert(`Clearing out room`);
    }
    removeAllStructures() {
        const keepStorageStructures = this.memory.keepStorageStructures !== undefined
            ? this.memory.keepStorageStructures : true;
        const keepRoads = this.memory.keepRoads !== undefined ? this.memory.keepRoads : true;
        const keepContainers = this.memory.keepContainers !== undefined ? this.memory.keepContainers : true;
        if (this.room) {
            const allStructures = this.room.find(FIND_STRUCTURES);
            let i = 0;
            for (const s of allStructures) {
                if (s.structureType == STRUCTURE_CONTROLLER) {
                    continue;
                }
                if (keepStorageStructures &&
                    (s.structureType == STRUCTURE_STORAGE || s.structureType == STRUCTURE_TERMINAL) &&
                    !s.isEmpty) {
                    DirectiveHaul.createIfNotPresent(s.pos, 'pos');
                    continue;
                }
                if (s.structureType == STRUCTURE_NUKER && s.energy > 50000) {
                    DirectiveHaul.createIfNotPresent(s.pos, 'pos');
                }
                if (keepRoads && s.structureType == STRUCTURE_ROAD) {
                    continue;
                }
                if (keepContainers && s.structureType == STRUCTURE_CONTAINER) {
                    continue;
                }
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
            log.alert(`Destroyed ${i} structures in ${this.room.print}.`);
            this.memory.completedTime = Game.time;
            return true;
        }
        else {
            return false;
        }
    }
    findStructureBlockingController(pioneer) {
        const blockingPos = Pathing.findBlockingPos(pioneer.pos, pioneer.room.controller.pos, _.filter(pioneer.room.structures, s => !s.isWalkable));
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            if (structure) {
                return structure;
            }
            else {
                log.error(`${this.print}: no structure at blocking pos ${blockingPos.print}! (Why?)`);
            }
        }
    }
    cleanupFlags() {
        if (!this.room) {
            return false;
        }
        for (const flag of this.room.flags) {
            if (!_.contains(this.memory.preexistingFlags, flag.name) && flag.name != this.flag.name
                && !DirectiveHaul.filter(flag)) {
                flag.remove();
            }
        }
    }
    run() {
        if (this.room && this.room.my) {
            const done = this.removeAllStructures();
            if (done) {
                const result = this.room.controller.unclaim();
                this.cleanupFlags();
                log.notify(`Removing clearRoom directive in ${this.pos.roomName}: operation completed.`);
                if (result == OK) {
                    this.remove();
                    Overmind.shouldBuild = true;
                }
            }
        }
        else if (this.room && this.room.creeps.length > 1) {
            const currentlyDismantlingLocations = DirectiveDismantle.find(this.room.flags);
            if (currentlyDismantlingLocations.length == 0) {
                const pathablePos = this.room.creeps[0] ? this.room.creeps[0].pos
                    : Pathing.findPathablePosition(this.room.name);
                const blockingLocation = Pathing.findBlockingPos(pathablePos, this.room.controller.pos, _.filter(this.room.structures, s => !s.isWalkable));
                if (blockingLocation && !Directive.isPresent(blockingLocation)) {
                    log.notify(`Adding dismantle directive for ${this.pos.roomName} to reach controller.`);
                    DirectiveDismantle.create(blockingLocation);
                }
            }
        }
        if (Game.time % 10 == 2 && this.room && !!this.room.owner && this.room.owner != MY_USERNAME) {
            log.notify(`Removing clearRoom directive in ${this.pos.roomName}: room already owned by another player.`);
            this.remove();
        }
    }
};
DirectiveClearRoom.directiveName = 'clearRoom';
DirectiveClearRoom.color = COLOR_PURPLE;
DirectiveClearRoom.secondaryColor = COLOR_ORANGE;
DirectiveClearRoom = __decorate([
    profile
], DirectiveClearRoom);

var RoomPoisonerOverlord_1;
let RoomPoisonerOverlord = RoomPoisonerOverlord_1 = class RoomPoisonerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostOffense.roomPoisoner) {
        super(directive, 'PoisonRoom', priority);
        this.roomPoisoners = this.zerg(Roles.roomPoisoner);
    }
    init() {
        if (this.room) {
            const thingsToBlock = _.compact([this.room.controller, ...this.room.sources]);
            const neighborTiles = _.unique(_.flatten(_.map(thingsToBlock, obj => obj.pos.neighbors)), pos => packPos(pos));
            this.blockPositions = _.filter(neighborTiles, pos => pos.isWalkable(true));
        }
        else {
            this.blockPositions = [];
        }
        if (this.room && this.room.dangerousPlayerHostiles.length == 0) {
            this.wishlist(1, Setups.roomPoisoner);
        }
    }
    handleRoomPoisoner(posioner) {
        if (posioner.carry.energy < BUILD_POWER) {
            posioner.task = Tasks.recharge();
            return;
        }
        if (!posioner.inSameRoomAs(this)) {
            posioner.goTo(this.pos, { pathOpts: { ensurePath: true, avoidSK: true } });
            return;
        }
        if (this.room && this.room.controller && this.room.controller.my) {
            if (this.room.controller.level < 2) {
                posioner.task = Tasks.upgrade(this.room.controller);
                return;
            }
            const wallsUncached = this.room.find(FIND_STRUCTURES, { filter: { structureType: STRUCTURE_WALL } });
            const fortifyTarget = _.find(wallsUncached, wall => wall.hits < RoomPoisonerOverlord_1.settings.wallHits);
            if (fortifyTarget) {
                posioner.task = Tasks.fortify(fortifyTarget, RoomPoisonerOverlord_1.settings.wallHits);
                return;
            }
            const wallConstructionSite = _.first(this.room.constructionSites);
            if (wallConstructionSite) {
                posioner.task = Tasks.build(wallConstructionSite);
                return;
            }
            posioner.flee(this.blockPositions, {}, { fleeRange: 4 });
        }
    }
    run() {
        this.autoRun(this.roomPoisoners, roomPoisoner => this.handleRoomPoisoner(roomPoisoner));
    }
};
RoomPoisonerOverlord = RoomPoisonerOverlord_1 = __decorate([
    profile
], RoomPoisonerOverlord);

let OutpostDefenseOverlord = class OutpostDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.outpostDefense) {
        super(directive, 'outpostDefense', priority, 1);
        this.zerglings = this.combatZerg(Roles.melee);
        this.hydralisks = this.combatZerg(Roles.ranged);
        this.healers = this.combatZerg(Roles.healer);
    }
    handleCombat(zerg) {
        if (this.room && this.room.hostiles.length == 0) {
            zerg.doMedicActions(this.room.name);
        }
        else {
            zerg.autoSkirmish(this.pos.roomName);
        }
    }
    handleHealer(healer) {
        var towersAvaliable = (healer.inFriendlyRoom && healer.towersAvaliable(healer.getCurrentColony()));
        if (CombatIntel.isHealer(healer) && healer.getActiveBodyparts(HEAL) == 0 && !towersAvaliable) {
            if (this.colony.towers.length > 0) {
                return healer.goToRoom(this.colony.room.name);
            }
            else {
                return healer.suicide();
            }
        }
        else {
            if (this.room && _.any([...this.zerglings, ...this.hydralisks], creep => creep.room == this.room)) {
                this.handleCombat(healer);
            }
            else {
                healer.autoSkirmish(healer.room.name);
            }
        }
    }
    getEnemyPotentials() {
        const d = { attack: 0, ranged: 1, heal: 0, };
        if (!this.room)
            return d;
        const pot = CombatIntel.getCombatPotentials(this.room.hostiles);
        if (!pot.ranged && !pot.attack && !pot.heal)
            return d;
        return pot;
    }
    init() {
        const enemyPotentials = this.getEnemyPotentials();
        const needAttack = enemyPotentials.attack * 1.1;
        const needRanged = enemyPotentials.ranged * 1.3;
        const needHeal = enemyPotentials.heal * 1.2;
        if (needAttack > 100 || needRanged > 100 || needHeal > 100) {
            log.alert(`${this.print}: too much firepower needed to fight: ${JSON.stringify(enemyPotentials)}`);
            return;
        }
        if (this.reassignIdleCreeps(Roles.melee, 1))
            return;
        if (this.reassignIdleCreeps(Roles.ranged, 1))
            return;
        if (this.reassignIdleCreeps(Roles.healer, 1))
            return;
        const noBigColoniesNearby = _.all(this.spawnGroup.colonies, col => col.room.energyCapacityAvailable < 800);
        const myPotentials = CombatIntel.getMyCombatPotentials([...this.zerglings,
            ...this.hydralisks,
            ...this.healers]);
        const hydraliskSetup = noBigColoniesNearby ? CombatSetups.hydralisks.noHeal : CombatSetups.hydralisks.default;
        const zerglingSetup = noBigColoniesNearby ? CombatSetups.zerglings.default : CombatSetups.zerglings.healing;
        const healerSetup = CombatSetups.transfusers.default;
        if (myPotentials.ranged < needRanged) {
            this.requestCreep(hydraliskSetup);
        }
        else if (myPotentials.heal < needHeal) {
            this.requestCreep(healerSetup);
        }
        else if (myPotentials.attack < needAttack) {
            this.requestCreep(zerglingSetup);
        }
    }
    run() {
        this.autoRun(this.zerglings, zergling => this.handleCombat(zergling));
        this.autoRun(this.hydralisks, hydralisk => this.handleCombat(hydralisk));
        this.autoRun(this.healers, healer => this.handleHealer(healer));
    }
};
OutpostDefenseOverlord = __decorate([
    profile
], OutpostDefenseOverlord);

let DirectiveOutpostDefense = class DirectiveOutpostDefense extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.outpostDefense = new OutpostDefenseOverlord(this);
    }
    init() {
        const numHostiles = this.room ? this.room.hostiles.length.toString() : '???';
        this.alert(`Outpost defense (hostiles: ${numHostiles})`, NotifierPriority.High);
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
        }
        if (this.room && this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > 100) {
            if (_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax).length == 0) {
                this.remove();
            }
        }
    }
};
DirectiveOutpostDefense.directiveName = 'outpostDefense';
DirectiveOutpostDefense.color = COLOR_BLUE;
DirectiveOutpostDefense.secondaryColor = COLOR_RED;
DirectiveOutpostDefense = __decorate([
    profile
], DirectiveOutpostDefense);

let ControllerAttackerOverlord = class ControllerAttackerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.offense.controllerAttack) {
        super(directive, 'controllerAttack', priority);
        this.controllerAttackers = this.zerg(Roles.claim);
        this.spawnGroup = new SpawnGroup(this, { requiredRCL: 3 });
        this.refresh();
    }
    refresh() {
        super.refresh();
        if (!this.room || !this.room.controller) {
            this.attackPositions = [];
            return;
        }
        this.attackPositions = this.room.controller.pos.availableNeighbors(true);
        this.assignments = this.getPositionAssignments();
    }
    getPositionAssignments() {
        const assignments = {};
        const maxLoops = Math.min(this.attackPositions.length, this.controllerAttackers.length);
        const controllerAttackers = _.sortBy(this.controllerAttackers, zerg => zerg.name);
        for (let i = 0; i < maxLoops; i++) {
            assignments[controllerAttackers[i].name] = this.attackPositions[i];
        }
        return assignments;
    }
    init() {
        if ((this.controllerIsNeutral() != true && this.controllerAttackers.length < this.attackPositions.length) && !(this.room && this.room.controller && this.room.controller.upgradeBlocked && this.room.controller.upgradeBlocked > 0)) {
            this.wishlist(this.attackPositions.length, Setups.infestors.controllerAttacker, { noLifetimeFilter: true, reassignIdle: true });
        }
    }
    controllerIsNeutral() {
        if (!this.room || !this.room.controller)
            return undefined;
        if (this.room.controller.reservation && !this.room.controller.reservedByMe)
            return false;
        if (this.room.controller.owner && this.room.controller.owner.username != getMyUsername())
            return false;
        if (this.room.controller.level > 0)
            return false;
        return true;
    }
    run() {
        var _a;
        if (!this.room || !this.room.controller)
            return;
        if (this.room && this.room.controller && this.room.controller.upgradeBlocked && this.room.controller.upgradeBlocked > 0)
            return;
        var ready = 0;
        for (const controllerAttacker of this.controllerAttackers) {
            const attackPos = this.assignments[controllerAttacker.name];
            if (this.room && this.room.controller && this.room.controller.upgradeBlocked && this.room.controller.upgradeBlocked > 0)
                return;
            if (!attackPos) {
                log.error(`No attack position for ${controllerAttacker.print}!`);
                continue;
            }
            if (!attackPos.inRangeTo(controllerAttacker.pos, 0)) {
                controllerAttacker.goTo(attackPos);
                continue;
            }
            if (this.controllerIsNeutral()) {
                log.debug(`Controller already neutral: ${(_a = this.room) === null || _a === void 0 ? void 0 : _a.name}`);
                return;
            }
            if (!(controllerAttacker.getActiveBodyparts(CLAIM) == controllerAttacker.getBodyparts(CLAIM))) {
                controllerAttacker.retire();
                return;
            }
            if (attackPos.inRangeTo(controllerAttacker.pos, 0)) {
                ready += 1;
            }
            if (ready == this.controllerAttackers.length) {
                const ret = controllerAttacker.attackController(this.room.controller);
                if (ret != 0 && ret != -11) {
                    log.error(`Attacking Controller: ${this.room.controller.pos} Ret: ${ret}`);
                    continue;
                }
                this.finish(false);
            }
        }
    }
};
ControllerAttackerOverlord = __decorate([
    profile
], ControllerAttackerOverlord);

let DirectiveControllerAttack = class DirectiveControllerAttack extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.scout = new StationaryScoutOverlord(this);
        this.overlords.controllerAttack = new ControllerAttackerOverlord(this);
    }
    init() {
        const level = this.room && this.room.controller ? this.room.controller.level.toString() : '???';
        this.alert(`Downgrading controller (RCL${level})`);
    }
    run() {
        if (this.room && this.room.controller && (this.room.controller.level == 0 && (!this.room.controller.reservation || this.room.controller.reservation.ticksToEnd < 5))) {
            log.notify(`Removing ${this.name} since controller has reached level 0.`);
            this.remove();
        }
    }
};
DirectiveControllerAttack.directiveName = 'controllerAttack';
DirectiveControllerAttack.color = COLOR_RED;
DirectiveControllerAttack.secondaryColor = COLOR_PURPLE;
DirectiveControllerAttack = __decorate([
    profile
], DirectiveControllerAttack);

var DirectivePoisonRoom_1;
let DirectivePoisonRoom = DirectivePoisonRoom_1 = class DirectivePoisonRoom extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= DirectivePoisonRoom_1.requiredRCL);
        let remove = false;
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.error(`${this.print}: not placed is not a controller room; removing directive!`);
            remove = true;
        }
        if (this.room && this.room.controller && this.room.controller.my && this.room.controller.level > 2) {
            log.error(`Removing ${this.print}: room owned by self and above RCL 2!`);
            remove = true;
        }
        if (this.room && this.room.owner && this.room.owner != MY_USERNAME) {
            log.error(`Removing poisonRoom directive in ${this.pos.roomName}: room already owned by another player.`);
            remove = true;
        }
        if (remove) {
            this.remove(true);
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.roomPoisoner = new RoomPoisonerOverlord(this);
    }
    static roomAlreadyPoisoned(room) {
        const thingsToBlock = _.compact([room.controller, ...room.sources]);
        const neighborTiles = _.unique(_.flatten(_.map(thingsToBlock, obj => obj.pos.neighbors)), pos => packPos(pos));
        const blockPositions = _.filter(neighborTiles, pos => pos.isWalkable(true));
        return blockPositions.length == 0;
    }
    static canAutoPoison(room, allowReserved = false) {
        if (room.isColony || room.isOutpost) {
            return false;
        }
        if (!room.controller) {
            return false;
        }
        if (allowReserved && room.controller.reservation) {
            return false;
        }
        if (room.dangerousHostiles.length > 0) {
            return false;
        }
        if (_.filter(room.controller.pos.neighbors, pos => pos.isWalkable(true)).length == 0) {
            return false;
        }
        return true;
    }
    init() {
        this.alert(`Poisoning room`);
        if (this.room) {
            const thingsToBlock = _.compact([this.room.controller, ...this.room.sources]);
            const neighborTiles = _.unique(_.flatten(_.map(thingsToBlock, obj => obj.pos.neighbors)), pos => packPos(pos));
            this.blockPositions = _.filter(neighborTiles, pos => pos.isWalkable(true));
        }
        else {
            this.blockPositions = [];
        }
    }
    prePoisonActions() {
        if (this.room && this.room.controller && this.room.controller.level != 1) {
            return;
        }
        if (this.room) {
            const removeStructures = this.room.find(FIND_STRUCTURES, {
                filter: (s) => s.structureType != STRUCTURE_CONTROLLER &&
                    s.structureType != STRUCTURE_STORAGE &&
                    s.structureType != STRUCTURE_TERMINAL &&
                    s.structureType != STRUCTURE_FACTORY &&
                    s.structureType != STRUCTURE_LAB &&
                    s.structureType != STRUCTURE_NUKER
            });
            _.forEach(removeStructures, s => s.destroy());
            _.forEach(this.room.find(FIND_HOSTILE_CONSTRUCTION_SITES), csite => csite.remove());
        }
    }
    poisonActions() {
        if (!(this.room && this.room.controller && this.room.controller.level == 2)) {
            return;
        }
        const positionToBlock = _.first(this.blockPositions);
        if (!positionToBlock) {
            return;
        }
        const enoughEnergyToBuildFinalWall = _.any(this.overlords.roomPoisoner.roomPoisoners, creep => creep.carry.energy >= BUILD_POWER);
        if (this.blockPositions.length == 1 && !enoughEnergyToBuildFinalWall) {
            return;
        }
        positionToBlock.createConstructionSite(STRUCTURE_WALL);
    }
    clearRoom() {
        if (this.room) {
            const allStructures = this.room.find(FIND_STRUCTURES, {
                filter: (s) => s.structureType != STRUCTURE_CONTROLLER &&
                    s.structureType != STRUCTURE_STORAGE &&
                    s.structureType != STRUCTURE_TERMINAL &&
                    s.structureType != STRUCTURE_FACTORY &&
                    s.structureType != STRUCTURE_LAB &&
                    s.structureType != STRUCTURE_NUKER
            });
            _.forEach(allStructures, s => s.destroy());
        }
    }
    run() {
        if (this.room && this.room.controller && Game.time % DirectivePoisonRoom_1.settings.runFrequency == 0) {
            if (this.room.controller.reservation && this.room.controller.reservation.ticksToEnd > 500) {
                DirectiveControllerAttack.createIfNotPresent(this.room.controller.pos, 'room');
            }
            if (this.room.playerHostiles.length > 0) {
                DirectiveOutpostDefense.createIfNotPresent(this.room.controller.pos, 'room');
            }
        }
        if (this.room && this.room.controller && this.room.controller.my) {
            if (Game.time % DirectivePoisonRoom_1.settings.runFrequency == 0 || this.room.constructionSites.length == 0) {
                if (this.room.controller.level == 1) {
                    this.prePoisonActions();
                    return;
                }
                if (this.room.controller.level == 2) {
                    if (this.blockPositions.length > 0) {
                        this.poisonActions();
                    }
                    else {
                        this.room.controller.unclaim();
                        log.notify(`Removing poisonRoom directive in ${this.pos.roomName}: operation completed.`);
                        this.remove();
                    }
                }
            }
        }
    }
};
DirectivePoisonRoom.directiveName = 'poisonRoom';
DirectivePoisonRoom.color = COLOR_PURPLE;
DirectivePoisonRoom.secondaryColor = COLOR_RED;
DirectivePoisonRoom.requiredRCL = 5;
DirectivePoisonRoom.settings = {
    runFrequency: 12,
};
DirectivePoisonRoom = DirectivePoisonRoom_1 = __decorate([
    profile
], DirectivePoisonRoom);

let DirectiveTargetSiege = class DirectiveTargetSiege extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    getTarget() {
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {
    }
    run() {
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'orange' });
    }
};
DirectiveTargetSiege.directiveName = 'target:siege';
DirectiveTargetSiege.color = COLOR_GREY;
DirectiveTargetSiege.secondaryColor = COLOR_ORANGE;
DirectiveTargetSiege = __decorate([
    profile
], DirectiveTargetSiege);

var PairDestroyerOverlord_1;
let PairDestroyerOverlord = PairDestroyerOverlord_1 = class PairDestroyerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'destroy', priority);
        this.directive = directive;
        this.attackers = this.combatZerg(Roles.melee, { notifyWhenAttacked: false });
        this.healers = this.combatZerg(Roles.healer, { notifyWhenAttacked: false });
    }
    findTarget(attacker) {
        if (this.room) {
            const targetingDirectives = DirectiveTargetSiege.find(this.room.flags);
            const targetedStructures = _.compact(_.map(targetingDirectives, directive => directive.getTarget()));
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(attacker.pos, targetedStructures);
            }
            else {
                const creepTarget = CombatTargeting.findClosestHostile(attacker, {
                    checkReachable: true,
                    ignoreCreepsAtEdge: true,
                    playerOnly: false,
                    onlyUnramparted: true
                });
                if (creepTarget)
                    return creepTarget;
                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(attacker);
                if (structureTarget)
                    return structureTarget;
            }
        }
    }
    attackActions(attacker, healer) {
        const target = this.findTarget(attacker);
        if (target) {
            if (attacker.pos.isNearTo(target)) {
                attacker.attack(target);
            }
            else {
                Movement.pairwiseMove(attacker, healer, target);
                attacker.autoMelee();
            }
        }
    }
    handleSquad(attacker) {
        const healer = attacker.findPartner(this.healers);
        if (!healer || healer.spawning || healer.needsBoosts) {
            if (attacker.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {
                attacker.goTo(this.colony.controller, { range: 5 });
            }
            else {
                attacker.park();
            }
        }
        else {
            if (attacker.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent) ||
                healer.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent)) {
                Movement.pairwiseMove(healer, attacker, CombatIntel.getFallbackFrom(this.directive.pos));
            }
            else {
                if (!attacker.inSameRoomAs(this)) {
                    Movement.pairwiseMove(attacker, healer, this.pos);
                }
                else {
                    this.attackActions(attacker, healer);
                }
            }
        }
    }
    handleHealer(healer) {
        var towersAvaliable = (healer.inFriendlyRoom && healer.towersAvaliable(healer.getCurrentColony()));
        if (CombatIntel.isHealer(healer) && healer.getActiveBodyparts(HEAL) == 0 && !towersAvaliable) {
            if (this.colony.towers.length > 0) {
                healer.goToRoom(this.colony.room.name);
            }
            else {
                healer.suicide();
            }
        }
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            healer.doMedicActions(this.room.name);
            return;
        }
        const attacker = healer.findPartner(this.attackers);
        if (!attacker || attacker.spawning || attacker.needsBoosts) {
            if (healer.hits < healer.hitsMax) {
                healer.heal(healer);
            }
            if (healer.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {
                healer.goTo(this.colony.controller, { range: 5 });
            }
            else {
                healer.park();
            }
        }
        else {
            if (attacker.hitsMax - attacker.hits > healer.hitsMax - healer.hits) {
                healer.heal(attacker);
            }
            else {
                healer.heal(healer);
            }
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        }
        else {
            amount = 1;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            amount = 0;
        }
        const attackerPriority = this.attackers.length < this.healers.length ? this.priority - 0.1 : this.priority + 0.1;
        const attackerSetup = CombatSetups.zerglings.boosted.armored;
        this.wishlist(amount, attackerSetup, { priority: attackerPriority });
        const healerPriority = this.healers.length < this.attackers.length ? this.priority - 0.1 : this.priority + 0.1;
        const healerSetup = CombatSetups.transfusers.boosted.default;
        this.wishlist(amount, healerSetup, { priority: healerPriority });
    }
    run() {
        this.reassignIdleCreeps(Roles.healer);
        this.reassignIdleCreeps(Roles.melee);
        for (const attacker of this.attackers) {
            if (attacker.hasValidTask) {
                attacker.run();
            }
            else {
                if (attacker.needsBoosts) {
                    this.handleBoosting(attacker);
                }
                else {
                    this.handleSquad(attacker);
                }
            }
        }
        for (const healer of this.healers) {
            if (healer.hasValidTask) {
                healer.run();
            }
            else {
                if (healer.needsBoosts) {
                    this.handleBoosting(healer);
                }
                else {
                    this.handleHealer(healer);
                }
            }
        }
    }
};
PairDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
PairDestroyerOverlord = PairDestroyerOverlord_1 = __decorate([
    profile
], PairDestroyerOverlord);

let DirectivePairDestroy = class DirectivePairDestroy extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new PairDestroyerOverlord(this);
    }
    init() {
        this.alert(`Pair destroyer directive active`);
    }
    run() {
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            log.notify(`Pair destroyer mission at ${this.pos.roomName} completed successfully.`);
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
        const fallback = CombatIntel.getFallbackFrom(this.pos);
        Visualizer.marker(fallback, { color: 'green' });
    }
};
DirectivePairDestroy.directiveName = 'destroy';
DirectivePairDestroy.color = COLOR_RED;
DirectivePairDestroy.secondaryColor = COLOR_CYAN;
DirectivePairDestroy = __decorate([
    profile
], DirectivePairDestroy);

var DirectiveColonize_1;
let DirectiveColonize = DirectiveColonize_1 = class DirectiveColonize extends Directive {
    constructor(flag) {
        var _a, _b, _c;
        flag.memory.allowPortals = true;
        super(flag, colony => colony.level >= DirectiveColonize_1.requiredRCL
            && colony.name != Directive.getPos(flag).roomName && colony.spawns.length > 0);
        this.type = 'default';
        this.toColonize = this.room ? Overmind.colonies[Overmind.colonyMap[this.room.name]] : undefined;
        if (this.room) {
            var intel = RoomIntel.getAllRoomObjectInfo(this.room.name);
        }
        if (this.room && !!this.room.owner && this.room.owner != MY_USERNAME) {
            log.notify(`Removing Colonize directive in ${this.pos.roomName}: room already owned by another player.`);
            var scan = true;
            if (scan) {
                var intel = RoomIntel.getAllRoomObjectInfo(this.room.name);
                var spawns = (_a = intel === null || intel === void 0 ? void 0 : intel.importantStructures) === null || _a === void 0 ? void 0 : _a.spawnPositions;
                var towers = (_b = intel === null || intel === void 0 ? void 0 : intel.importantStructures) === null || _b === void 0 ? void 0 : _b.towerPositions;
                var controller = intel === null || intel === void 0 ? void 0 : intel.controller;
                var owner = controller === null || controller === void 0 ? void 0 : controller.owner;
                var safemode = (_c = intel === null || intel === void 0 ? void 0 : intel.controller) === null || _c === void 0 ? void 0 : _c.safemode;
                var safemodeActive = (safemode && safemode > 0);
                var spawnP = ((spawns === null || spawns === void 0 ? void 0 : spawns.length) && (spawns === null || spawns === void 0 ? void 0 : spawns.length) <= 0);
                var towerP = ((towers === null || towers === void 0 ? void 0 : towers.length) && (towers === null || towers === void 0 ? void 0 : towers.length) <= 0);
                var viableRoom = (spawnP && towerP && !safemode);
                if (viableRoom && (this.room.controller)) {
                    DirectiveControllerAttack.createIfNotPresent(this.room.controller.pos, 'room');
                }
                if ((this.room.controller) && this.room.playerHostiles.length > 0) {
                    DirectiveOutpostDefense.createIfNotPresent(this.room.controller.pos, 'room');
                }
                if ((this.room.controller) && this.room.dangerousPlayerHostiles.length > 0) {
                    DirectivePairDestroy.createIfNotPresent(this.room.controller.pos, 'room');
                }
            }
            this.remove(true);
        }
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller room; ` +
                `removing directive!`);
            this.remove(true);
            return;
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.pioneer = new PioneerOverlord(this);
    }
    init() {
        this.alert(`Colonization in progress`);
    }
    run(verbose = false) {
        if (this.toColonize && this.toColonize.spawns.length > 0) {
            const miningOverlords = _.map(this.toColonize.miningSites, site => site.overlords.mine);
            for (const pioneer of this.overlords.pioneer.pioneers) {
                const miningOverlord = miningOverlords.shift();
                if (miningOverlord) {
                    if (verbose) {
                        log.debug(`Reassigning: ${pioneer.print} to mine: ${miningOverlord.print}`);
                    }
                    pioneer.reassign(miningOverlord, Roles.drone);
                }
                else {
                    if (verbose) {
                        log.debug(`Reassigning: ${pioneer.print} to work: ${this.toColonize.overlords.work.print}`);
                    }
                    pioneer.reassign(this.toColonize.overlords.work, Roles.worker);
                }
            }
            this.remove();
        }
        if (Game.time % 10 == 2 && (this.room && !!this.room.owner && this.room.owner != MY_USERNAME)) {
            log.notify(`Removing Colonize directive in ${this.pos.roomName}: room already owned by another player.`);
            this.remove();
        }
    }
};
DirectiveColonize.directiveName = 'colonize';
DirectiveColonize.color = COLOR_PURPLE;
DirectiveColonize.secondaryColor = COLOR_GREY;
DirectiveColonize.requiredRCL = 3;
DirectiveColonize = DirectiveColonize_1 = __decorate([
    profile
], DirectiveColonize);

let DirectiveIncubate = class DirectiveIncubate extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 7);
        this.incubatee = this.room ? Overmind.colonies[Overmind.colonyMap[this.room.name]] : undefined;
        this.refresh();
    }
    refresh() {
        if (this.incubatee) {
            this.incubatee.state.isIncubating = true;
            this.incubatee.spawnGroup = new SpawnGroup(this.incubatee);
        }
    }
    spawnMoarOverlords() {
        if (!this.incubatee) {
            this.overlords.claim = new ClaimingOverlord(this);
        }
    }
    init() {
    }
    run() {
        if (this.incubatee) {
            if (this.incubatee.level >= 7 && this.incubatee.storage && this.incubatee.terminal) {
                this.remove();
            }
        }
    }
};
DirectiveIncubate.directiveName = 'incubate';
DirectiveIncubate.color = COLOR_PURPLE;
DirectiveIncubate.secondaryColor = COLOR_WHITE;
DirectiveIncubate = __decorate([
    profile
], DirectiveIncubate);

let GuardSwarmOverlord = class GuardSwarmOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, 'swarmGuard', priority);
        this.directive = directive;
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    findAttackTarget(guard) {
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(guard.room.hostiles, hostile => hostile.pos.rangeToEdge > 0);
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            return guard.pos.findClosestByRange(guard.room.hostileStructures);
        }
    }
    handleGuard(guard) {
        if (guard.pos.roomName != this.pos.roomName) {
            guard.goToRoom(this.pos.roomName);
        }
        else {
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                guard.attackAndChase(attackTarget);
            }
            else {
                guard.park(this.pos);
            }
        }
    }
    init() {
        if (this.directive.memory.amount) {
            this.wishlist(this.directive.memory.amount, CombatSetups.broodlings.early);
        }
        else {
            if (this.room) {
                const smallHostiles = _.filter(this.room.dangerousHostiles, creep => creep.body.length < 10);
                if (smallHostiles.length > 2) {
                    this.wishlist(Math.round(smallHostiles.length), CombatSetups.broodlings.early);
                }
            }
            else {
                this.wishlist(2, CombatSetups.broodlings.early);
            }
        }
    }
    run() {
        for (const guard of this.guards) {
            if (guard.hasValidTask) {
                guard.run();
            }
            else {
                this.handleGuard(guard);
            }
        }
    }
};
GuardSwarmOverlord = __decorate([
    profile
], GuardSwarmOverlord);

let DefenseNPCOverlord = class DefenseNPCOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, 'guard', priority);
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    findAttackTarget(guard) {
        const targetingDirectives = DirectiveTargetSiege.find(guard.room.flags);
        const targetedStructures = _.compact(_.map(targetingDirectives, directive => directive.getTarget()));
        if (targetedStructures.length > 0) {
            return guard.pos.findClosestByRange(targetedStructures);
        }
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(guard.room.hostiles, hostile => hostile.pos.rangeToEdge > 0);
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            const haulFlags = DirectiveHaul.find(guard.room.flags);
            if (haulFlags.length == 0) {
                return guard.pos.findClosestByRange(guard.room.hostileStructures);
            }
        }
    }
    combatActions(guard, target) {
        guard.attackAndChase(target);
        guard.healSelfIfPossible();
    }
    handleGuard(guard) {
        if (!guard.inSameRoomAs(this) || guard.pos.isEdge) {
            guard.goToRoom(this.pos.roomName);
        }
        else {
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                this.combatActions(guard, attackTarget);
            }
            else {
                guard.doMedicActions(this.pos.roomName);
            }
        }
    }
    init() {
        let amount = 0;
        if (!this.room && !this.colony.observer) {
            amount = 1;
        }
        if (this.room && (this.room.invaders.length > 0 || this.room.invaderCore || RoomIntel.isInvasionLikely(this.room))) {
            amount = 1;
        }
        const setup = this.colony.stage == ColonyStage.Larva ? CombatSetups.broodlings.early : CombatSetups.broodlings.default;
        this.wishlist(amount, setup, { reassignIdle: true });
    }
    run() {
        this.autoRun(this.guards, guard => this.handleGuard(guard));
    }
};
DefenseNPCOverlord.requiredRCL = 3;
DefenseNPCOverlord = __decorate([
    profile
], DefenseNPCOverlord);

let DirectiveGuard = class DirectiveGuard extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        if (this.colony.level >= DefenseNPCOverlord.requiredRCL) {
            this.overlords.guard = new DefenseNPCOverlord(this);
        }
        else {
            this.overlords.swarmGuard = new GuardSwarmOverlord(this);
        }
    }
    init() {
        if (this.room && this.room.invaderCore) {
            this.memory.invaderCore = true;
        }
        if (this.memory.invaderCore) {
            this.alert(`Attacking invader core`, NotifierPriority.Low);
        }
    }
    run() {
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            const creepsNeedingHealing = _.filter(this.room.creeps, creep => creep.hits < creep.hitsMax);
            if (creepsNeedingHealing.length == 0 && this.room.isSafe) {
                this.remove();
            }
        }
    }
};
DirectiveGuard.directiveName = 'guard';
DirectiveGuard.color = COLOR_BLUE;
DirectiveGuard.secondaryColor = COLOR_BLUE;
DirectiveGuard = __decorate([
    profile
], DirectiveGuard);

let BunkerDefenseOverlord = class BunkerDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.meleeDefense) {
        super(directive, 'bunkerDefense', priority, 1, 30);
        this.defenders = this.combatZerg(Roles.bunkerDefender);
    }
    handleDefender(lurker) {
        if (!lurker.inRampart) {
            const nearbyRampart = _.find(lurker.room.walkableRamparts, rampart => rampart.pos.getRangeTo(lurker) < 5);
            if (nearbyRampart) {
                lurker.goTo(nearbyRampart);
            }
        }
        if (lurker.room.hostiles.length > 0) {
            lurker.autoBunkerCombat(lurker.room.name);
        }
        else {
        }
    }
    init() {
        this.reassignIdleCreeps(Roles.bunkerDefender);
        this.wishlist(1, CombatSetups.bunkerDefender.boosted);
    }
    run() {
        this.autoRun(this.defenders, defender => this.handleDefender(defender));
    }
};
BunkerDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
BunkerDefenseOverlord = __decorate([
    profile
], BunkerDefenseOverlord);

var DistractionOverlord_1;
let DistractionOverlord = DistractionOverlord_1 = class DistractionOverlord extends CombatOverlord {
    constructor(directive, boosted = false, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, 'distraction', priority, 1);
        this.distractions = this.combatZerg(Roles.rangedDistractor);
    }
    handleDistraction(distraction) {
        if (this.room && this.room.hostiles.length > 0) {
            distraction.autoCombat(this.room.name, false, 5, { preferRamparts: false });
            DistractionOverlord_1.taunt(distraction, this.room.hostiles[0].owner.username);
            const nearbyHostiles = this.room.hostiles.filter(hostile => hostile.pos.getRangeTo(distraction) <= 6);
            if (nearbyHostiles.length > 0) {
                distraction.kite(nearbyHostiles);
            }
        }
    }
    static taunt(distraction, name) {
        const taunts = ['Heylisten!', 'Pssssst', 'So close', '🎣', 'Try harder', 'Get good;)', 'Base ⬆️', '🔜',
            '⚠️Swamp⚠️', 'Follow me!', 'Catch Me!', `Hi ${name || ''}`, '🍑🍑🍑', '🏎️ VROOM'];
        distraction.sayRandom(taunts, true);
    }
    init() {
        const setup = CombatSetups.distractors.ranged;
        this.wishlist(1, setup);
    }
    run() {
        this.autoRun(this.distractions, distraction => this.handleDistraction(distraction));
    }
};
DistractionOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
DistractionOverlord = DistractionOverlord_1 = __decorate([
    profile
], DistractionOverlord);

let RangedDefenseOverlord = class RangedDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, 'rangedDefense', priority, 1);
        this.hydralisks = this.combatZerg(Roles.ranged);
    }
    handleDefender(hydralisk) {
        if (this.room.hostiles.length > 0) {
            hydralisk.autoCombat(this.room.name);
        }
        else {
            if (!hydralisk.doMedicActions(this.room.name) && hydralisk.pos.getRangeTo(this.directive.pos) > 4) {
                hydralisk.goTo(this.directive.pos);
            }
        }
    }
    computeNeededAdditionalRangedPotential() {
        const healAmount = CombatIntel.maxHealingByCreeps(this.room.hostiles);
        const towerDamage = this.room.hostiles[0] ? CombatIntel.towerDamageAtPos(this.room.hostiles[0].pos) || 0 : 0;
        const worstDamageMultiplier = _.min(_.map(this.room.hostiles, creep => CombatIntel.minimumDamageTakenMultiplier(creep)));
        const hydraliskDamage = RANGED_ATTACK_POWER * CombatIntel.getMyCombatPotentials(this.hydralisks).ranged;
        const maxDamageReceived = worstDamageMultiplier * (hydraliskDamage + towerDamage + 1);
        const needAdditionalDamage = Math.max(healAmount - maxDamageReceived, 0);
        const neededRangedParts = needAdditionalDamage / RANGED_ATTACK_POWER;
        return neededRangedParts;
    }
    init() {
        if (this.reassignIdleCreeps(Roles.ranged, 1))
            return;
        let setup = CombatSetups.hydralisks.default;
        if (_.all(this.spawnGroup.colonies, col => col.room.energyCapacityAvailable < 800)) {
            setup = CombatSetups.hydralisks.noHeal;
        }
        else {
            const { attack, ranged, heal } = CombatIntel.getCombatPotentials(this.room.hostiles);
            if (attack + ranged + heal > 100 || this.age > 1000) {
                setup = CombatSetups.hydralisks.boosted.default;
            }
        }
        const neededAdditionalRangedPotential = this.computeNeededAdditionalRangedPotential();
        if (neededAdditionalRangedPotential) {
            this.requestCreep(setup);
        }
    }
    run() {
        this.autoRun(this.hydralisks, hydralisk => this.handleDefender(hydralisk));
    }
};
RangedDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
RangedDefenseOverlord = __decorate([
    profile
], RangedDefenseOverlord);

let DirectiveInvasionDefense = class DirectiveInvasionDefense extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 1 && colony.spawns.length > 0);
    }
    spawnMoarOverlords() {
        if (!this.room) {
            return;
        }
        const expectedDamage = CombatIntel.maxDamageByCreeps(this.room.dangerousPlayerHostiles);
        const expectedHealing = CombatIntel.maxHealingByCreeps(this.room.dangerousPlayerHostiles);
        const useBoosts = (expectedDamage > ATTACK_POWER * 50) || (expectedHealing > RANGED_ATTACK_POWER * 100)
            && !!this.colony.terminal
            && !!this.colony.evolutionChamber;
        const percentWalls = _.filter(this.room.barriers, s => s.structureType == STRUCTURE_WALL).length /
            this.room.barriers.length;
        const meleeHostiles = _.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(ATTACK) > 0 ||
            hostile.getActiveBodyparts(WORK) > 0);
        const rangedHostiles = _.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(RANGED_ATTACK) > 0);
        this.overlords.rangedDefense = new RangedDefenseOverlord(this);
        if (meleeHostiles.length > 0 && expectedDamage > ATTACK_POWER * 70 &&
            (this.colony.level >= BarrierPlanner.settings.bunkerizeRCL || rangedHostiles.length > 3)) {
            this.overlords.bunkerDefense = new BunkerDefenseOverlord(this);
        }
        if (meleeHostiles.length > 0 && expectedDamage > 40 * ATTACK_POWER) {
            this.overlords.distraction = new DistractionOverlord(this);
        }
    }
    init() {
        const numHostiles = this.room ? this.room.hostiles.length.toString() : '???';
        this.alert(`Invasion (hostiles: ${numHostiles}) ${Game.time - this.memory.safeSince}`, NotifierPriority.Critical);
    }
    recordBaddies() {
        if (!this.room) {
            return;
        }
        const mem = Memory.playerCreepTracker;
        const hostiles = this.room.hostiles;
        hostiles.forEach(creep => {
            if (!mem[creep.owner.username]) {
                mem[creep.owner.username] = {
                    creeps: {},
                    types: {},
                    parts: {},
                    boosts: {},
                };
            }
            const playerMem = mem[creep.owner.username];
            if (!playerMem.creeps[creep.name]) {
                playerMem.creeps[creep.name] = Game.time;
                const creepType = creep.name.substr(0, creep.name.indexOf(' '));
                if (creepType == creep.name) {
                    return;
                }
                playerMem.types[creepType] = (playerMem.types[creepType] + 1) || 1;
                for (const bodyPart of creep.body) {
                    playerMem.parts[bodyPart.type] = (playerMem.parts[bodyPart.type]) + 1 || 1;
                    if (bodyPart.boost) {
                        playerMem.boosts[bodyPart.boost] = (playerMem.boosts[bodyPart.boost]) + 1 || 1;
                    }
                }
            }
        });
    }
    printPlayerExpenditure() {
        let t3Count = 0;
        let energyCount = 0;
        const mem = Memory.playerCreepTracker.inakrin;
        for (const boostid in mem.boosts) {
            const boost = mem.boosts[boostid];
            console.log(`${boostid} : ${boost * 30}`);
            t3Count += boost * 30;
            energyCount += 20;
        }
        for (const partType in mem.parts) {
            const partCount = mem.parts[partType];
            const cost = BODYPART_COST[partType];
            console.log(`${partType} : ${cost * partCount}`);
            energyCount += cost * partCount;
        }
        console.log(`Total T3 Cost: ${t3Count}`);
        console.log(`Total Energy Cost: ${energyCount}`);
    }
    cleanUpPlayerMem() {
        const mem = Memory.playerCreepTracker;
        for (const player of _.keys(mem)) {
            const tracker = mem[player];
            for (const creep of _.keys(tracker.creeps)) {
                if (tracker.creeps[creep] + 1500 < Game.time) {
                    delete tracker.creeps[creep];
                }
            }
        }
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
            this.recordBaddies();
        }
        if (Game.time % 5000 == 0) {
            this.cleanUpPlayerMem();
        }
        if (this.room && false) {
        }
        if (this.room && this.room.hostiles.length == 0 &&
            (Game.time - this.memory.safeSince) > this.safeEndTime) {
            if (_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax).length == 0) {
                this.remove();
            }
        }
        else if ((Game.time - this.memory.safeSince) > 3000) {
            this.remove();
        }
    }
};
DirectiveInvasionDefense.directiveName = 'invasionDefense';
DirectiveInvasionDefense.color = COLOR_BLUE;
DirectiveInvasionDefense.secondaryColor = COLOR_PURPLE;
DirectiveInvasionDefense = __decorate([
    profile
], DirectiveInvasionDefense);

let DirectiveDrop = class DirectiveDrop extends Directive {
    constructor(flag, pileAmount = 2000) {
        super(flag);
        this.memory.amount = pileAmount;
    }
    spawnMoarOverlords() {
    }
    get targetedBy() {
        return Overmind.cache.targets[this.ref];
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops) {
            const drops = (this.pos.lookFor(LOOK_RESOURCES) || []);
            this._drops = _.groupBy(drops, drop => drop.resourceType);
        }
        return this._drops;
    }
    get store() {
        if (!this._store) {
            const store = { energy: 0 };
            for (const resourceType of _.keys(this.drops)) {
                const totalResourceAmount = _.sum(this.drops[resourceType], drop => drop.amount);
                if (store[resourceType]) {
                    store[resourceType] += totalResourceAmount;
                }
                else {
                    store[resourceType] = totalResourceAmount;
                }
            }
            this._store = store;
        }
        return this._store;
    }
    refresh() {
        super.refresh();
        this._store = undefined;
    }
    registerEnergyRequests() {
        const threshold = 0.75;
        if (this.store.energy < threshold * this.memory.amount) {
            this.colony.logisticsNetwork.requestInput(this);
        }
    }
    init() {
        this.registerEnergyRequests();
        this.alert(`Drop directive active - ${_.sum(this.store)}`);
    }
    run() {
        const storagePos = this.colony.roomPlanner.storagePos;
        const upgradePos = this.colony.upgradeSite.batteryPos;
        if (storagePos && this.pos.isEqualTo(storagePos)) {
            if (this.colony.hatchery && this.colony.hatchery.batteries.length > 0) {
                this.remove();
            }
        }
        else if (upgradePos && this.pos.isEqualTo(upgradePos)) {
            if (this.colony.upgradeSite.battery) {
                this.remove();
            }
        }
        else {
            log.error('Drop directive placed on invalid location; removing!');
            this.remove();
        }
    }
};
DirectiveDrop.directiveName = 'haul';
DirectiveDrop.color = COLOR_GREEN;
DirectiveDrop.secondaryColor = COLOR_GREEN;
DirectiveDrop = __decorate([
    profile
], DirectiveDrop);

var HarassOverlord_1;
let HarassOverlord = HarassOverlord_1 = class HarassOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostOffense.harass) {
        super(directive, 'harass', priority, 1);
        this.directive = directive;
        this.nibblers = this.combatZerg(Roles.melee);
        this.hydralisks = this.combatZerg(Roles.ranged);
    }
    handleHarass(hydralisk) {
        hydralisk.autoCombat(this.targetRemoteToHarass || hydralisk.room.name);
        if (!this.targetRemoteToHarass) {
            this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
        }
        if (this.targetRemoteToHarass && hydralisk.room.name != this.targetRemoteToHarass) {
            hydralisk.goToRoom(this.targetRemoteToHarass);
        }
        else if (hydralisk.room.dangerousHostiles.length > 2) {
            hydralisk.room.dangerousHostiles.forEach(hostile => {
                const nextSafeSpawn = (Game.time - HarassOverlord_1.settings.prespawn + (hostile.ticksToLive || 0));
                if (nextSafeSpawn > this.directive.memory.nextSpawnTime) {
                    this.directive.memory.nextSpawnTime = nextSafeSpawn;
                }
            });
            if (hydralisk.room.name != this.targetRemoteToHarass) {
                hydralisk.goToRoom(this.targetRemoteToHarass);
            }
            else {
                const nextRoom = this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
                if (nextRoom) {
                    hydralisk.goToRoom(this.targetRemoteToHarass);
                }
            }
        }
    }
    chooseRemoteToHarass(hydralisk, currentRoom) {
        if (!this.directive.memory.roomsToHarass || this.directive.memory.roomsToHarass.length == 0) {
            this.directive.memory.roomsToHarass = this.directive.findNearbyReservedRoomsForHarassment();
        }
        const nextRoom = this.directive.memory.roomsToHarass.shift();
        if (nextRoom) {
            this.directive.memory.roomsToHarass.push(nextRoom);
            this.targetRemoteToHarass = nextRoom;
            log.debug(`Selecting new target of ${this.targetRemoteToHarass} for ${hydralisk.print} from ` +
                `${this.directive.memory.roomsToHarass}`);
            hydralisk.say(`Tgt ${this.targetRemoteToHarass}`);
            return nextRoom;
        }
    }
    init() {
        this.reassignIdleCreeps(Roles.ranged);
        this.reassignIdleCreeps(Roles.melee);
        const setup = CombatSetups.hydralisks.default;
        const numtoSpawn = (!this.directive.memory.nextSpawnTime || Game.time >= this.directive.memory.nextSpawnTime) ? 1 : 0;
        this.wishlist(numtoSpawn, setup);
    }
    run() {
        this.autoRun(this.hydralisks, hydralisk => this.handleHarass(hydralisk));
        this.autoRun(this.nibblers, hydralisk => this.handleHarass(hydralisk));
    }
};
HarassOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
    prespawn: 200,
};
HarassOverlord = HarassOverlord_1 = __decorate([
    profile
], HarassOverlord);

let DirectiveHarass = class DirectiveHarass extends Directive {
    constructor(flag) {
        super(flag);
        this.memory.targetPlayer = RoomIntel.roomOwnedBy(flag.pos.roomName);
        this.memory.nextSpawnTime = Game.time;
        if (this.memory.targetPlayer == MY_USERNAME) {
            log.error(`Ahhhhhh harassing self in room ${flag.pos.roomName}`);
            this.remove();
        }
        else {
            log.alert(`Starting harass on ${flag.pos.roomName} owned by ${this.memory.targetPlayer}`);
        }
        if (this.memory.targetPlayer) {
            this.memory.roomsToHarass = this.findNearbyReservedRooms(flag.pos.roomName, this.memory.targetPlayer);
        }
    }
    spawnMoarOverlords() {
        this.overlords.harassOverlord = new HarassOverlord(this);
    }
    init() {
    }
    findNearbyReservedRoomsForHarassment() {
        if (this.memory.targetPlayer) {
            return this.findNearbyReservedRooms(this.flag.pos.roomName, this.memory.targetPlayer);
        }
        return [];
    }
    findNearbyReservedRooms(roomName, playerName) {
        if (!this.memory.targetPlayer) {
            log.error(`Unable to find which player to harass in room ${roomName}`);
            return [];
        }
        const whitelist = Memory.settings.allies;
        const reservedByTargetPlayer = [];
        const adjacentRooms = _.values(Game.map.describeExits(roomName));
        adjacentRooms.forEach(room => {
            const reservation = RoomIntel.roomReservedBy(room);
            console.log('Checking for harass in room ' + room);
            if (reservation && this.memory.aggressive ? !whitelist.includes(reservation) : reservation == playerName) {
                reservedByTargetPlayer.push(room);
                _.values(Game.map.describeExits(room)).forEach(room => {
                    if (RoomIntel.roomReservedBy(room) == playerName) {
                        reservedByTargetPlayer.push(room);
                    }
                });
            }
        });
        Game.notify(`Looking for nearby rooms to harass, found ${reservedByTargetPlayer}`);
        return reservedByTargetPlayer;
    }
    run() {
    }
};
DirectiveHarass.directiveName = 'harass';
DirectiveHarass.color = COLOR_RED;
DirectiveHarass.secondaryColor = COLOR_WHITE;
DirectiveHarass = __decorate([
    profile
], DirectiveHarass);

let SwarmOverlord = class SwarmOverlord extends CombatOverlord {
    swarmWishlist(swarmQuantity, config) {
        const creepQuantities = {};
        const neededQuantities = {};
        const validSwarms = _.filter(this.swarms, swarm => !swarm.isExpired);
        for (const swarm of validSwarms) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                const existingCreepsOfRole = _.filter(swarm.creeps, creep => creep.roleName == setup.role);
                if (!creepQuantities[setup.role])
                    creepQuantities[setup.role] = 0;
                creepQuantities[setup.role] += existingCreepsOfRole.length;
                if (!neededQuantities[setup.role])
                    neededQuantities[setup.role] = 0;
                neededQuantities[setup.role] += amount;
                const spawnQuantity = amount - existingCreepsOfRole.length;
                for (let i = 0; i < spawnQuantity; i++) {
                    this.requestCreep(setup, { priority: priority });
                }
            }
        }
        const numRemainingSwarms = swarmQuantity - validSwarms.length;
        for (let n = 0; n < numRemainingSwarms; n++) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                if (!neededQuantities[setup.role])
                    neededQuantities[setup.role] = 0;
                neededQuantities[setup.role] += amount;
                for (let i = 0; i < amount; i++) {
                    this.requestCreep(setup, { priority: priority + 0.5 });
                }
            }
        }
        for (const role of _.keys(neededQuantities)) {
            this.creepReport(role, creepQuantities[role] || 0, neededQuantities[role]);
        }
    }
};
SwarmOverlord = __decorate([
    profile
], SwarmOverlord);

const DEBUG = false;
let SwarmDestroyerOverlord = class SwarmDestroyerOverlord extends SwarmOverlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'destroy', priority, 8);
        this.directive = directive;
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.intel = new CombatIntel(this.directive);
        this.zerglings = this.combatZerg(Roles.melee, { notifyWhenAttacked: false });
        this.healers = this.combatZerg(Roles.healer, { notifyWhenAttacked: false });
        this.makeSwarms();
        this.fallback = $.pos(this, 'fallback', () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }), 200);
        this.assemblyPoints = [];
        for (let i = 0; i < _.keys(this.swarms).length + 1; i++) {
            this.assemblyPoints.push($.pos(this, `assemble_${i}`, () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }, i + 1), 200));
        }
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.makeSwarms();
    }
    makeSwarms() {
        this.swarms = {};
        const meleeZerg = [...this.zerglings, ...this.healers];
        const maxPerSwarm = { [Roles.melee]: 2, [Roles.healer]: 2, [Roles.ranged]: 4 };
        const meleeZergBySwarm = _.groupBy(meleeZerg, zerg => zerg.findSwarm(meleeZerg, maxPerSwarm));
        for (const ref in meleeZergBySwarm) {
            if (ref != undefined) {
                if (DEBUG)
                    log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);
                this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
            }
        }
    }
    handleSwarm(swarm, index, waypoint = this.directive.pos) {
        if (!swarm.memory.initialAssembly) {
            const assemblyPoint = this.assemblyPoints[index] || this.fallback;
            log.debug(`Assmbling at ${assemblyPoint.print}`);
            swarm.memory.initialAssembly = swarm.assemble(assemblyPoint);
            return;
        }
        const room = swarm.rooms[0];
        if (!room) {
            log.warning(`${this.print} No room! (Why?)`);
        }
        const nearbyHostiles = _.filter(room.hostiles, creep => swarm.minRangeTo(creep) <= 3 + 1);
        const attack = _.sum(nearbyHostiles, creep => CombatIntel.getAttackDamage(creep));
        const rangedAttack = _.sum(nearbyHostiles, creep => CombatIntel.getRangedAttackDamage(creep));
        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(_.map(swarm.creeps, c => c.creep));
        const canPopShield = (attack + rangedAttack + CombatIntel.towerDamageAtPos(swarm.anchor)) * myDamageMultiplier
            > _.min(_.map(swarm.creeps, creep => 100 * creep.getActiveBodyparts(TOUGH)));
        if (canPopShield || room.hostileStructures.length == 0 || _.values(this.swarms).length > 1) {
            swarm.autoCombat(this.pos.roomName, waypoint);
        }
        else {
            swarm.autoSiege(this.pos.roomName, waypoint);
        }
    }
    init() {
        let numSwarms = this.directive.memory.amount || 1;
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            numSwarms = 0;
        }
        const zerglingPriority = this.zerglings.length <= this.healers.length ? this.priority - 0.1 : this.priority + 0.1;
        const zerglingSetup = CombatSetups.zerglings.boosted.armored;
        const healerPriority = this.healers.length < this.zerglings.length ? this.priority - 0.1 : this.priority + 0.1;
        const healerSetup = CombatSetups.transfusers.boosted.armored;
        const hydraliskPriority = this.healers.length < this.zerglings.length ? this.priority - 0.1 : this.priority + 0.1;
        const hydraliskSetup = CombatSetups.hydralisks.boosted.armored;
        const swarmConfig = [{ setup: zerglingSetup, amount: 2, priority: zerglingPriority },
            { setup: healerSetup, amount: 2, priority: healerPriority }];
        this.swarmWishlist(numSwarms, swarmConfig);
    }
    run() {
        this.autoRun(this.zerglings, zergling => undefined);
        this.autoRun(this.healers, healer => undefined);
        const refs = _.keys(this.swarms).sort();
        let i = 0;
        for (const ref of refs) {
            this.handleSwarm(this.swarms[ref], i);
            i++;
        }
    }
    visuals() {
        Visualizer.marker(this.fallback, { color: 'green' });
        for (const ref in this.swarms) {
            const swarm = this.swarms[ref];
            Visualizer.marker(swarm.anchor, { color: 'blue' });
            if (swarm.target) {
                Visualizer.marker(swarm.target.pos, { color: 'orange' });
            }
        }
    }
};
SwarmDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
SwarmDestroyerOverlord = __decorate([
    profile
], SwarmDestroyerOverlord);

var DirectiveSwarmDestroy_1;
let DirectiveSwarmDestroy = DirectiveSwarmDestroy_1 = class DirectiveSwarmDestroy extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= DirectiveSwarmDestroy_1.requiredRCL);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new SwarmDestroyerOverlord(this);
    }
    init() {
        this.alert(`Swarm destroyer directive active`);
    }
    run() {
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            log.notify(`Swarm destroyer mission at ${this.pos.roomName} completed successfully.`);
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
};
DirectiveSwarmDestroy.directiveName = 'destroy';
DirectiveSwarmDestroy.color = COLOR_RED;
DirectiveSwarmDestroy.secondaryColor = COLOR_RED;
DirectiveSwarmDestroy.requiredRCL = 6;
DirectiveSwarmDestroy = DirectiveSwarmDestroy_1 = __decorate([
    profile
], DirectiveSwarmDestroy);

let Power = class Power {
    constructor(powerCreep, target) {
        this._powerCreep = {
            name: powerCreep.name,
        };
        if (target) {
            this._target = {
                ref: target.ref,
                _pos: target.pos,
            };
        }
    }
    get target() {
        return deref(this._target.ref);
    }
    canRunPower() {
        const power = this.powerCreep.powers[powerId$1];
        return power && power.level > 0 && power.cooldown == 0;
    }
    get powerCreep() {
        return Game.powerCreeps[this._powerCreep.name];
    }
    set powerCreep(pc) {
        this._powerCreep.name = pc.name;
    }
    run() {
        if (this.canRunPower()) {
            this.operatePower();
        }
    }
    operatePower() {
    }
};
Power = __decorate([
    profile
], Power);

const powerId$1 = PWR_GENERATE_OPS;
let GenerateOps = class GenerateOps extends Power {
    constructor(powerCreep, target) {
        super(powerCreep, target);
    }
    operatePower() {
        if (this.powerCreep.carry.ops && this.powerCreep.carry.ops > (this.powerCreep.carryCapacity * 0.9)) {
            const storage = this.powerCreep.room.storage;
            if (!storage) {
                log.error(`Ops power creep with no storage`);
            }
            else {
                this.powerCreep.moveTo(storage);
                this.powerCreep.transfer(storage, RESOURCE_OPS, this.powerCreep.carry.ops);
            }
        }
        else {
            return this.powerCreep.usePower(powerId$1);
        }
        return ERR_TIRED;
    }
};
GenerateOps = __decorate([
    profile
], GenerateOps);

const powerId = PWR_OPERATE_EXTENSION;
let OperateExtension = class OperateExtension extends Power {
    constructor(powerCreep, target) {
        super(powerCreep, target);
    }
    operatePower() {
        if (this.powerCreep.carry.ops && this.powerCreep.carry.ops > 2 && this.powerCreep.room
            && this.powerCreep.room.energyAvailable < this.powerCreep.room.energyCapacityAvailable * 0.5) {
            const terminal = this.powerCreep.room.storage;
            if (!terminal) {
                log.error(`Ops power creep with no storage`);
            }
            else {
                this.powerCreep.moveTo(terminal);
                return this.powerCreep.usePower(powerId, terminal);
            }
        }
        return ERR_TIRED;
    }
};
OperateExtension = __decorate([
    profile
], OperateExtension);

var types;
(function (types) {
    types[types["opgen"] = 0] = "opgen";
    types[types["baseoperator"] = 1] = "baseoperator";
    types[types["basedefender"] = 2] = "basedefender";
})(types || (types = {}));
let DirectiveBaseOperator = class DirectiveBaseOperator extends Directive {
    constructor(flag) {
        super(flag);
        this.defaultPowerPriorities = [
            PWR_GENERATE_OPS,
            PWR_REGEN_SOURCE,
            PWR_OPERATE_TOWER,
            PWR_OPERATE_STORAGE,
            PWR_OPERATE_LAB,
            PWR_OPERATE_SPAWN,
            PWR_OPERATE_EXTENSION,
            PWR_REGEN_MINERAL
        ];
        const powerCreep = Game.powerCreeps[flag.name];
        if (!powerCreep) {
            log.error(`Power Creep not found for ${this.print}, deleting directive`);
            this.remove();
        }
        this.memory.powerPriorities = this.memory.powerPriorities || this.defaultPowerPriorities;
    }
    spawnMoarOverlords() {
    }
    init() {
    }
    renew(powerCreep, powerSource) {
        if (powerCreep.pos.inRangeToPos(powerSource.pos, 1)) {
            return powerCreep.renew(powerSource);
        }
        else {
            return powerCreep.moveTo(powerSource, {
                ignoreRoads: true, range: 1, swampCost: 1, reusePath: 0,
                visualizePathStyle: { lineStyle: 'dashed', fill: 'yellow' }
            });
        }
    }
    enablePower(powerCreep, controller) {
        log.alert(`Trying to enable power for ${controller} with `);
        if (powerCreep.pos.inRangeToPos(controller.pos, 1)) {
            return powerCreep.enableRoom(controller);
        }
        else {
            return powerCreep.moveTo(controller.pos, {
                ignoreRoads: true, range: 1, swampCost: 1,
                reusePath: 0, visualizePathStyle: { lineStyle: 'solid' }
            });
        }
    }
    usePower(powerCreep, power) {
        switch (power) {
            case PWR_GENERATE_OPS:
                return new GenerateOps(powerCreep);
            case PWR_OPERATE_EXTENSION:
                return new OperateExtension(powerCreep);
        }
    }
    runPowers(powerCreep) {
        const priorities = this.memory.powerPriorities;
        for (const powerId in priorities) {
            const powerToUse = this.usePower(powerCreep, priorities[powerId]);
            if (powerToUse && powerToUse.operatePower()) {
                break;
            }
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
    run() {
        const powerCreep = Game.powerCreeps[this.flag.name];
        if (!powerCreep || Game.cpu.bucket < 5000 && (!powerCreep.ticksToLive || powerCreep.ticksToLive > 500)) {
            this.powerCreepName = this.flag.name;
            return;
        }
        if (powerCreep.name == 'BaseDefender' && powerCreep.room && powerCreep.room.terminal) {
            powerCreep.usePower(PWR_OPERATE_TERMINAL, powerCreep.room.terminal);
        }
        const isStationary = powerCreep.name.toLowerCase().indexOf(types.basedefender.toString());
        if (powerCreep.name == 'activate') {
            console.log('Power creep move is ' + JSON.stringify(powerCreep.memory));
        }
        if (!this.room) {
            return;
        }
        else if (!powerCreep.ticksToLive && this.room && this.room.powerSpawn) {
            const res = powerCreep.spawn(this.room.powerSpawn);
            log.alert(`Running ${powerCreep} with spawn of ${res}`);
        }
        else if (this.room.controller && !this.room.controller.isPowerEnabled) {
            const res = this.enablePower(powerCreep, this.room.controller);
            log.alert(`Running ${powerCreep} with enable power of ${res}`);
        }
        else if (powerCreep && powerCreep.ticksToLive && powerCreep.ticksToLive < 900 && this.room.powerSpawn) {
            const res = this.renew(powerCreep, this.room.powerSpawn);
            log.alert(`Running ${powerCreep} with renew of ${res}`);
        }
        else {
            const res = this.runPowers(powerCreep);
        }
        if (this.room.hostiles.length > 2 || (powerCreep.pos && DirectiveNukeResponse.isPresent(powerCreep.pos.roomName))) {
            const towersToBoost = this.colony.towers.filter(tower => !tower.effects || tower.effects.length == 0);
            if (towersToBoost.length > 0) {
                powerCreep.usePower(PWR_OPERATE_TOWER, towersToBoost[0]);
            }
            if ((!powerCreep.carry.ops || powerCreep.carry.ops < 20) && this.room.storage && this.room.storage.store.ops
                && this.room.storage.store.ops > 100) {
                powerCreep.withdraw(this.room.storage, RESOURCE_OPS, 100);
            }
        }
    }
};
DirectiveBaseOperator.directiveName = 'BaseOperator';
DirectiveBaseOperator.color = COLOR_CYAN;
DirectiveBaseOperator.secondaryColor = COLOR_PURPLE;
DirectiveBaseOperator = __decorate([
    profile
], DirectiveBaseOperator);

var ExtractorOverlord_1;
const BUILD_OUTPUT_FREQUENCY$1 = 15;
let ExtractorOverlord = ExtractorOverlord_1 = class ExtractorOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, 'mineral', priority);
        this.directive = directive;
        this.priority += this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.drones = this.zerg(Roles.drone);
        this.populateStructures();
    }
    shouldHaveContainer() {
        return this.mineral && (this.mineral.mineralAmount > 0 || (this.mineral.ticksToRegeneration || 0) < 2000);
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.extractor = this.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            this.mineral = this.pos.lookFor(LOOK_MINERALS)[0];
            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);
        }
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            this.populateStructures();
        }
        super.refresh();
        $.refresh(this, 'extractor', 'mineral', 'container');
    }
    registerOutputRequests() {
        var _a, _b, _c;
        if (!this.container)
            return;
        const exhausted = ((_a = this.mineral) === null || _a === void 0 ? void 0 : _a.mineralAmount) === 0
            && ((_c = (_b = this.mineral) === null || _b === void 0 ? void 0 : _b.ticksToRegeneration) !== null && _c !== void 0 ? _c : 0) > 0;
        const outputThreshold = this.drones.length == 0 ? this.container.store.getCapacity() : 0;
        if (this.container.store.getUsedCapacity() > outputThreshold ||
            exhausted && this.container.store.getUsedCapacity() > 0) {
            this.colony.logisticsNetwork.requestOutput(this.container, { resourceType: 'all' });
        }
    }
    calculateContainerPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, pos => pos.getRangeTo(this) == 1);
            if (pos)
                return pos;
        }
        log.warning(`Last resort container position calculation for ${this.print}!`);
        return _.first(this.pos.availableNeighbors(true));
    }
    buildOutputIfNeeded() {
        if (!this.container && this.shouldHaveContainer()) {
            const containerSite = _.first(_.filter(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2), site => site.structureType == STRUCTURE_CONTAINER));
            if (!containerSite) {
                const containerPos = this.calculateContainerPos();
                log.info(`${this.print}: building container at ${containerPos.print}`);
                const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);
                if (result != OK) {
                    log.error(`${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`);
                }
                return;
            }
        }
    }
    init() {
        this.registerOutputRequests();
        const amount = this.mineral && this.mineral.mineralAmount > 0 && this.extractor && this.container
            ? Math.min(this.mineral.pos.availableNeighbors().length, ExtractorOverlord_1.settings.maxDrones)
            : 0;
        this.wishlist(amount, Setups.drones.extractor);
    }
    handleDrone(drone) {
        var _a;
        if (drone.avoidDanger({ timer: 10, dropEnergy: true })) {
            return;
        }
        if (drone.room == this.room && !drone.pos.isEdge) {
            if (this.mineral && !drone.pos.inRangeToPos(this.mineral.pos, 1)) {
                return drone.goTo(this.mineral.pos);
            }
            if (this.mineral) {
                if (((_a = this.extractor) === null || _a === void 0 ? void 0 : _a.cooldown) == 0) {
                    const ret = drone.harvest(this.mineral);
                    if (ret == ERR_NOT_IN_RANGE) {
                        return drone.goTo(this.mineral);
                    }
                }
                if (this.container) {
                    if (drone.store.getUsedCapacity() > 0.9 * drone.store.getCapacity()) {
                        const transfer = drone.transferAll(this.container);
                        if (transfer == ERR_NOT_IN_RANGE) {
                            return drone.goTo(this.container, { range: 1 });
                        }
                    }
                    if (this.drones.length == 1 && !drone.pos.isEqualTo(this.container.pos)) {
                        return drone.goTo(this.container, { range: 0 });
                    }
                }
            }
            else {
                log.error(`${this.print}: room defined and no mineral! (Why?)`);
            }
        }
        else {
            drone.goTo(this);
        }
    }
    run() {
        _.forEach(this.drones, drone => this.handleDrone(drone));
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY$1 == 2) {
            this.buildOutputIfNeeded();
        }
    }
};
ExtractorOverlord.settings = {
    maxDrones: 2,
};
ExtractorOverlord = ExtractorOverlord_1 = __decorate([
    profile
], ExtractorOverlord);

let DirectiveExtract = class DirectiveExtract extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        let priority;
        if (this.room && this.room.my) {
            if (this.colony.level == 8) {
                priority = OverlordPriority.ownedRoom.mineralRCL8;
            }
            else {
                priority = OverlordPriority.ownedRoom.mineral;
            }
        }
        else {
            priority = OverlordPriority.remoteSKRoom.mineral;
        }
        this.overlords.extract = new ExtractorOverlord(this, priority);
    }
    init() {
        var _a, _b;
        const extractPos = (_b = (_a = this.overlords.extract.container) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.pos;
        this.colony.destinations.push({ pos: extractPos, order: this.memory["T"] || Game.time });
    }
    run() {
        if (this.colony.level < 6) {
            log.notify(`Removing extraction directive in ${this.pos.roomName}: room RCL insufficient.`);
            this.remove();
        }
        else if (!this.colony.terminal) {
            log.notify(`Removing extraction directive in ${this.pos.roomName}: room is missing terminal.`);
            this.remove();
        }
    }
};
DirectiveExtract.directiveName = 'extract';
DirectiveExtract.color = COLOR_YELLOW;
DirectiveExtract.secondaryColor = COLOR_CYAN;
DirectiveExtract = __decorate([
    profile
], DirectiveExtract);

var MiningOverlord_1;
const StandardMinerSetupCost = bodyCost(Setups.drones.miners.standard.generateBody(Infinity));
const DoubleMinerSetupCost = bodyCost(Setups.drones.miners.double.generateBody(Infinity));
const BUILD_OUTPUT_FREQUENCY = 15;
const SUICIDE_CHECK_FREQUENCY = 3;
const MINER_SUICIDE_THRESHOLD = 200;
const DISMANTLE_CHECK_FREQUENCY = 1500;
const DISMANTLE_CHECK = 'dc';
let MiningOverlord = MiningOverlord_1 = class MiningOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, 'mine', priority);
        this.distance = directive.distance;
        this.priority += this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.miners = this.zerg(Roles.drone);
        this.populateStructures();
        if (this.memory.dismantleNeeded || Game.time > (this.memory[DISMANTLE_CHECK] || 0)) {
            if (this.room) {
                this.dismantlePositions = this.getDismantlePositions();
                if (this.dismantlePositions.length > 0) {
                    this.memory.dismantleNeeded = true;
                }
                else {
                    this.memory[DISMANTLE_CHECK] = getCacheExpiration(DISMANTLE_CHECK_FREQUENCY, DISMANTLE_CHECK_FREQUENCY / 5);
                }
            }
        }
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {
            this.energyPerTick = SOURCE_ENERGY_KEEPER_CAPACITY / ENERGY_REGEN_TIME;
        }
        else if (this.colony.level >= DirectiveOutpost.settings.canSpawnReserversAtRCL) {
            this.energyPerTick = SOURCE_ENERGY_CAPACITY / ENERGY_REGEN_TIME;
        }
        else {
            this.energyPerTick = SOURCE_ENERGY_NEUTRAL_CAPACITY / ENERGY_REGEN_TIME;
        }
        this.miningPowerNeeded = Math.ceil(this.energyPerTick / HARVEST_POWER) + 1;
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {
            this.mode = 'SK';
            this.setup = Setups.drones.miners.sourceKeeper;
        }
        else if (this.colony.room.energyCapacityAvailable < StandardMinerSetupCost) {
            this.mode = 'early';
            this.setup = Setups.drones.miners.default;
        }
        else if (this.link) {
            this.mode = 'link';
            if (this.colony.assets.energy >= 100000) {
                this.setup = Setups.drones.miners.linkOptimized;
            }
            else {
                this.setup = Setups.drones.miners.default;
            }
        }
        else {
            this.mode = 'standard';
            this.setup = Setups.drones.miners.standard;
        }
        const miningPowerEach = this.setup.getBodyPotential(WORK, this.colony);
        this.minersNeeded = Math.min(Math.ceil(this.miningPowerNeeded / miningPowerEach), this.pos.availableNeighbors(true).length);
        this.minersNeeded = this.isDisabled ? 0 : this.minersNeeded;
        this.allowDropMining = this.colony.level < MiningOverlord_1.settings.dropMineUntilRCL;
        if (this.mode != 'early' && !this.allowDropMining) {
            if (this.container) {
                this.harvestPos = this.container.pos;
            }
            else if (this.link) {
                this.harvestPos = _.find(this.link.pos.availableNeighbors(true), pos => pos.getRangeTo(this) == 1);
            }
            else {
                this.harvestPos = this.calculateContainerPos();
            }
        }
    }
    isDoubleSource() {
        if (this.memory.doubleSource !== undefined) {
            return this.memory.doubleSource;
        }
        const room = Game.rooms[this.pos.roomName];
        if (room) {
            this.source = this.source || _.first(room.sources);
            const otherSource = _.find(this.source.pos.findInRange(FIND_SOURCES, 2), source => source.id != (this.source ? this.source.id : ''));
            if (otherSource) {
                this.secondSource = otherSource;
                if (this.source.pos.getRangeTo(this.secondSource) > 1) {
                    const miningPos = this.source.pos.getPositionAtDirection(this.source.pos.getDirectionTo(this.secondSource.pos));
                    if (!miningPos.isWalkable()) {
                        return false;
                    }
                }
                if (this.source.id > this.secondSource.id) {
                    this.isDisabled = true;
                }
                return true;
            }
        }
        return false;
    }
    getDismantlePositions() {
        const dismantleStructures = [];
        if (!this.room) {
            log.error(`MiningOverlord.getDismantleStructures() called with no vision in room ${this.pos.roomName}!`);
            return [];
        }
        if (this.room.name != this.colony.room.name) {
            if (this.memory.dismantleNeeded) {
                log.error(`dismantleNeeded is true but cannot find blockingPos when in outpost room: ${this.pos.roomName}`);
            }
            return [];
        }
        const targets = _.compact([...this.room.sources, this.room.controller]);
        for (const target of targets) {
            const blockingStructure = this.findBlockingStructure(target);
            if (blockingStructure) {
                dismantleStructures.push(blockingStructure);
            }
            for (const pos of target.pos.getPositionsInRange(2, false, false)) {
                const unwalkableStructure = _.find(pos.lookFor(LOOK_STRUCTURES), s => !s.isWalkable);
                if (unwalkableStructure && !unwalkableStructure.my) {
                    dismantleStructures.push(unwalkableStructure);
                }
            }
        }
        return _.unique(_.map(dismantleStructures, s => s.pos));
    }
    findBlockingStructure(target) {
        if (!this.room)
            return;
        const pos = Pathing.findBlockingPos(this.colony.pos, target.pos, _.filter(this.room.structures, s => !s.isWalkable));
        if (pos) {
            const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => !s.isWalkable);
            return structure || log.error(`${this.print}: no structure at blocking pos ${pos.print}!`);
        }
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.source = _.first(this.pos.lookFor(LOOK_SOURCES));
            this.constructionSite = _.first(_.filter(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2), site => site.structureType == STRUCTURE_CONTAINER ||
                site.structureType == STRUCTURE_LINK));
            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);
            this.link = this.pos.findClosestByLimitedRange(this.colony.availableLinks, 2);
        }
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            this.populateStructures();
        }
        super.refresh();
        $.refresh(this, 'source', 'container', 'link', 'constructionSite');
    }
    calculateContainerPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, pos => pos.getRangeTo(this) == 1);
            if (pos)
                return pos;
        }
        log.warning(`Last resort container position calculation for ${this.print}!`);
        return _.first(this.pos.availableNeighbors(true));
    }
    addRemoveContainer() {
        if (this.allowDropMining) {
            return;
        }
        if (!this.container && !this.constructionSite && !this.link) {
            const containerPos = this.calculateContainerPos();
            if (!containerPos) {
                log.error(`${this.print}: can't build container at ${this.room}`);
                return;
            }
            const container = containerPos ? containerPos.lookForStructure(STRUCTURE_CONTAINER) : undefined;
            if (container) {
                log.warning(`${this.print}: this.container out of sync at ${containerPos.print}`);
                this.container = container;
                return;
            }
            log.info(`${this.print}: building container at ${containerPos.print}`);
            const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);
            if (result != OK) {
                log.error(`${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`);
            }
            return;
        }
        if (this.container && this.link) {
            if (this.colony.hatchery && this.container.pos.getRangeTo(this.colony.hatchery) > 2 &&
                this.container.pos.getRangeTo(this.colony.upgradeSite) > 3) {
                log.info(`${this.print}: container and link present; destroying container at ${this.container.pos.print}`);
                this.container.destroy();
            }
        }
    }
    registerEnergyRequests() {
        if (this.container) {
            const transportCapacity = 200 * this.colony.level;
            const threshold = this.colony.stage > ColonyStage.Larva ? 0.8 : 0.5;
            if (_.sum(this.container.store) > threshold * transportCapacity) {
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    resourceType: 'all',
                    dAmountdt: this.energyPerTick
                });
            }
        }
        if (this.link) {
            const minerCapacity = 150;
            if (this.link.energy + minerCapacity > this.link.energyCapacity) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    init() {
        this.wishlist(this.minersNeeded, this.setup);
        this.registerEnergyRequests();
    }
    earlyMiningActions(miner) {
        if (!miner.pos.inRangeToPos(this.pos, 1)) {
            return miner.goTo(this);
        }
        if (this.container) {
            if (this.container.hits < this.container.hitsMax
                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.goRepair(this.container);
            }
            else {
                if (_.sum(miner.carry) < miner.carryCapacity) {
                    return miner.goHarvest(this.source);
                }
                else {
                    return miner.goTransfer(this.container);
                }
            }
        }
        if (this.constructionSite) {
            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.goBuild(this.constructionSite);
            }
            else {
                return miner.goHarvest(this.source);
            }
        }
        if (this.allowDropMining) {
            miner.goHarvest(this.source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);
                if (biggestDrop) {
                    miner.goDrop(biggestDrop.pos, RESOURCE_ENERGY);
                }
            }
            return;
        }
    }
    suicideOldMiners() {
        if (this.miners.length > this.minersNeeded && this.source) {
            const targetPos = this.harvestPos || this.source.pos;
            const minersNearSource = _.filter(this.miners, miner => miner.pos.getRangeTo(targetPos) <= SUICIDE_CHECK_FREQUENCY);
            if (minersNearSource.length > this.minersNeeded) {
                const oldestMiner = minBy(minersNearSource, miner => miner.ticksToLive || 9999);
                if (oldestMiner && (oldestMiner.ticksToLive || 9999) < MINER_SUICIDE_THRESHOLD) {
                    oldestMiner.suicide();
                    return true;
                }
            }
        }
        return false;
    }
    linkMiningActions(miner) {
        if (this.isSleeping(miner))
            return;
        if (this.link) {
            const res = miner.harvest(this.source);
            if (res == ERR_NOT_IN_RANGE) {
                if (this.goToMiningSite(miner))
                    return;
            }
            if (miner.carry.energy > 0.9 * miner.carryCapacity) {
                miner.transfer(this.link, RESOURCE_ENERGY);
            }
            if (Game.time % 10 == 0) {
                const commandCenterLink = this.colony.commandCenter ? this.colony.commandCenter.link : undefined;
                if (!commandCenterLink) {
                    miner.drop(RESOURCE_ENERGY);
                }
            }
        }
        else {
            log.warning(`${this.print}: Link miner ${miner.print} has no link! (Why?)`);
        }
    }
    standardMiningActions(miner) {
        if (this.isSleeping(miner))
            return;
        if (this.goToMiningSite(miner))
            return;
        const source = this.source;
        if (this.container) {
            if (this.container.hits < this.container.hitsMax
                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.repair(this.container);
            }
            else {
                return this.harvestOrSleep(miner, source);
            }
        }
        if (this.constructionSite) {
            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.build(this.constructionSite);
            }
            else {
                return this.harvestOrSleep(miner, source);
            }
        }
        if (this.allowDropMining) {
            this.harvestOrSleep(miner, source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
            }
            if (miner.carry.energy == miner.carryCapacity) {
                miner.drop(RESOURCE_ENERGY);
            }
            return;
        }
    }
    skMiningActions(miner) {
        if (this.isSleeping(miner))
            return;
        if (this.goToMiningSite(miner, false))
            return;
        const source = this.source;
        if (this.container) {
            if (this.container.hits < this.container.hitsMax
                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.repair(this.container);
            }
            else {
                return this.harvestOrSleep(miner, source);
            }
        }
        if (this.constructionSite) {
            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.build(this.constructionSite);
            }
            else {
                return this.harvestOrSleep(miner, source);
            }
        }
        if (this.allowDropMining) {
            this.harvestOrSleep(miner, source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
            }
            if (miner.carry.energy == miner.carryCapacity) {
                miner.drop(RESOURCE_ENERGY);
            }
            return;
        }
    }
    doubleMiningActions(miner) {
        if (this.goToMiningSite(miner))
            return;
        if (this.link) {
            if (this.source && this.source.energy > 0) {
                miner.harvest(this.source);
            }
            else {
                miner.harvest(this.secondSource);
            }
            if (miner.carry.energy > 0.9 * miner.carryCapacity) {
                miner.transfer(this.link, RESOURCE_ENERGY);
            }
            return;
        }
        else {
            log.warning(`Link miner ${miner.print} has no link!`);
        }
        if (this.container) {
            if (this.container.hits < this.container.hitsMax
                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.repair(this.container);
            }
            else if (this.source && this.source.energy > 0) {
                return miner.harvest(this.source);
            }
            else {
                return miner.harvest(this.secondSource);
            }
        }
        if (this.constructionSite) {
            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.build(this.constructionSite);
            }
            else {
                return miner.harvest(this.source);
            }
        }
        if (this.allowDropMining) {
            miner.harvest(this.source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
            }
            if (miner.carry.energy == miner.carryCapacity) {
                miner.drop(RESOURCE_ENERGY);
            }
            return;
        }
    }
    dismantleActions(miner) {
        if (!miner.safelyInRoom(this.pos.roomName)) {
            return miner.goToRoom(this.pos.roomName);
        }
        if (!this.dismantlePositions || this.dismantlePositions.length == 0) {
            log.info(`Miner dismantling completed in room ${miner.room.print}`);
            delete this.memory.dismantleNeeded;
            this.memory[DISMANTLE_CHECK] = getCacheExpiration(DISMANTLE_CHECK_FREQUENCY, DISMANTLE_CHECK_FREQUENCY / 5);
            return;
        }
        const dismantlePos = _.find(this.dismantlePositions, pos => Pathing.isReachable(miner.pos, pos, _.filter(miner.room.structures, s => !s.isWalkable)));
        if (dismantlePos) {
            const dismantleTarget = _.find(dismantlePos.lookFor(LOOK_STRUCTURES), s => !s.isWalkable && !s.my);
            if (dismantleTarget) {
                if (dismantleTarget.hits > 1000 && Game.time % 10 == 0) {
                    log.alert(`${miner.print} attempting to dismantle large structure!`);
                }
                return miner.goDismantle(dismantleTarget);
            }
        }
        else {
            log.warning(`No reachable dismantle positions for ${miner.print}!`);
        }
    }
    goToMiningSite(miner, avoidSK = true) {
        if (this.harvestPos) {
            if (!miner.pos.inRangeToPos(this.harvestPos, 0)) {
                miner.goTo(this.harvestPos, { range: 0, pathOpts: { avoidSK: avoidSK } });
                return true;
            }
        }
        else {
            if (!miner.pos.inRangeToPos(this.pos, 1)) {
                miner.goTo(this.pos, { range: 1, pathOpts: { avoidSK: avoidSK } });
                return true;
            }
        }
        return false;
    }
    isSleeping(miner) {
        if (miner.memory.sleepUntil) {
            if (Game.time >= miner.memory.sleepUntil) {
                delete miner.memory.sleepUntil;
                return false;
            }
            return true;
        }
        return false;
    }
    harvestOrSleep(miner, source, allowSuicide = true) {
        const ret = miner.harvest(source);
        if (ret != OK) {
            switch (ret) {
                case ERR_NOT_ENOUGH_RESOURCES:
                    if (allowSuicide && source.ticksToRegeneration > (miner.ticksToLive || Infinity)) {
                        miner.suicide();
                    }
                    else {
                        miner.memory.sleepUntil = Game.time + source.ticksToRegeneration;
                    }
                    break;
                case ERR_NO_BODYPART:
                    if (allowSuicide) {
                        miner.suicide();
                    }
                    break;
                case ERR_NOT_OWNER:
                    if (Game.time % 20 == 0) {
                        log.alert(`${miner.print}: room ${miner.room.name} is reserved by hostiles!`);
                    }
                    break;
                default:
                    log.error(`${miner.print}: unhandled miner.harvest() exception: ${ret}`);
                    break;
            }
        }
    }
    handleMiner(miner) {
        if (miner.avoidDanger({ timer: 10, dropEnergy: true })) {
            return;
        }
        if (this.memory.dismantleNeeded) {
            return this.dismantleActions(miner);
        }
        switch (this.mode) {
            case 'early':
                return this.earlyMiningActions(miner);
            case 'link':
                return this.linkMiningActions(miner);
            case 'standard':
                return this.standardMiningActions(miner);
            case 'SK':
                return this.skMiningActions(miner);
            case 'double':
                return this.doubleMiningActions(miner);
            default:
                log.error(`UNHANDLED MINER STATE FOR ${miner.print} (MODE: ${this.mode})`);
        }
    }
    run() {
        for (const miner of this.miners) {
            this.handleMiner(miner);
        }
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY == 1) {
            this.addRemoveContainer();
        }
        if (Game.time % SUICIDE_CHECK_FREQUENCY == 0) {
            this.suicideOldMiners();
        }
    }
};
MiningOverlord.settings = {
    minLinkDistance: 10,
    dropMineUntilRCL: 3,
};
MiningOverlord = MiningOverlord_1 = __decorate([
    profile
], MiningOverlord);

const defaultDirectiveHarvestMemory = {
    ["u"]: 1,
    ["d"]: 0,
};
let DirectiveHarvest = class DirectiveHarvest extends Directive {
    constructor(flag) {
        super(flag);
        if (this.colony) {
            this.colony.miningSites[this.name] = this;
        }
        _.defaultsDeep(this.memory, defaultDirectiveHarvestMemory);
    }
    get distance() {
        if (!this.memory["P"] || Game.time >= this.memory["P"]["X"]) {
            const distance = Pathing.distance(this.colony.pos, this.pos) || Infinity;
            const expiration = getCacheExpiration(this.colony.storage ? 5000 : 1000);
            this.memory["P"] = {
                ["D"]: distance,
                ["X"]: expiration
            };
        }
        return this.memory["P"]["D"];
    }
    spawnMoarOverlords() {
        let priority = OverlordPriority.ownedRoom.mine;
        if (!(this.room && this.room.my)) {
            priority = Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER ?
                OverlordPriority.remoteSKRoom.mine : OverlordPriority.remoteRoom.mine;
        }
        this.overlords.mine = new MiningOverlord(this, priority);
    }
    init() {
        var _a, _b;
        const harvestPos = (_b = (_a = this.overlords.mine) === null || _a === void 0 ? void 0 : _a.harvestPos) !== null && _b !== void 0 ? _b : this.pos;
        this.colony.destinations.push({ pos: harvestPos, order: this.memory["T"] || Game.time });
    }
    run() {
        this.computeStats();
    }
    computeStats() {
        const source = this.overlords.mine.source;
        if (source && source.ticksToRegeneration == 1) {
            this.memory["u"] = (source.energyCapacity - source.energy) / source.energyCapacity;
        }
        const container = this.overlords.mine.container;
        this.memory["d"] = +(ema(container ? +container.isFull : 0, this.memory["d"], CREEP_LIFE_TIME)).toFixed(5);
    }
    visuals() {
        if (!(this.memory.debug && Memory.settings.enableVisuals))
            return;
        const data = [
            this.name,
            ` U: ${this.memory["u"].toPercent()}`,
            ` D: ${this.memory["d"].toPercent()}`,
        ];
        if (this.memory["P"]) {
            data.push(` P: ${this.memory["P"]["D"]}`);
        }
        const { x, y, roomName } = this.pos;
        new RoomVisual(roomName).infoBox(data, x, y, { color: '#FFE87B' });
    }
};
DirectiveHarvest.directiveName = 'harvest';
DirectiveHarvest.color = COLOR_YELLOW;
DirectiveHarvest.secondaryColor = COLOR_YELLOW;
DirectiveHarvest = __decorate([
    profile
], DirectiveHarvest);

var PowerDrillOverlord_1;
let PowerDrillOverlord = PowerDrillOverlord_1 = class PowerDrillOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.powerMine.drill) {
        super(directive, 'powerDrill', priority, PowerDrillOverlord_1.requiredRCL, Memory.settings.powerCollection.maxRange * 50);
        this.directive = directive;
        this.priority += this.outpostIndex * OverlordPriority.powerMine.roomIncrement;
        this.drills = this.combatZerg(Roles.drill);
        this.coolant = this.combatZerg(Roles.coolant);
        this.memory = Mem.wrap(this.directive.memory, 'powerDrill');
        this.partnerMap = new Map();
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, 'powerDrill');
    }
    init() {
        this.wishlist(1, CombatSetups.drill.default);
        this.wishlist(2, CombatSetups.coolant.small);
    }
    getHostileDrill(powerBank) {
        return powerBank.hits < powerBank.hitsMax && powerBank.pos.findInRange(FIND_HOSTILE_CREEPS, 2)[0];
    }
    handleHostileDrill(hostileDrill, powerBank) {
        Game.notify(`${hostileDrill.owner.username} power harvesting ${powerBank.room.name}, competing for same power bank.`);
    }
    handleDrill(drill) {
        if (drill.spawning) {
            return;
        }
        if (!this.directive.powerBank) {
            if (!this.room) {
            }
            else {
                if (this.directive.powerBank == undefined && this.directive.memory.state < 2) {
                    Game.notify(`Power bank in ${this.room.print} is dead.`);
                    drill.say('💀 RIP 💀');
                    const result = drill.retire();
                    if (result == ERR_BUSY) {
                    }
                    log.notify('FINISHED POWER MINING IN ' + this.room + ' DELETING CREEP at time: ' +
                        Game.time.toString() + ' result: ' + result);
                    return;
                }
            }
        }
        if (!this.room || drill.room != this.room || drill.pos.isEdge || !this.directive.powerBank) {
            drill.goTo(this.pos);
            return;
        }
        if (drill.pos.isNearTo(this.directive.powerBank)) {
            if (!this.partnerMap.get(drill.name)) {
                this.partnerMap.set(drill.name, []);
            }
            PowerDrillOverlord_1.periodicSay(drill, 'Drilling⚒️');
            drill.attack(this.directive.powerBank);
        }
        else {
            PowerDrillOverlord_1.periodicSay(drill, '🚗Traveling🚗');
            drill.goTo(this.directive.powerBank);
        }
    }
    handleCoolant(coolant) {
        if (coolant.spawning) {
            return;
        }
        if (!this.room || coolant.room != this.room || coolant.pos.isEdge) {
            coolant.healSelfIfPossible();
            coolant.goTo(this.pos);
            return;
        }
        else if (!this.directive.powerBank) {
            Game.notify('Power bank in ' + this.room + ' is dead.');
            coolant.say('💀 RIP 💀');
            coolant.retire();
            return;
        }
        if (coolant.pos.getRangeTo(this.directive.powerBank) > 3) {
            coolant.goTo(this.directive.powerBank);
        }
        else {
            const activeDrills = this.pos.findInRange(FIND_MY_CREEPS, 1).filter(creep => _.contains(creep.name, 'drill'));
            if (activeDrills.length > 0) {
                const drill = activeDrills[0];
                coolant.heal(drill);
                if (coolant.pos.getRangeTo(drill) > 1) {
                    coolant.goTo(drill, { range: 1, noPush: true });
                }
            }
        }
    }
    static periodicSay(zerg, text) {
        if (Game.time % 10 == PowerDrillOverlord_1.getCreepNameOffset(zerg)) {
            zerg.say(text, true);
        }
    }
    static getCreepNameOffset(zerg) {
        return parseInt(zerg.name.charAt(zerg.name.length - 1), 10) || 0;
    }
    run() {
        this.autoRun(this.drills, drill => this.handleDrill(drill));
        this.autoRun(this.coolant, coolant => this.handleCoolant(coolant));
        if (this.directive.memory.state >= 3) {
            Game.notify('DELETING ALL POWER MINING CREEPS BECAUSE STATE IS >= 3 in ' + this.directive.print);
            this.drills.forEach(drill => drill.retire());
            this.coolant.forEach(coolant => coolant.retire());
        }
    }
    visuals() {
        if (this.room && this.directive.powerBank) {
            Visualizer.marker(this.directive.powerBank.pos);
        }
    }
};
PowerDrillOverlord.requiredRCL = 7;
PowerDrillOverlord = PowerDrillOverlord_1 = __decorate([
    profile
], PowerDrillOverlord);

let PowerHaulingOverlord = class PowerHaulingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.collectionUrgent.haul) {
        super(directive, 'powerHaul', priority);
        this.requiredRCL = 6;
        this.prespawnAmount = 300;
        this.directive = directive;
        this.haulers = this.zerg(Roles.transport);
        this.totalCollected = this.totalCollected || 0;
        const haulingPartsNeeded = this.directive.totalResources / CARRY_CAPACITY;
        const haulerCarryParts = Setups.transporters.default.getBodyPotential(CARRY, this.colony);
        this.numHaulers = Math.ceil(haulingPartsNeeded / haulerCarryParts);
        const route = Game.map.findRoute(this.directive.pos.roomName, this.colony.room.name);
        const distance = route == -2 ? 50 : route.length * 50;
        this.tickToSpawnOn = Game.time + (this.directive.calculateRemainingLifespan() || 0) - distance - this.prespawnAmount;
    }
    init() {
    }
    handleHauler(hauler) {
        if (_.sum(hauler.carry) == 0) {
            if (this.directive.memory.state >= 4) {
                hauler.say('💀 RIP 💀', true);
                log.warning(`${hauler.name} is committing suicide as directive is done!`);
                this.numHaulers = 0;
                hauler.retire();
            }
            if (hauler.inSameRoomAs(this.directive)) {
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    }
                }
                else if (this.directive.powerBank) {
                    if (hauler.pos.getRangeTo(this.directive.powerBank) > 4) {
                        hauler.goTo(this.directive.powerBank);
                    }
                    else {
                        hauler.say('🚬', true);
                    }
                    return;
                }
                else if (this.room && this.room.ruins) {
                    const pb = this.room.ruins.filter(ruin => !!ruin.store[RESOURCE_POWER] && ruin.store[RESOURCE_POWER] > 0);
                    if (pb.length > 0) {
                        hauler.task = Tasks.withdraw(pb[0], RESOURCE_POWER);
                    }
                }
                else if (this.room && this.room.drops) {
                    const allDrops = _.flatten(_.values(this.room.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    }
                    else {
                        hauler.say('💀 RIP 💀', true);
                        log.warning(`${hauler.name} is committing suicide!`);
                        hauler.retire();
                        return;
                    }
                }
                log.warning(`${hauler.name} in ${hauler.room.print}: nothing to collect!`);
            }
            else {
                hauler.goTo(this.directive);
            }
        }
        else {
            if (hauler.inSameRoomAs(this.colony)) {
                for (const [resourceType, amount] of hauler.carry.contents) {
                    if (amount == 0)
                        continue;
                    if (resourceType == RESOURCE_ENERGY) {
                        if (this.colony.storage && _.sum(this.colony.storage.store) < STORAGE_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.storage, resourceType);
                            return;
                        }
                        else if (this.colony.terminal && _.sum(this.colony.terminal.store) < TERMINAL_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                    }
                    else {
                        this.directive.memory.totalCollected += hauler.carry.power || 0;
                        if (this.colony.terminal && _.sum(this.colony.terminal.store) < TERMINAL_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                        else if (this.colony.storage && _.sum(this.colony.storage.store) < STORAGE_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.storage, resourceType);
                            return;
                        }
                    }
                }
                log.warning(`${hauler.name} in ${hauler.room.print}: nowhere to put resources!`);
            }
            else {
                hauler.task = Tasks.goToRoom(this.colony.room.name);
            }
        }
    }
    checkIfStillCarryingPower() {
        return _.find(this.haulers, hauler => hauler.carry.power != undefined && hauler.carry.power > 0);
    }
    run() {
        if (Game.time >= this.tickToSpawnOn && this.directive.memory.state < 4) {
            this.wishlist(this.numHaulers, Setups.transporters.default);
        }
        this.autoRun(this.haulers, this.handleHauler);
    }
};
PowerHaulingOverlord = __decorate([
    profile
], PowerHaulingOverlord);

function calculateFormationStrength(creeps) {
    const tally = {
        move: 0,
        work: 0,
        carry: 0,
        attack: 0,
        ranged_attack: 0,
        tough: 0,
        heal: 0,
        claim: 0,
    };
    _.forEach(creeps, function (unit) {
        const individualTally = calculateBodyPotential(unit.body);
        for (const bodyType in individualTally) {
            const type = bodyType;
            tally[type] += individualTally[type];
        }
    });
    return tally;
}
function calculateBodyPotential(body) {
    const tally = {
        move: 0,
        work: 0,
        carry: 0,
        attack: 0,
        ranged_attack: 0,
        tough: 0,
        heal: 0,
        claim: 0,
    };
    _.forEach(body, function (bodyPart) {
        tally[bodyPart.type] += 1;
    });
    return tally;
}

var DirectivePowerMine_1;
var PowerMineState;
(function (PowerMineState) {
    PowerMineState[PowerMineState["init"] = 0] = "init";
    PowerMineState[PowerMineState["miningStarted"] = 1] = "miningStarted";
    PowerMineState[PowerMineState["haulingStarted"] = 2] = "haulingStarted";
    PowerMineState[PowerMineState["miningDone"] = 3] = "miningDone";
    PowerMineState[PowerMineState["haulingComplete"] = 4] = "haulingComplete";
})(PowerMineState || (PowerMineState = {}));
let DirectivePowerMine = DirectivePowerMine_1 = class DirectivePowerMine extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= DirectivePowerMine_1.requiredRCL);
        this._powerBank = this.powerBank;
        this.memory.state = this.memory.state || 0;
        this.memory["X"] = this.memory["X"] ||
            Game.time + (this.powerBank ? this.powerBank.ticksToDecay + 1000 : 5500);
        this.memory.totalCollected = this.memory.totalCollected || 0;
    }
    spawnMoarOverlords() {
        if (this.memory.state < 3) {
            this.overlords.powerMine = new PowerDrillOverlord(this);
        }
        if (this.memory.state > 1) {
            this.overlords.powerHaul = new PowerHaulingOverlord(this);
        }
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops || _.keys(this._drops).length == 0) {
            const drops = (this.pos.lookFor(LOOK_RESOURCES) || []);
            this._drops = _.groupBy(drops, drop => drop.resourceType);
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get powerBank() {
        if (this.pos.isVisible) {
            this._powerBank = this._powerBank || !!this.flag.room
                ? this.flag.pos.lookForStructure(STRUCTURE_POWER_BANK)
                : undefined;
            return this._powerBank;
        }
    }
    get totalResources() {
        if (this.pos.isVisible) {
            this.memory.totalResources = this.powerBank ? this.powerBank.power : this.memory.totalResources;
        }
        if (this.memory.totalResources == undefined) {
            return 5000;
        }
        return this.memory.totalResources;
    }
    calculateRemainingLifespan() {
        if (!this.room) {
            return undefined;
        }
        else if (this.powerBank == undefined) {
            return 0;
        }
        else {
            const tally = calculateFormationStrength(this.powerBank.pos.findInRange(FIND_MY_CREEPS, 4));
            const healStrength = tally.heal * HEAL_POWER || 0;
            const attackStrength = tally.attack * ATTACK_POWER || 0;
            const avgDamagePerTick = Math.min(attackStrength, healStrength * 2);
            return this.powerBank.hits / avgDamagePerTick;
        }
    }
    manageState() {
        const currentState = this.memory.state;
        log.debug(`Managing state ${currentState} of directive ${this.print} with PB ${this.powerBank}`);
        if (currentState == 0 && this.powerBank && this.powerBank.hits < this.powerBank.hitsMax) {
            if (this.powerBank.pos.findInRange(FIND_MY_CREEPS, 3).length == 0
                && this.powerBank.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length > 0) {
                log.alert(`Power bank mining ${this.print} competing with ${this.powerBank.room.hostiles[0].owner.username}.`);
            }
            else {
                this.memory.state = 1;
            }
        }
        else if ((currentState == 0 || currentState == 1) && this.room && (!this.powerBank
            || this.powerBank.hits < 500000)) {
            Game.notify('Activating spawning haulers for power mining in room ' + this.pos.roomName);
            log.info('Activating spawning haulers for power mining in room ' + this.pos.roomName);
            this.memory.state = 2;
        }
        else if (currentState == 2 && this.room && !this.powerBank && (this.hasDrops || this.room.ruins.length == 0)) {
            Game.notify(`Mining is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            log.alert(`Mining is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            this.memory.state = 3;
            delete this.overlords.powerMine;
            this._powerBank = undefined;
        }
        else if ((currentState == 0 || currentState == 1 || currentState == 2) && this.room
            && this.pos.isVisible && !this.powerBank) {
            if (!this.hasDrops && this.room.ruins.length == 0) {
                Game.notify(`WE FAILED. SORRY CHIEF, COULDN'T FINISH POWER MINING IN ${this.print} ` +
                    `DELETING Directive at time ${Game.time}`);
                log.error(`WE FAILED. SORRY CHIEF, COULDN'T FINISH POWER MINING IN ${this.room} ` +
                    `DELETING Directive at time: ${Game.time}`);
                this.remove();
            }
            else {
                Game.notify(`Somehow the power bank died early in ${this.room} at state ${currentState}, ` +
                    `setting state to 3 ${Game.time}`);
                this.memory.state = 3;
            }
        }
        else if (currentState == 3 && this.room && this.pos.isVisible && !this.hasDrops
            && this.room.ruins.filter(ruin => !!ruin.store[RESOURCE_POWER]
                && ruin.store[RESOURCE_POWER] > 0).length == 0) {
            Game.notify(`Hauler pickup is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            log.alert(`Hauler pickup is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            this.memory.state = 4;
        }
        else if (currentState == 4 && this.overlords.powerHaul && this.overlords.powerHaul
            .checkIfStillCarryingPower() == undefined) {
            log.notify(`Hauling complete for ${this.print} at time ${Game.time}. Final power collected was 
			${this.memory.totalCollected} out of ${this.memory.totalResources}`);
            this.remove();
        }
        else {
            log.debug(`Power mining ${this.print} is in state ${currentState}`);
        }
    }
    init() {
        let alert;
        if (this.pos.room && !!this.powerBank) {
            alert = `PM ${this.memory.state} ${this.totalResources} P${Math.floor(100 * this.powerBank.hits / this.powerBank.hitsMax)}% @ ${this.powerBank.ticksToDecay}TTL`;
        }
        else {
            alert = `PowerMine ${this.memory.state} ${this.totalResources}`;
        }
        this.alert(alert);
    }
    run() {
        const frequency = this.memory.state == 2 ? 1 : 21;
        if (Game.time % frequency == 0) {
            this.manageState();
        }
    }
};
DirectivePowerMine.directiveName = 'powerMine';
DirectivePowerMine.color = COLOR_YELLOW;
DirectivePowerMine.secondaryColor = COLOR_RED;
DirectivePowerMine.requiredRCL = 7;
DirectivePowerMine = DirectivePowerMine_1 = __decorate([
    profile
], DirectivePowerMine);

let DirectiveRPBunker = class DirectiveRPBunker extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    init() {
        if (!this.room)
            return;
        if (this.colony.room.name != this.room.name)
            return;
        this.colony.roomPlanner.addComponent('bunker', this.pos, this.memory.rotation);
    }
    run() {
    }
    visuals() {
        Visualizer.drawLayout(bunkerLayout, this.pos);
    }
};
DirectiveRPBunker.directiveName = 'roomPlanner:CommandCenter';
DirectiveRPBunker.color = COLOR_WHITE;
DirectiveRPBunker.secondaryColor = COLOR_RED;
DirectiveRPBunker = __decorate([
    profile
], DirectiveRPBunker);

let DirectiveRPCommandCenter = class DirectiveRPCommandCenter extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    init() {
        log.info(`Classic overmind layout is deprecated; bunker layout is recommended.`);
        this.colony.roomPlanner.addComponent('commandCenter', this.pos, this.memory.rotation);
    }
    run() {
    }
};
DirectiveRPCommandCenter.directiveName = 'roomPlanner:CommandCenter';
DirectiveRPCommandCenter.color = COLOR_WHITE;
DirectiveRPCommandCenter.secondaryColor = COLOR_BLUE;
DirectiveRPCommandCenter = __decorate([
    profile
], DirectiveRPCommandCenter);

let DirectiveRPHatchery = class DirectiveRPHatchery extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    init() {
        log.info(`Classic overmind layout is deprecated; bunker layout is recommended.`);
        this.colony.roomPlanner.addComponent('hatchery', this.pos, this.memory.rotation);
    }
    run() {
    }
};
DirectiveRPHatchery.directiveName = 'roomPlanner:Hatchery';
DirectiveRPHatchery.color = COLOR_WHITE;
DirectiveRPHatchery.secondaryColor = COLOR_GREEN;
DirectiveRPHatchery = __decorate([
    profile
], DirectiveRPHatchery);

let BootstrappingOverlord = class BootstrappingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.emergency.bootstrap) {
        super(directive, 'bootstrap', priority);
        this.fillers = this.zerg(Roles.filler);
        this.supplyStructures = _.filter([...this.colony.spawns, ...this.colony.extensions], structure => structure.energy < structure.energyCapacity);
        this.withdrawStructures = _.filter(_.compact([this.colony.storage,
            this.colony.terminal,
            this.colony.powerSpawn,
            ...this.room.containers,
            ...this.room.links,
            ...this.room.towers,
            ...this.room.labs]), structure => structure.energy > 0);
    }
    spawnBootstrapMiners() {
        let miningSitesInRoom = _.filter(_.values(this.colony.miningSites), site => site.room == this.colony.room);
        if (this.colony.spawns[0]) {
            miningSitesInRoom = _.sortBy(miningSitesInRoom, site => site.pos.getRangeTo(this.colony.spawns[0]));
        }
        const pattern = [WORK, WORK, CARRY, MOVE];
        const miningOverlordsInRoom = _.map(miningSitesInRoom, site => site.overlords.mine);
        const allMiners = _.flatten(_.map(miningOverlordsInRoom, overlord => overlord.lifetimeFilter(overlord.miners)));
        const allMiningPower = _.sum(allMiners, creep => creep.getActiveBodyparts(WORK));
        let sizeLimit;
        if (allMiningPower == 0) {
            sizeLimit = Math.min(Math.floor(this.colony.room.energyAvailable / bodyCost(pattern)), 3);
        }
        else {
            sizeLimit = 3;
        }
        const setup = new CreepSetup(Roles.drone, {
            pattern: pattern,
            sizeLimit: sizeLimit,
        });
        for (const overlord of miningOverlordsInRoom) {
            const filteredMiners = this.lifetimeFilter(overlord.miners);
            const miningPowerAssigned = _.sum(_.map(this.lifetimeFilter(overlord.miners), creep => creep.getActiveBodyparts(WORK)));
            if (miningPowerAssigned < overlord.miningPowerNeeded &&
                filteredMiners.length < overlord.pos.availableNeighbors().length) {
                if (this.colony.hatchery) {
                    const request = {
                        setup: setup,
                        overlord: overlord,
                        priority: this.priority + 1,
                    };
                    this.colony.hatchery.enqueue(request);
                    this.debug(`Enqueueing bootstrap miner with size ${sizeLimit}`);
                }
            }
        }
    }
    init() {
        const totalEnergyInRoom = _.sum(this.withdrawStructures, structure => structure.store.energy);
        const costToMakeNormalMinerAndFiller = patternCost(Setups.drones.miners.emergency) * 3
            + patternCost(Setups.filler);
        if (totalEnergyInRoom < costToMakeNormalMinerAndFiller) {
            if (this.colony.getCreepsByRole(Roles.drone).length == 0) {
                this.spawnBootstrapMiners();
                return;
            }
        }
        if (this.colony.getCreepsByRole(Roles.queen).length == 0 && this.colony.hatchery) {
            const transporter = _.first(this.colony.getZergByRole(Roles.transport));
            if (transporter) {
                transporter.reassign(this.colony.hatchery.overlord, Roles.queen);
            }
            else {
                this.wishlist(1, Setups.filler);
            }
        }
        this.spawnBootstrapMiners();
    }
    supplyActions(filler) {
        const target = filler.pos.findClosestByRange(this.supplyStructures);
        if (target) {
            filler.task = Tasks.transfer(target);
        }
        else {
            this.rechargeActions(filler);
        }
    }
    rechargeActions(filler) {
        const target = filler.pos.findClosestByRange(this.withdrawStructures);
        if (target) {
            filler.task = Tasks.withdraw(target);
        }
        else {
            filler.task = Tasks.recharge();
        }
    }
    handleFiller(filler) {
        if (filler.carry.energy > 0) {
            this.supplyActions(filler);
        }
        else {
            this.rechargeActions(filler);
        }
    }
    run() {
        this.autoRun(this.fillers, filler => this.handleFiller(filler));
    }
};
BootstrappingOverlord.settings = {
    spawnBootstrapMinerThreshold: 3000
};
BootstrappingOverlord = __decorate([
    profile
], BootstrappingOverlord);

let DirectiveBootstrap = class DirectiveBootstrap extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.bootstrapping = true;
        this.needsMiner = (this.colony.getCreepsByRole(Roles.drone).length == 0);
        this.needsManager = (this.colony.commandCenter != undefined &&
            this.colony.commandCenter.overlord != undefined &&
            this.colony.commandCenter.link != undefined &&
            this.colony.getCreepsByRole(Roles.manager).length == 0);
        this.needsQueen = (this.colony.getCreepsByRole(Roles.queen).length == 0);
    }
    spawnMoarOverlords() {
        this.overlords.bootstrap = new BootstrappingOverlord(this);
    }
    init() {
        this.alert(`Colony in bootstrap mode!`, NotifierPriority.High);
        if (Game.time % 100 == 0) {
            log.alert(`Colony ${this.room.print} is in emergency recovery mode.`);
        }
    }
    run() {
        if (!this.needsQueen && !this.needsMiner) {
            if (this.colony.storage && this.colony.assets.energy < 5000) {
                return;
            }
            log.alert(`Colony ${this.room.print} has recovered from crash; removing bootstrap directive.`);
            const overlord = this.overlords.bootstrap;
            for (const filler of overlord.fillers) {
                filler.reassign(this.colony.overlords.logistics, Roles.transport);
            }
            this.remove();
        }
    }
};
DirectiveBootstrap.directiveName = 'bootstrap';
DirectiveBootstrap.color = COLOR_ORANGE;
DirectiveBootstrap.secondaryColor = COLOR_ORANGE;
DirectiveBootstrap = __decorate([
    profile
], DirectiveBootstrap);

let DirectiveNukeTarget = class DirectiveNukeTarget extends Directive {
    constructor(flag) {
        super(flag, (colony) => !!colony.nuker && !(colony.nuker.cooldown > 0)
            && Game.map.getRoomLinearDistance(colony.room.name, flag.pos.roomName) <= 10);
        this.refresh();
    }
    refresh() {
        super.refresh();
    }
    spawnMoarOverlords() {
    }
    init() {
    }
    run() {
        if (this.colony.nuker && this.colony.nuker.cooldown == 0) {
            const res = this.colony.nuker.launchNuke(this.flag.pos);
            if (res == OK) {
                log.notify(`Launching nuclear strike at ${this.flag.pos.print}, ETA ${Game.time + NUKE_LAND_TIME}`);
                this.remove();
            }
        }
        else if (!this.colony.nuker || this.colony.nuker.cooldown > 0) {
            log.error(`DirectiveNuke unable to fire from ${this.colony.name} due to nuker ${this.colony.nuker} ` +
                `being unavailable: ${this.print}`);
            this.remove();
        }
    }
};
DirectiveNukeTarget.directiveName = 'nukeTarget';
DirectiveNukeTarget.color = COLOR_ORANGE;
DirectiveNukeTarget.secondaryColor = COLOR_RED;
DirectiveNukeTarget.requiredRCL = 8;
DirectiveNukeTarget = __decorate([
    profile
], DirectiveNukeTarget);

const DEFAULT_NUM_SCOUTS = 1;
let PortalScoutOverlord = class PortalScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.randomWalker) {
        super(directive, 'scout', priority);
        this.directive = directive;
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(DEFAULT_NUM_SCOUTS, Setups.scout);
    }
    portalSays(creep, isPublic) {
        const says = ['One small', 'step for', `${creep.name}`, `one giant`, `leap for`, `all`, `Creepkind`];
        creep.say(says[Game.time % says.length], isPublic);
    }
    handleScout(scout) {
        const finalDestination = this.directive;
        if (scout.pos != finalDestination.pos) {
            scout.goTo(finalDestination, { pathOpts: { avoidSK: true } });
        }
        this.portalSays(scout, true);
    }
    run() {
        this.autoRun(this.scouts, scout => this.handleScout(scout));
    }
};
PortalScoutOverlord = __decorate([
    profile
], PortalScoutOverlord);

let DirectivePortalScout = class DirectivePortalScout extends Directive {
    constructor(flag, colonyFilter) {
        flag.memory.allowPortals = true;
        super(flag, colonyFilter);
    }
    spawnMoarOverlords() {
        this.overlords.portalScoutOverlord = new PortalScoutOverlord(this);
    }
    init() {
        this.alert(`Portal scout active`);
    }
    run() {
    }
};
DirectivePortalScout.directiveName = 'portalScout';
DirectivePortalScout.color = COLOR_ORANGE;
DirectivePortalScout.secondaryColor = COLOR_WHITE;
DirectivePortalScout.requiredRCL = 3;
DirectivePortalScout = __decorate([
    profile
], DirectivePortalScout);

const highPriorityLoot = [
    ...BOOSTS_T3,
    RESOURCE_OPS,
    RESOURCE_POWER,
];
const lowPriorityLoot = [
    ...BOOSTS_T2,
    ...BOOSTS_T1,
    ...INTERMEDIATE_REACTANTS,
    ...BASE_RESOURCES,
];
const dontLoot = [
    RESOURCE_ENERGY,
];
const everythingElse = _.filter(RESOURCES_ALL, res => !(highPriorityLoot.includes(res) || lowPriorityLoot.includes(res))
    && !dontLoot.includes(res));
const LOOTING_ORDER = [...highPriorityLoot,
    ...everythingElse,
    ...lowPriorityLoot];
let RemoteUpgradingOverlord = class RemoteUpgradingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.remoteUpgrading) {
        super(directive, 'remoteUpgrade', priority);
        this.directive = directive;
        this.parentColony = this.colony;
        this.childColony = Overmind.colonies[this.pos.roomName];
        if (!this.childColony) {
            log.error(`${this.print}: no child colony! (Why?)`);
        }
        if (this.parentColony == this.childColony) {
            log.error(`${this.print}: parent and child colonies are the same! (Why?)`);
        }
        this.upgradeSite = this.childColony.upgradeSite;
        this.carriers = this.zerg(Roles.transport);
        this.upgraders = this.zerg(Roles.upgrader);
        this.boosted = true;
    }
    computeNeededCarrierCapacity() {
        if (this.childColony.terminal && this.childColony.terminal.my) {
            return 0;
        }
        const roundTripDistance = 1.5 * this.directive.distanceFromColony.terrainWeighted;
        const energyPerTick = _.sum(this.upgraders, upgrader => UPGRADE_CONTROLLER_POWER * upgrader.getActiveBodyparts(WORK));
        return energyPerTick * roundTripDistance;
    }
    init() {
        let neededCarriers = this.carriers.length;
        if (this.carriers.length == 0) {
            neededCarriers = 1;
        }
        else {
            const neededCarryCapacity = this.computeNeededCarrierCapacity();
            const currentCarryCapacity = _.sum(this.carriers, carrier => CARRY_CAPACITY * CombatIntel.getCarryPotential(carrier.creep, true));
            const avgCarrierCapactiy = currentCarryCapacity / this.carriers.length;
            this.debug(`Needed carry capacity: ${neededCarryCapacity}; Current carry capacity: ${currentCarryCapacity}`);
            neededCarriers = Math.ceil(neededCarryCapacity / avgCarrierCapactiy);
            this.debug(`Needed carriers: ${neededCarriers}`);
        }
        if (this.boosted) {
            this.wishlist(neededCarriers, Setups.transporters.boosted, { priority: this.priority });
            this.wishlist(8, Setups.upgraders.remote_boosted, { priority: this.priority + 1 });
        }
        else {
            this.wishlist(neededCarriers, Setups.transporters.default, { priority: this.priority });
            this.wishlist(8, Setups.upgraders.remote, { priority: this.priority + 1 });
        }
    }
    handleUpgrader(upgrader) {
        if (!upgrader.safelyInRoom(this.childColony.room.name)) {
            upgrader.goToRoom(this.childColony.room.name);
            return;
        }
        if (upgrader.carry.energy > 0) {
            upgrader.task = Tasks.upgrade(this.upgradeSite.controller);
            return;
        }
        if (this.upgradeSite.link && this.upgradeSite.link.energy > 0) {
            upgrader.task = Tasks.withdraw(this.upgradeSite.link);
            return;
        }
        if (this.upgradeSite.battery && this.upgradeSite.battery.energy > 0) {
            upgrader.task = Tasks.withdraw(this.upgradeSite.battery);
            return;
        }
        const nearbyCarriers = _.filter(this.carriers, carrier => upgrader.pos.getRangeTo(carrier) <= 5);
        const nearbyCarriersWaitingToUnload = _.filter(nearbyCarriers, carrier => carrier.carry.energy > 0);
        const lowestEnergyCarrier = minBy(nearbyCarriersWaitingToUnload, carrier => carrier.carry.energy);
        if (lowestEnergyCarrier) {
            upgrader.goTo(lowestEnergyCarrier);
            return;
        }
        else {
            upgrader.task = Tasks.recharge();
        }
    }
    handleCarrier(carrier) {
        if (carrier.getActiveBodyparts(HEAL) > 0) {
            carrier.heal(carrier);
        }
        if (carrier.carry.energy == 0) {
            if (carrier.room == this.childColony.room && carrier.carry.getFreeCapacity() > 0) {
                const storeStructuresNotMy = _.filter(_.compact([this.childColony.room.storage,
                    this.childColony.room.terminal]), structure => !structure.my);
                for (const resource of LOOTING_ORDER) {
                    const withdrawTarget = _.find(storeStructuresNotMy, structure => structure.store.getUsedCapacity(resource) > 0);
                    if (withdrawTarget) {
                        const amount = Math.min(withdrawTarget.store.getUsedCapacity(resource), carrier.carry.getFreeCapacity());
                        carrier.task = Tasks.withdraw(withdrawTarget, resource, amount);
                        return;
                    }
                }
            }
            if (!carrier.safelyInRoom(this.parentColony.room.name)) {
                carrier.goToRoom(this.parentColony.room.name);
                return;
            }
            const target = _.find(_.compact([this.parentColony.storage, this.parentColony.terminal]), s => s.store[RESOURCE_ENERGY] >= carrier.carryCapacity);
            if (!target) {
                log.warning(`${this.print}: no energy withdraw target for ${carrier.print}!`);
                return;
            }
            if (carrier.carry.getUsedCapacity() > carrier.carry.getUsedCapacity(RESOURCE_ENERGY)) {
                carrier.task = Tasks.transferAll(target);
            }
            else {
                carrier.task = Tasks.withdraw(target);
            }
        }
        else {
            if (!carrier.safelyInRoom(this.childColony.room.name)) {
                carrier.goToRoom(this.childColony.room.name);
                return;
            }
            const depositPos = this.upgradeSite.batteryPos || this.upgradeSite.pos;
            const carriersWaitingToUnload = _.filter(this.carriers, carrier => carrier.carry.energy > 0 && carrier.pos.inRangeToPos(depositPos, 5));
            const firstCarrierInQueue = minBy(carriersWaitingToUnload, carrier => carrier.carry.energy + (carrier.ticksToLive || Infinity) / 10000);
            if (this.childColony.storage && firstCarrierInQueue && firstCarrierInQueue != carrier) {
                carrier.task = Tasks.transfer(this.childColony.storage);
                return;
            }
            const range = firstCarrierInQueue && carrier == firstCarrierInQueue ? 0 : 3;
            if (!carrier.pos.inRangeToPos(depositPos, range)) {
                const ret = carrier.goTo(depositPos);
                return;
            }
            if (carrier == firstCarrierInQueue) {
                if (this.upgradeSite.battery && this.upgradeSite.battery.store.getFreeCapacity() > 0) {
                    if (carrier.transfer(this.upgradeSite.battery) == OK)
                        return;
                }
                const upgraderTransferTarget = maxBy(_.filter(this.upgraders, upgrader => upgrader.pos.isNearTo(carrier)), upgrader => upgrader.store.getFreeCapacity());
                if (upgraderTransferTarget) {
                    if (carrier.transfer(upgraderTransferTarget) == OK)
                        return;
                }
            }
        }
    }
    run() {
        this.autoRun(this.upgraders, upgrader => this.handleUpgrader(upgrader));
        this.autoRun(this.carriers, carrier => this.handleCarrier(carrier));
    }
};
RemoteUpgradingOverlord = __decorate([
    profile
], RemoteUpgradingOverlord);

var DirectiveRemoteUpgrade_1;
let DirectiveRemoteUpgrade = DirectiveRemoteUpgrade_1 = class DirectiveRemoteUpgrade extends Directive {
    constructor(flag) {
        flag.memory.allowPortals = true;
        super(flag, (colony) => colony.level >= DirectiveRemoteUpgrade_1.requiredRCL);
    }
    spawnMoarOverlords() {
        this.overlords.remoteUpgrade = new RemoteUpgradingOverlord(this);
    }
    init() {
        this.alert(`Remote upgrade active`);
    }
    run() {
        if (this.room && this.room.controller && this.room.controller.level == 8) {
            this.remove();
        }
    }
};
DirectiveRemoteUpgrade.directiveName = 'remoteUpgrade';
DirectiveRemoteUpgrade.color = COLOR_ORANGE;
DirectiveRemoteUpgrade.secondaryColor = COLOR_YELLOW;
DirectiveRemoteUpgrade.requiredRCL = 8;
DirectiveRemoteUpgrade = DirectiveRemoteUpgrade_1 = __decorate([
    profile
], DirectiveRemoteUpgrade);

var StrongholdOverlord_1;
const StrongholdAttackPriorities = [
    STRUCTURE_INVADER_CORE,
    STRUCTURE_TOWER,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
let StrongholdOverlord = StrongholdOverlord_1 = class StrongholdOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, 'stronghold', priority, 1);
        this.strongholdKillers = this.combatZerg(Roles.strongholdKiller, { notifyWhenAttacked: false });
    }
    findAttackingPositionAndTarget(target, range, myCreep) {
        log.info(`Finding attacking position in ${target.room} for ${this.print}`);
        if (!target.room || range == 0) {
            return;
        }
        const shootPositions = target.pos.getPositionsAtRange(range, false, false);
        const avoidLocs = Array.from({ length: 5 }, () => []);
        avoidLocs[1] = avoidLocs[1].concat(target.room.ramparts.map(rampart => rampart.pos));
        avoidLocs[4] = avoidLocs[4].concat(target.room.sources.map(s => s.pos));
        avoidLocs[4] = avoidLocs[4].concat(target.room.keeperLairs.map(s => s.pos));
        if (target.room.mineral) {
            avoidLocs[4] = avoidLocs[4].concat(target.room.mineral.pos);
        }
        const safeSpots = this.findSafeLocation(shootPositions, avoidLocs);
        _.forEach(safeSpots, (distanceArray, hostilesIndex) => distanceArray.forEach(spot => Visualizer.marker(spot, { color: StrongholdOverlord_1.numberToColor(hostilesIndex), frames: 2 })));
        if (safeSpots[0].length > 0) {
            const closestFirst = safeSpots[0].sort(((a, b) => this.bestRampartToAttackSortFunction(a, b, myCreep.pos)));
            return { attackPos: closestFirst[0], target: target };
        }
        else if (safeSpots[1].length > 0) {
            const range1Spots = safeSpots[1];
            const ramparts = target.room.ramparts;
            const posToRampartMap = new Map();
            for (const spot of range1Spots) {
                for (const rampart of ramparts) {
                    if (rampart.pos.isNearTo(spot)) {
                        const temp = posToRampartMap.get(spot);
                        posToRampartMap.set(spot, !!temp ? temp.concat([rampart]) : [rampart]);
                    }
                }
            }
            if (myCreep) {
                const orderedByBest = Array.from(posToRampartMap.keys()).filter(p => posToRampartMap.get(p) && posToRampartMap.get(p).length == 1).sort((a, b) => this.bestRampartToAttackSortFunction(a, b, myCreep.pos));
                for (const pos of orderedByBest) {
                    const res = this.findAttackingPositionAndTarget(posToRampartMap.get(pos)[0], range - 1, myCreep);
                    if (res) {
                        return res;
                    }
                }
            }
            else {
                for (const pos of posToRampartMap) {
                    const res = this.findAttackingPositionAndTarget(pos[1][0], range - 1, myCreep);
                    if (res) {
                        return res;
                    }
                }
            }
        }
        return;
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(3000) };
        }
        else {
            delete this.memory.target;
        }
    }
    bestRampartToAttackSortFunction(element1, element2, currentPos) {
        return element1.getRangeTo(currentPos) - element2.getRangeTo(currentPos);
    }
    findSafeLocation(locations, avoidLocationsAtDistance) {
        const locationToHostilesMapping = Array.from({ length: 8 }, () => []);
        locations.forEach(loc => {
            let count = 0;
            avoidLocationsAtDistance.forEach((avoidArray, distance) => {
                avoidArray.forEach(avoidPos => {
                    if (avoidPos.getRangeTo(loc) <= distance) {
                        count++;
                    }
                });
            });
            if (count < locationToHostilesMapping.length) {
                locationToHostilesMapping[count].push(loc);
            }
        });
        return locationToHostilesMapping;
    }
    get attackPos() {
        if (this._attackPos) {
            return this._attackPos;
        }
        if (this.memory.target && this.memory.attackingPosition) {
            this._attackPos = posFromReadableName(this.memory.attackingPosition);
            return this._attackPos;
        }
    }
    handleKiller(killer) {
        if (Game.time % 15 == 0) {
            log.info(`Stronghold Killer ${killer.print} for ${this.print} in room ${killer.room.print}`);
        }
        if (this.room && killer.pos.roomName == this.pos.roomName) {
            if (this.directive.core && !this.memory.target) {
                const before = Game.cpu.getUsed();
                const targetingInfo = this.resetAttacking(this.directive.core, 3, killer);
                log.info(`CPU used for stronghold is ${Game.cpu.getUsed() - before}`);
            }
        }
        killer.heal(killer);
        if (killer.pos.roomName != this.pos.roomName) {
            killer.goToRoom(this.directive.pos.roomName);
        }
        if (killer.hits / killer.hitsMax < StrongholdOverlord_1.settings.retreatHitsPercent) {
            killer.flee([this.directive.pos].concat(killer.room.hostiles.map(sk => sk.pos)));
        }
        const unprotectedHostiles = killer.room.hostiles.filter(hostile => hostile.pos.getRangeTo(killer.pos)
            <= 3 && !hostile.inRampart);
        if (unprotectedHostiles.length > 0) {
            killer.rangedAttack(unprotectedHostiles[0]);
            return;
        }
        if (this.memory.attackingPosition) {
            const attackPos = posFromReadableName(this.memory.attackingPosition);
            if (!attackPos || !killer.pos.isEqualTo(attackPos)) {
                let avoids = [];
                if (this.directive.room) {
                    avoids = avoids.concat(_.flatten(this.directive.room.sourceKeepers.map(source => source.pos.getPositionsInRange(3, false, false))));
                    avoids = avoids.concat(_.flatten(this.directive.room.ramparts.map(ramparts => ramparts.pos.neighbors)));
                    if (this.directive.room.mineral) {
                        avoids = avoids.concat(this.directive.room.mineral.pos.getPositionsInRange(4, false, false));
                    }
                    avoids.forEach(av => Visualizer.circle(av));
                    killer.goTo(attackPos, { pathOpts: { obstacles: avoids } });
                }
            }
        }
        if (killer.pos.roomName == this.directive.pos.roomName) {
            if (this.target) {
                const res = killer.rangedAttack(this.target);
                if (res == ERR_INVALID_TARGET) {
                }
            }
            else {
                killer.goTo(this.pos);
                killer.rangedMassAttack();
            }
        }
    }
    static numberToColor(colorNumber) {
        switch (colorNumber) {
            case 0:
                return 'green';
            case 1:
                return 'yellow';
            case 2:
                return 'orange';
            default:
                return 'red';
        }
    }
    init() {
        if (this.memory.attackingPosition) {
            const attackPos = posFromReadableName(this.memory.attackingPosition);
            if (!!attackPos) {
                Visualizer.marker(attackPos, 'white');
            }
        }
        if (this.memory.target && Game.getObjectById(this.memory.target.id)) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                Visualizer.marker(target.pos, 'black');
            }
        }
        if (this.directive.memory.state >= 3) {
            return;
        }
        let setup;
        switch (this.directive.memory.strongholdLevel) {
            case 5:
                return;
            case 4:
                return;
            case 3:
                setup = CombatSetups.strongholdKiller['3'];
                break;
            case 2:
                setup = CombatSetups.strongholdKiller['2'];
                break;
            case 1:
                setup = CombatSetups.strongholdKiller['1'];
                break;
            case 0:
                return;
            default:
                return;
        }
    }
    resetAttacking(ultimateGoal, maxRange, myCreep) {
        const targetingInfo = this.findAttackingPositionAndTarget(ultimateGoal, 3, myCreep);
        if (targetingInfo) {
            this.target = targetingInfo.target;
            this.memory.attackingPosition = targetingInfo.attackPos.readableName;
        }
        return targetingInfo;
    }
    run() {
        const avoids = [];
        this.autoRun(this.strongholdKillers, killer => this.handleKiller(killer));
    }
};
StrongholdOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
StrongholdOverlord = StrongholdOverlord_1 = __decorate([
    profile
], StrongholdOverlord);

let DismantleOverlord = class DismantleOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.tasks.dismantle) {
        super(directive, 'dismantle', priority);
        this.directive = directive;
        this.dismantlers = this.zerg(Roles.dismantler);
    }
    init() {
        const MAX_DISMANTLERS = 2;
        let setup;
        if (!!this.directive.memory.attackInsteadOfDismantle) {
            setup = CombatSetups.dismantlers.attackDismantlers;
        }
        else {
            setup = CombatSetups.dismantlers.default;
        }
        setup = CombatSetups.dismantlers.default;
        const dismantlingParts = setup.getBodyPotential(!!this.directive.memory.attackInsteadOfDismantle
            ? ATTACK : WORK, this.colony);
        const dismantlingPower = dismantlingParts * (!!this.directive.memory.attackInsteadOfDismantle
            ? ATTACK_POWER : DISMANTLE_POWER);
        const tripDistance = Pathing.distance((this.colony).pos, this.directive.pos) || 0;
        const dismantleLifetimePower = (CREEP_LIFE_TIME - tripDistance) * dismantlingPower;
        if (this.directive.room && this.target && !this.directive.memory.numberSpots) {
            this.directive.getDismantleSpots(this.target.pos);
        }
        const nearbySpots = this.directive.memory.numberSpots != undefined ? this.directive.memory.numberSpots : 1;
        const dismantleNeeded = Math.ceil((this.target ? this.target.hits : 50000) / dismantleLifetimePower);
        const numDismantlers = Math.min(nearbySpots, MAX_DISMANTLERS, dismantleNeeded);
        this.wishlist(numDismantlers, setup);
    }
    runDismantler(dismantler) {
        if (!dismantler.inSameRoomAs(this.directive)) {
            const goal = this.target || this.directive;
            dismantler.goTo(goal, { pathOpts: { avoidSK: true } });
        }
        else {
            if (!this.target) {
                if (this.directive.memory.targetId) {
                    this.target = Game.getObjectById(this.directive.memory.targetId.toString()) || undefined;
                }
                this.target = this.target || this.directive.getTarget();
                if (!this.target) {
                    log.error(`No target found for ${this.directive.print}`);
                }
            }
            else {
                const res = !!this.directive.memory.attackInsteadOfDismantle ? dismantler.attack(this.target)
                    : dismantler.dismantle(this.target);
                if (res == ERR_NOT_IN_RANGE) {
                    const ret = dismantler.goTo(this.target, {});
                }
                else if (res == ERR_NO_BODYPART) {
                }
            }
        }
    }
    run() {
        this.reassignIdleCreeps(Roles.dismantler);
        for (const dismantler of this.dismantlers) {
            if (dismantler.hasValidTask) {
                dismantler.run();
            }
            else {
                if (dismantler.needsBoosts) {
                    this.handleBoosting(dismantler);
                }
                else {
                    this.runDismantler(dismantler);
                }
            }
        }
        for (const dismantler of this.dismantlers) {
            this.runDismantler(dismantler);
        }
    }
};
DismantleOverlord = __decorate([
    profile
], DismantleOverlord);

let DirectiveModularDismantle = class DirectiveModularDismantle extends Directive {
    constructor(flag, onlyKillRampart = false, additionalTargets) {
        super(flag);
        this.memory.onlyKillRampart = onlyKillRampart || this.flag.name.includes('rampart');
        this.memory.boost = this.memory.boost || this.flag.name.includes('boost');
        if (this.flag.room) {
            if (!this.memory.targetId) {
                const target = this.getTarget();
                this.memory.targetId = target ? target.id : undefined;
            }
            this.memory.additionalTargets = additionalTargets;
            if (!this.memory.numberSpots) {
                const spots = this.getDismantleSpots(this.flag.pos);
                if (spots) {
                    this.memory.numberSpots = spots.length;
                }
            }
        }
    }
    spawnMoarOverlords() {
        this.overlords.dismantle = new DismantleOverlord(this);
    }
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructureTypes = this.memory.onlyKillRampart ? [STRUCTURE_RAMPART] : AttackStructurePriorities;
        const targets = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structureType of targetedStructureTypes) {
            const correctTargets = targets.filter(target => {
                if (target.structureType == structureType) {
                    return target;
                }
                else if (target.structureType == STRUCTURE_INVADER_CORE) {
                    this.memory.attackInsteadOfDismantle = true;
                    return target;
                }
            });
            if (correctTargets.length > 0) {
                return correctTargets[0];
            }
        }
    }
    getDismantleSpots(target) {
        const nearbySpots = target.availableNeighbors(true);
        if (target.room && target.room.creeps.length > 0) {
            const startingCreep = target.room.creeps.filter(creep => creep.my)[0];
            if (!!startingCreep) {
                const obstacles = _.filter(target.room.structures, s => !s.isWalkable);
                return _.filter(nearbySpots, spot => Pathing.isReachable(startingCreep.pos, spot, obstacles));
            }
        }
    }
    init() {
        let hits = '???';
        const target = this.getTarget();
        hits = target ? (target.hits / 1000).toString() + 'K' : hits;
        this.alert(`Dismantling: ${hits}`);
    }
    run() {
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'yellow' });
    }
};
DirectiveModularDismantle.directiveName = 'modularDismantle';
DirectiveModularDismantle.color = COLOR_GREY;
DirectiveModularDismantle.secondaryColor = COLOR_CYAN;
DirectiveModularDismantle = __decorate([
    profile
], DirectiveModularDismantle);

var DirectiveStronghold_1;
const STRONGHOLD_SETUPS = {
    5: 9,
    4: 4,
    3: 2,
    2: 1,
    1: 0,
};
let DirectiveStronghold = DirectiveStronghold_1 = class DirectiveStronghold extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= DirectiveStronghold_1.requiredRCL);
        this.memory.state = this.memory.state || 0;
        if (this.core) {
            this.memory.strongholdLevel = this.core.level;
        }
        this.memory.waveCount = this.memory.waveCount || 0;
    }
    spawnMoarOverlords() {
        if (this.memory.state < 3) {
        }
        if (this.memory.state > 0 && this.memory.state <= 4) {
            this.overlords.strongholdKiller = new StrongholdOverlord(this);
        }
    }
    get core() {
        if (this.room) {
            return this._core || this.room.find(FIND_HOSTILE_STRUCTURES)
                .filter(struct => struct.structureType == STRUCTURE_INVADER_CORE)[0];
        }
    }
    getResourcePickupLocations() {
        if (this.room) {
            let returns = [];
            const containers = this.room.containers;
            const ruins = this.room.ruins;
            if (containers) {
                returns = returns.concat(containers.filter(container => container.pos.getRangeTo(this.pos) < 5 && _.sum(container.store) > 0));
            }
            if (ruins) {
                returns = returns.concat(ruins.filter(ruin => ruin.pos.getRangeTo(this.pos) <= 3 && _.sum(ruin.store) > 0));
            }
            return returns;
        }
    }
    manageState() {
        const currentState = this.memory.state;
        if (this.core && this.core.level == 5) {
        }
        if (this.room && this.core && currentState == 0) {
            if (!this.core.ticksToDeploy || this.core.ticksToDeploy < 150) {
                this.memory.state = 1;
            }
        }
        else if (this.room && this.memory.state == 0) {
        }
        else if (this.pos.isVisible && !this.core && this.pos.lookFor(LOOK_RUINS).length > 0) {
            this.memory.state = 4;
            if (Game.time % 50 == 0) {
                this.handleLooting();
            }
        }
        else if (this.pos.isVisible && !this.core && this.pos.lookFor(LOOK_RUINS).length == 0) {
            this.remove();
        }
    }
    handleLooting() {
        const lootSpots = this.getResourcePickupLocations();
        if (lootSpots && lootSpots.length > 0) {
            lootSpots.forEach(spot => {
                const isRamparted = spot.pos.lookFor(LOOK_STRUCTURES)
                    .filter(struct => struct.structureType == STRUCTURE_RAMPART).length > 0;
                if (isRamparted) {
                    DirectiveModularDismantle.createIfNotPresent(spot.pos, 'pos');
                }
                else {
                    DirectiveHaul.createIfNotPresent(spot.pos, 'pos');
                }
            });
            const openingToCore = this.pos.getPositionAtDirection(TOP);
            const isRamparted = openingToCore.lookFor(LOOK_STRUCTURES)
                .filter(struct => struct.structureType == STRUCTURE_RAMPART).length > 0;
            if (isRamparted) {
                DirectiveModularDismantle.createIfNotPresent(openingToCore, 'pos');
            }
        }
    }
    checkStrongholdUnitComposition(defenders) {
    }
    handleL5() {
        if (!this.pos.isVisible || !this.core || Game.time % 5 != 0) {
            return;
        }
        if (this.core.ticksToDeploy) {
            log.info(`Stronghold is still deploying! ${this.print}`);
            return;
        }
        const ramparts = this.core.room.ramparts;
        if (ramparts.length == 0 || ramparts[0].ticksToDecay < NUKE_LAND_TIME + 10000) {
            log.info(`Stronghold decaying too soon! ${this.print}`);
            return;
        }
        const bestTarget = this.pos.getPositionAtDirection(TOP_RIGHT);
        const nukes = this.core.room.find(FIND_NUKES);
        const nukesPrepped = DirectiveNukeTarget.isPresent(this.core.room.name);
        if (nukes.length < 2 && !nukesPrepped) {
            log.alert(`Nuking Stronghold! ${this.print}`);
            const res1 = DirectiveNukeTarget.create(bestTarget, { memory: { maxLinearRange: 10, pathNotRequired: true } });
            const res2 = DirectiveNukeTarget.create(bestTarget, { memory: { maxLinearRange: 10, pathNotRequired: true } });
            return res1 == OK && res2 == OK;
        }
        else {
            const strongholdDefenders = this.core.pos.findInRange(FIND_HOSTILE_CREEPS, 4);
            const reinforcers = strongholdDefenders.filter(creep => creep.body.find(bodyPart => bodyPart.type == WORK) != undefined);
            if (reinforcers.length >= nukes.length - 1) {
                log.alert(`Launching additional nuke against Stronghold with reinforcers ${reinforcers.length}! ${this.print}`);
                return DirectiveNukeTarget.create(bestTarget, { memory: { maxLinearRange: 11, pathNotRequired: true } });
            }
        }
    }
    manageDirectives() {
    }
    lootPositions() {
        this.pos.findInRange(FIND_STRUCTURES, 4);
    }
    init() {
        let alert;
        alert = `Stronghold ${this.memory.strongholdLevel} is state ${this.memory.state}`;
        this.alert(alert);
    }
    run() {
        if (this.colony.commandCenter && this.colony.commandCenter.observer) {
            this.colony.commandCenter.requestRoomObservation(this.pos.roomName);
        }
        const duration = Game.time - (this.memory["T"] || Game.time);
        if (duration % 50000 == 0) {
            log.notify(`DirectiveStronghold ${this.print} in ${this.pos.roomName} has been active for ${duration} ticks`);
        }
        this.manageState();
    }
};
DirectiveStronghold.directiveName = 'stronghold';
DirectiveStronghold.color = COLOR_ORANGE;
DirectiveStronghold.secondaryColor = COLOR_PURPLE;
DirectiveStronghold.requiredRCL = 7;
DirectiveStronghold = DirectiveStronghold_1 = __decorate([
    profile
], DirectiveStronghold);

const EVACUATE_STATE_TIMEOUT = 25000;
let DirectiveTerminalEvacuateState = class DirectiveTerminalEvacuateState extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.isEvacuating = true;
    }
    spawnMoarOverlords() {
    }
    init() {
        if (this.colony && this.colony.terminal) {
            for (const resource of RESOURCES_ALL) {
                if (resource == RESOURCE_ENERGY) {
                    Overmind.terminalNetwork.exportResource(this.colony, resource, {
                        target: 10000,
                        tolerance: 2000,
                        surplus: 15000,
                    });
                }
                else {
                    Overmind.terminalNetwork.exportResource(this.colony, resource);
                }
            }
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: evacuation terminal state active!`);
        }
        this.alert('Evacuation terminal state active!', NotifierPriority.High);
    }
    run() {
        if (!this.colony || !this.colony.terminal || !!this.colony.controller.safeMode
            || Game.time > (this.memory["T"] || 0) + EVACUATE_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalEvacuateState.directiveName = 'evacuateState';
DirectiveTerminalEvacuateState.color = COLOR_BROWN;
DirectiveTerminalEvacuateState.secondaryColor = COLOR_RED;
DirectiveTerminalEvacuateState = __decorate([
    profile
], DirectiveTerminalEvacuateState);

function DirectiveWrapper(flag) {
    switch (flag.color) {
        case COLOR_PURPLE:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveOutpost(flag);
                case COLOR_YELLOW:
                    return new DirectiveSKOutpost(flag);
                case COLOR_WHITE:
                    return new DirectiveIncubate(flag);
                case COLOR_GREY:
                    return new DirectiveColonize(flag);
                case COLOR_BLUE:
                    return new DirectiveColonizeShard(flag);
                case COLOR_ORANGE:
                    return new DirectiveClearRoom(flag);
                case COLOR_RED:
                    return new DirectivePoisonRoom(flag);
                case COLOR_BROWN:
                    return undefined;
            }
            break;
        case COLOR_RED:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveSwarmDestroy(flag);
                case COLOR_CYAN:
                    return new DirectivePairDestroy(flag);
                case COLOR_PURPLE:
                    return new DirectiveControllerAttack(flag);
                case COLOR_WHITE:
                    return new DirectiveHarass(flag);
            }
            break;
        case COLOR_BLUE:
            switch (flag.secondaryColor) {
                case COLOR_BLUE:
                    return new DirectiveGuard(flag);
                case COLOR_RED:
                    return new DirectiveOutpostDefense(flag);
                case COLOR_PURPLE:
                    return new DirectiveInvasionDefense(flag);
            }
            break;
        case COLOR_ORANGE:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveBootstrap(flag);
                case COLOR_BLUE:
                    return new DirectiveNukeResponse(flag);
                case COLOR_RED:
                    return new DirectiveNukeTarget(flag);
                case COLOR_PURPLE:
                    return new DirectiveStronghold(flag);
                case COLOR_WHITE:
                    return new DirectivePortalScout(flag);
                case COLOR_YELLOW:
                    return new DirectiveRemoteUpgrade(flag);
            }
            break;
        case COLOR_YELLOW:
            switch (flag.secondaryColor) {
                case COLOR_YELLOW:
                    return new DirectiveHarvest(flag);
                case COLOR_CYAN:
                    return new DirectiveExtract(flag);
                case COLOR_BLUE:
                    return new DirectiveHaul(flag);
                case COLOR_RED:
                    return new DirectivePowerMine(flag);
            }
            break;
        case COLOR_BROWN:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveTerminalEvacuateState(flag);
                case COLOR_YELLOW:
                    return new DirectiveTerminalRebuildState(flag);
            }
            break;
        case COLOR_GREY:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveTargetSiege(flag);
                case COLOR_YELLOW:
                    return new DirectiveDismantle(flag);
                case COLOR_CYAN:
                    return new DirectiveModularDismantle(flag);
            }
            break;
        case COLOR_WHITE:
            switch (flag.secondaryColor) {
                case COLOR_GREEN:
                    return new DirectiveRPHatchery(flag);
                case COLOR_BLUE:
                    return new DirectiveRPCommandCenter(flag);
                case COLOR_RED:
                    return new DirectiveRPBunker(flag);
            }
            break;
        case COLOR_GREEN:
            switch (flag.secondaryColor) {
                case COLOR_GREEN:
                    return new DirectiveDrop(flag);
            }
            break;
        case COLOR_CYAN:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveBaseOperator(flag);
            }
            break;
    }
}

var TerminalNetworkV2_1;
const getDefaultTerminalNetworkMemory = () => ({});
const getDefaultTerminalNetworkStats = () => ({
    assets: {},
    fractionalEnergyTransferCost: 0.25,
    incomingResources: {},
    outgoingResources: {},
    sendCosts: {},
    terminals: {
        avgCooldown: {},
        overload: {},
    },
    states: {
        activeProviders: {},
        passiveProviders: {},
        equilibriumNodes: {},
        passiveRequestors: {},
        activeRequestors: {},
    }
});
const DEFAULT_TARGET = 2 * LAB_MINERAL_CAPACITY + 1000;
const DEFAULT_SURPLUS = 15 * LAB_MINERAL_CAPACITY;
const ENERGY_SURPLUS = 500000;
const DEFAULT_TOLERANCE = LAB_MINERAL_CAPACITY / 3;
const THRESHOLDS_DEFAULT = {
    target: DEFAULT_TARGET,
    surplus: DEFAULT_SURPLUS,
    tolerance: DEFAULT_TOLERANCE,
};
const THRESHOLDS_BOOSTS_T3 = {
    target: DEFAULT_TARGET + 10 * LAB_MINERAL_CAPACITY,
    tolerance: DEFAULT_TOLERANCE + 10 * LAB_MINERAL_CAPACITY,
    surplus: 75000,
};
const THRESHOLDS_BOOSTS_T2 = {
    target: DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY,
    tolerance: DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY,
    surplus: 25000,
};
const THRESHOLDS_BOOSTS_T1 = {
    target: DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY,
    tolerance: DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY,
    surplus: 25000,
};
const THREHSOLDS_INTERMEDIATE_REACTANTS = {
    target: LAB_MINERAL_CAPACITY + 1000,
    tolerance: LAB_MINERAL_CAPACITY / 3,
    surplus: 3 * LAB_MINERAL_CAPACITY,
};
const THRESHOLDS_GHODIUM = {
    target: 10000,
    tolerance: 5000,
    surplus: 20000,
};
const THRESHOLDS_DONT_WANT = {
    target: 0,
    surplus: 0,
    tolerance: 0,
};
const THRESHOLDS_DONT_CARE = {
    target: 0,
    surplus: undefined,
    tolerance: 0,
};
const THRESHOLDS_POWER = {
    target: 2500,
    surplus: undefined,
    tolerance: 2500,
};
const THRESHOLDS_OPS = {
    target: 2500,
    surplus: undefined,
    tolerance: 2500,
};
function getThresholds(resource) {
    if (resource == RESOURCE_POWER) {
        return THRESHOLDS_POWER;
    }
    if (resource == RESOURCE_OPS) {
        return THRESHOLDS_OPS;
    }
    if (Abathur.isBaseMineral(resource)) {
        return THRESHOLDS_DEFAULT;
    }
    if (Abathur.isIntermediateReactant(resource)) {
        if (resource == RESOURCE_HYDROXIDE) {
            return THRESHOLDS_DEFAULT;
        }
        else {
            return THREHSOLDS_INTERMEDIATE_REACTANTS;
        }
    }
    if (resource == RESOURCE_GHODIUM) {
        return THRESHOLDS_GHODIUM;
    }
    if (Abathur.isBoost(resource)) {
        const tier = Abathur.getBoostTier(resource);
        if (tier == 'T3') {
            return THRESHOLDS_BOOSTS_T3;
        }
        else if (tier == 'T2') {
            return THRESHOLDS_BOOSTS_T2;
        }
        else if (tier == 'T1') {
            return THRESHOLDS_BOOSTS_T1;
        }
    }
    if (Abathur.isMineralOrCompound(resource)) {
        return THRESHOLDS_DEFAULT;
    }
    if (Abathur.isDepositResource(resource)) {
        return THRESHOLDS_DONT_CARE;
    }
    if (Abathur.isCommodity(resource)) {
        return THRESHOLDS_DONT_CARE;
    }
    log.error(`Shouldn't reach here! Unhandled resource ${resource} in getThresholds()!`);
    return THRESHOLDS_DONT_CARE;
}
const ALL_THRESHOLDS = _.object(RESOURCES_ALL_EXCEPT_ENERGY, _.map(RESOURCES_ALL_EXCEPT_ENERGY, res => getThresholds(res)));
const _resourcePrioritiesOrdered = [
    ...BOOSTS_T3,
    RESOURCE_OPS,
    ...BOOSTS_T2,
    ...BOOSTS_T1,
    ...INTERMEDIATE_REACTANTS,
    ...BASE_RESOURCES,
    RESOURCE_POWER,
    RESOURCE_ENERGY
];
const _resourcePrioritiesEverythingElse = _.filter(RESOURCES_ALL, res => !_resourcePrioritiesOrdered.includes(res));
const RESOURCE_EXCHANGE_ORDER = [..._resourcePrioritiesOrdered,
    ..._resourcePrioritiesEverythingElse];
const _resourceExchangePrioritiesLookup = _.zipObject(RESOURCE_EXCHANGE_ORDER, _.map(RESOURCE_EXCHANGE_ORDER, res => _.indexOf(RESOURCE_EXCHANGE_ORDER, res)));
const EMPTY_COLONY_TIER = _.zipObject(RESOURCES_ALL, _.map(RESOURCES_ALL, i => []));
let TerminalNetworkV2 = TerminalNetworkV2_1 = class TerminalNetworkV2 {
    constructor() {
        this.name = 'TerminalNetwork';
        this.colonies = [];
        this.refresh();
    }
    refresh() {
        this.colonyThresholds = {};
        this.colonyLockedAmounts = {};
        this._energyThresholds = undefined;
        this.colonyStates = {};
        this._colonyStatesAssigned = false;
        this.activeProviders = {};
        this.passiveProviders = {};
        this.equilibriumNodes = {};
        this.passiveRequestors = {};
        this.activeRequestors = {};
        this.assets = {};
        this.terminalOverload = {};
        this.notifications = [];
        this.memory = Mem.wrap(Memory.Overmind, 'terminalNetwork', getDefaultTerminalNetworkMemory);
        this.stats = Mem.wrap(Memory.stats.persistent, 'terminalNetwork', getDefaultTerminalNetworkStats);
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert('TerminalNetwork:', args);
        }
    }
    addColony(colony) {
        if (!(colony.terminal && colony.terminal.my && colony.level >= 6)) {
            log.error(`Cannot add colony ${colony.print} to terminal network!`);
        }
        else {
            this.colonies.push(colony);
        }
    }
    getAssets() {
        if (_.isEmpty(this.assets)) {
            this.assets = mergeSum(_.map(this.colonies, colony => colony.assets));
        }
        return this.assets;
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    transfer(sender, receiver, resourceType, amount, description) {
        const cost = Game.market.calcTransactionCost(amount, sender.room.name, receiver.room.name);
        const response = sender.send(resourceType, amount, receiver.room.name, description);
        if (response == OK) {
            let msg;
            const floorAmt = Math.floor(amount);
            if (description == 'provide') {
                msg = `${printRoomName(sender.room.name, true)} ${rightArrow} ${floorAmt} ${resourceType} ` +
                    `${rightArrow} ${printRoomName(receiver.room.name, true)} `;
            }
            else if (description == 'request') {
                msg = `${printRoomName(receiver.room.name, true)} ${leftArrow} ${floorAmt} ${resourceType} ` +
                    `${leftArrow} ${printRoomName(sender.room.name, true)} `;
            }
            else {
                msg = `${printRoomName(sender.room.name, true)} ${rightArrow} ${floorAmt} ${resourceType} ` +
                    `${rightArrow} ${printRoomName(receiver.room.name, true)} `;
                if (description) {
                    msg += `(${description})`;
                }
            }
            this.notify(msg);
        }
        else {
            log.warning(`Could not send ${amount} ${resourceType} from ${sender.room.print} to ` +
                `${receiver.room.print}! Response: ${response}`);
            if (response == ERR_NOT_ENOUGH_RESOURCES || response == ERR_TIRED) {
                this.terminalOverload[sender.room.name] = true;
            }
        }
        return response;
    }
    getRemainingSpace(colony, includeFactoryCapacity = false) {
        let totalAssets = _.sum(colony.assets);
        if (colony.storage && _.sum(colony.storage.store) > STORAGE_CAPACITY) {
            totalAssets -= (_.sum(colony.storage.store) - STORAGE_CAPACITY);
        }
        const roomCapacity = (colony.terminal ? TERMINAL_CAPACITY : 0) +
            (colony.storage ? STORAGE_CAPACITY : 0) +
            (colony.factory && includeFactoryCapacity ? FACTORY_CAPACITY : 0);
        return roomCapacity - totalAssets;
    }
    getEnergyThresholds() {
        if (!this._energyThresholds) {
            const nonExceptionalColonies = _.filter(this.colonies, colony => colony.storage
                && !(this.colonyThresholds[colony.name] && this.colonyThresholds[colony.name][RESOURCE_ENERGY]));
            const avgEnergy = _.sum(nonExceptionalColonies, colony => colony.assets.energy) /
                nonExceptionalColonies.length;
            this._energyThresholds = {
                target: avgEnergy,
                surplus: ENERGY_SURPLUS,
                tolerance: avgEnergy / 5,
            };
        }
        return this._energyThresholds;
    }
    getColonyState(colony, resource) {
        const { target, surplus, tolerance } = this.thresholds(colony, resource);
        const amount = colony.assets[resource];
        if ((surplus != undefined && amount > surplus)
            || (amount > target + tolerance
                && this.getRemainingSpace(colony) < TerminalNetworkV2_1.settings.minColonySpace)) {
            return 5;
        }
        if ((surplus != undefined ? surplus : Infinity) >= amount && amount > target + tolerance) {
            return 4;
        }
        if (target + tolerance >= amount && amount >= Math.max(target - tolerance, 0)) {
            return 3;
        }
        if (amount < Math.max(target - tolerance, 0)) {
            return 2;
        }
        log.error(`Shouldn't reach this part of TerminalNetwork code!`);
        return 0;
    }
    thresholds(colony, resource) {
        if (this.colonyThresholds[colony.name] && this.colonyThresholds[colony.name][resource]) {
            return this.colonyThresholds[colony.name][resource];
        }
        else {
            if (resource == RESOURCE_ENERGY) {
                return this.getEnergyThresholds();
            }
            else {
                return ALL_THRESHOLDS[resource];
            }
        }
    }
    lockedAmount(colony, resource) {
        if (this.colonyLockedAmounts[colony.name] && this.colonyLockedAmounts[colony.name][resource]) {
            return this.colonyLockedAmounts[colony.name][resource];
        }
        else {
            return 0;
        }
    }
    requestResource(requestor, resource, totalAmount, tolerance = 0) {
        if (PHASE != 'init')
            log.error(`TerminalNetwork.requestResource must be called in the init() phase!`);
        if (requestor.assets[resource] >= totalAmount) {
            log.error(`TerminalNetwork.requestResource() called for ${requestor.print} requesting ${totalAmount} ` +
                `of ${resource}, but colony already has ${requestor.assets[resource]} amount!`);
            return;
        }
        if (!this.colonyThresholds[requestor.name]) {
            this.colonyThresholds[requestor.name] = {};
        }
        if (this.colonyThresholds[requestor.name][resource] != undefined) {
            log.warning(`TerminalNetwork.colonyThresholds[${requestor.name}][${resource}] already set to:` +
                `${this.colonyThresholds[requestor.name][resource]}; overriding previous request!`);
        }
        this.colonyThresholds[requestor.name][resource] = {
            target: totalAmount,
            surplus: undefined,
            tolerance: tolerance,
        };
        this.colonyStates[requestor.name][resource] = 1;
    }
    lockResource(requestor, resource, lockAmount) {
        if (PHASE != 'init')
            log.error(`TerminalNetwork.lockResource() must be called in the init() phase!`);
        if (!this.colonyLockedAmounts[requestor.name]) {
            this.colonyLockedAmounts[requestor.name] = {};
        }
        const alreadyLockedAmount = this.colonyLockedAmounts[requestor.name][resource] || 0;
        const newLockAmount = alreadyLockedAmount + lockAmount;
        if (requestor.assets[resource] < newLockAmount) {
            log.warning(`TerminalNetwork.lockResource() called for ${requestor.print} locking ${lockAmount} ` +
                `(total: ${newLockAmount}) of ${resource}, but colony only has ` +
                `${requestor.assets[resource]} amount!`);
        }
        this.colonyLockedAmounts[requestor.name][resource] = newLockAmount;
    }
    exportResource(provider, resource, thresholds = THRESHOLDS_DONT_WANT) {
        if (PHASE != 'init')
            log.error(`TerminalNetwork.exportResource must be called in the init() phase!`);
        if (this.colonyThresholds[provider.name] && this.colonyThresholds[provider.name][resource] != undefined) {
            log.warning(`TerminalNetwork.colonyThresholds[${provider.name}][${resource}] already set to:` +
                `${this.colonyThresholds[provider.name][resource]}; overriding previous export!`);
        }
        if (!this.colonyThresholds[provider.name]) {
            this.colonyThresholds[provider.name] = {};
        }
        this.colonyThresholds[provider.name][resource] = thresholds;
    }
    canObtainResource(requestor, resource, totalAmount) {
        if (PHASE != 'run') {
            log.error(`TerminalNetwork.canObtainResource() must be called in the run() phase!`);
            return false;
        }
        const requestAmount = totalAmount - requestor.assets[resource];
        if (requestAmount <= 0) {
            log.error(`TerminalNetwork.canObtainResource() called when you already have the resource! :thonk:`);
            return true;
        }
        const opts = {
            allowDivvying: false,
            takeFromColoniesBelowTarget: false,
            requestType: 'active',
            allowMarketBuy: Game.market.credits > TraderJoe.settings.market.credits.canBuyAbove,
            receiveOnlyOncePerTick: false,
            complainIfUnfulfilled: true,
            dryRun: true,
        };
        this.assignColonyStates();
        const prioritizedPartners = [this.activeProviders,
            this.passiveProviders,
            this.equilibriumNodes,
            this.passiveRequestors];
        const partnerSets = _.map(prioritizedPartners, partners => partners[resource] || []);
        const success = this.handleRequestInstance(requestor, resource, requestAmount, partnerSets, opts);
        return success;
    }
    init() {
        this.assets = this.getAssets();
        for (const colony of this.colonies) {
            this.colonyStates[colony.name] = {};
        }
    }
    assignColonyStates() {
        if (this._colonyStatesAssigned) {
            return;
        }
        for (const colony of this.colonies) {
            for (const resource of RESOURCE_EXCHANGE_ORDER) {
                if (!this.colonyThresholds[colony.name]) {
                    this.colonyThresholds[colony.name] = {};
                }
                if (!this.colonyStates[colony.name][resource]) {
                    this.colonyStates[colony.name][resource] = this.getColonyState(colony, resource);
                }
                switch (this.colonyStates[colony.name][resource]) {
                    case 5:
                        if (this.activeProviders[resource] == undefined)
                            this.activeProviders[resource] = [];
                        this.activeProviders[resource].push(colony);
                        break;
                    case 4:
                        if (this.passiveProviders[resource] == undefined)
                            this.passiveProviders[resource] = [];
                        this.passiveProviders[resource].push(colony);
                        break;
                    case 3:
                        if (this.equilibriumNodes[resource] == undefined)
                            this.equilibriumNodes[resource] = [];
                        this.equilibriumNodes[resource].push(colony);
                        break;
                    case 2:
                        if (this.passiveRequestors[resource] == undefined)
                            this.passiveRequestors[resource] = [];
                        this.passiveRequestors[resource].push(colony);
                        break;
                    case 1:
                        if (this.activeRequestors[resource] == undefined)
                            this.activeRequestors[resource] = [];
                        this.activeRequestors[resource].push(colony);
                        break;
                    case 0:
                        log.error(`TN_STATE.error type encountered!`);
                        break;
                    default:
                        log.error(`Should not be here! colony state is ${this.colonyStates[colony.name][resource]}`);
                        break;
                }
            }
        }
        _.forEach(this.activeRequestors, (cols, resource) => this.activeRequestors[resource] = _.shuffle(cols));
        _.forEach(this.passiveRequestors, (cols, resource) => this.passiveRequestors[resource] = _.shuffle(cols));
        _.forEach(this.equilibriumNodes, (cols, resource) => this.equilibriumNodes[resource] = _.shuffle(cols));
        _.forEach(this.passiveProviders, (cols, resource) => this.passiveProviders[resource] = _.shuffle(cols));
        _.forEach(this.activeProviders, (cols, resource) => this.activeProviders[resource] = _.shuffle(cols));
        this._colonyStatesAssigned = true;
    }
    getBestSenderColony(resource, amount, colony, partners) {
        if (partners.length == 0) {
            log.error(`Passed an empty list of sender partners!`);
        }
        const K = 2;
        const BIG_COST = 2000;
        return maxBy(partners, partner => {
            const sendCost = Game.market.calcTransactionCost(amount, partner.name, colony.name);
            const avgCooldown = this.stats.terminals.avgCooldown[partner.name] || 0;
            const score = -1 * (sendCost) * (K + sendCost / BIG_COST + avgCooldown);
            return score;
        });
    }
    handleRequestInstance(colony, resource, requestAmount, partnerSets, opts) {
        const originalRequestAmount = requestAmount;
        if (resource == RESOURCE_ENERGY) {
            requestAmount = Math.min(requestAmount, TerminalNetworkV2_1.settings.maxEnergySendAmount);
        }
        else {
            requestAmount = Math.min(requestAmount, TerminalNetworkV2_1.settings.maxResourceSendAmount);
        }
        for (const partners of partnerSets) {
            let validPartners = _.filter(partners, partner => partner.assets[resource] - requestAmount - this.lockedAmount(partner, resource)
                >= this.thresholds(partner, resource).target);
            if (validPartners.length == 0) {
                validPartners = _.filter(partners, partner => partner.assets[resource] - requestAmount - this.lockedAmount(partner, resource) >=
                    this.thresholds(partner, resource).target - this.thresholds(colony, resource).tolerance);
            }
            if (validPartners.length == 0 && opts.takeFromColoniesBelowTarget) {
                validPartners = _.filter(partners, partner => partner.assets[resource] - requestAmount - this.lockedAmount(partner, resource) > 0);
            }
            if (validPartners.length > 0) {
                const bestPartner = this.getBestSenderColony(resource, requestAmount, colony, validPartners);
                const lockedAmount = this.lockedAmount(bestPartner, resource);
                const thresholds = this.thresholds(bestPartner, resource);
                const sendTerm = bestPartner.terminal;
                const recvTerm = colony.terminal;
                const sendAmount = opts.takeFromColoniesBelowTarget
                    ? Math.min(requestAmount, sendTerm.store[resource], bestPartner.assets[resource] - lockedAmount)
                    : Math.min(requestAmount, sendTerm.store[resource], bestPartner.assets[resource]
                        - (thresholds.target - thresholds.tolerance) - lockedAmount);
                if (sendAmount <= 0) {
                    log.error(`Request from ${colony.print} to ${bestPartner.print} for ${sendAmount} ${resource}`);
                    return false;
                }
                if (!opts.dryRun) {
                    if (sendTerm.isReady) {
                        this.transfer(sendTerm, recvTerm, resource, sendAmount, `request`);
                    }
                    else {
                        this.terminalOverload[sendTerm.room.name] = true;
                    }
                }
                return true;
            }
        }
        if (opts.allowDivvying) {
            const MAX_SEND_REQUESTS = 3;
            const allPartners = _.flatten(partnerSets);
            let validPartners = _(allPartners)
                .filter(partner => partner.assets[resource] - this.lockedAmount(partner, resource)
                > this.thresholds(partner, resource).target)
                .sortBy(partner => partner.assets[resource]
                - this.lockedAmount(partner, resource)
                - this.thresholds(partner, resource).target)
                .take(MAX_SEND_REQUESTS).run();
            if (validPartners.length == 0 && opts.takeFromColoniesBelowTarget) {
                validPartners = _(allPartners)
                    .filter(partner => partner.assets[resource] - this.lockedAmount(partner, resource) > 0)
                    .sortBy(partner => partner.assets[resource] - this.lockedAmount(partner, resource))
                    .take(MAX_SEND_REQUESTS).run();
            }
            let remainingAmount = requestAmount;
            let sentSome = false;
            for (const partner of validPartners) {
                const sendTerm = partner.terminal;
                const recvTerm = colony.terminal;
                const amountPartnerCanSend = opts.takeFromColoniesBelowTarget
                    ? sendTerm.store[resource] - this.lockedAmount(partner, resource)
                    : sendTerm.store[resource] - this.lockedAmount(partner, resource)
                        - this.thresholds(partner, resource).target;
                let sendAmount = Math.min(amountPartnerCanSend, remainingAmount);
                if (resource == RESOURCE_ENERGY) {
                    const sendCost = Game.market.calcTransactionCost(sendAmount, colony.name, partner.name);
                    if (sendAmount + sendCost > sendTerm.store[resource]) {
                        sendAmount -= sendCost;
                    }
                }
                if (opts.dryRun) {
                    remainingAmount -= sendAmount;
                }
                else {
                    if (sendTerm.isReady) {
                        const ret = this.transfer(sendTerm, recvTerm, resource, sendAmount, `request`);
                        if (ret == OK) {
                            remainingAmount -= sendAmount;
                            sentSome = true;
                        }
                        else {
                            this.terminalOverload[sendTerm.room.name] = true;
                        }
                    }
                    else {
                        this.terminalOverload[sendTerm.room.name] = true;
                    }
                }
                if (remainingAmount <= 0) {
                    return true;
                }
            }
            if (sentSome) {
                return true;
            }
        }
        if (opts.allowMarketBuy) {
            if (resource == RESOURCE_ENERGY &&
                Game.market.credits < TraderJoe.settings.market.credits.canBuyEnergyAbove) {
                return false;
            }
            if (Abathur.isIntermediateReactant(resource) || resource == RESOURCE_GHODIUM) {
                return false;
            }
            if (Abathur.isBoost(resource)) {
                if (Game.market.credits < TraderJoe.settings.market.credits.canBuyBoostsAbove) {
                    return false;
                }
                const boostTier = Abathur.getBoostTier(resource);
                if (boostTier != 'T3' && !TraderJoe.settings.market.resources.allowBuyT1T2boosts) {
                    return false;
                }
            }
            if (opts.requestType == 'passive' && !Abathur.isBaseMineral(resource)) {
                return false;
            }
            const buyOpts = { dryRun: opts.dryRun };
            if (Abathur.isBaseMineral(resource) &&
                colony.assets[resource] < TerminalNetworkV2_1.settings.buyBaseMineralsDirectUnder) {
                if (opts.requestType == 'active') {
                    buyOpts.preferDirect = true;
                    buyOpts.ignorePriceChecksForDirect = true;
                    buyOpts.ignoreMinAmounts = true;
                }
                else if (opts.requestType == 'passive') {
                    buyOpts.preferDirect = false;
                    buyOpts.ignoreMinAmounts = false;
                }
                else {
                    log.error(`Need to specify active or passive request type request for ${resource}!`);
                }
            }
            const ret = Overmind.tradeNetwork.buy(colony.terminal, resource, originalRequestAmount, buyOpts);
            this.debug(`Buying ${requestAmount} ${resource} for ${colony.print} with opts=${JSON.stringify(buyOpts)}` +
                `from trade network (${ret})`);
            if (ret >= 0) {
                return true;
            }
        }
        return false;
    }
    handleProvideInstance(colony, resource, provideAmount, partnerSets, opts) {
        if (opts.allowPushToOtherRooms) {
            let sendAmount = provideAmount;
            if (colony.state.isEvacuating) {
                sendAmount = Math.min(provideAmount, TerminalNetworkV2_1.settings.maxEvacuateSendAmount);
            }
            else {
                if (resource == RESOURCE_ENERGY) {
                    sendAmount = Math.min(provideAmount, TerminalNetworkV2_1.settings.maxEnergySendAmount);
                }
                else {
                    sendAmount = Math.min(provideAmount, TerminalNetworkV2_1.settings.maxResourceSendAmount);
                }
            }
            for (const partners of partnerSets) {
                let validPartners = _.filter(partners, partner => partner.assets[resource] + sendAmount <= this.thresholds(partner, resource).target &&
                    this.getRemainingSpace(partner) - sendAmount >= TerminalNetworkV2_1.settings.minColonySpace);
                if (validPartners.length == 0) {
                    validPartners = _.filter(partners, partner => partner.assets[resource] + sendAmount <=
                        this.thresholds(partner, resource).target + this.thresholds(colony, resource).tolerance &&
                        this.getRemainingSpace(partner) - sendAmount >= TerminalNetworkV2_1.settings.minColonySpace);
                }
                if (validPartners.length == 0) {
                    validPartners = _.filter(partners, partner => {
                        if (this.getRemainingSpace(partner) - sendAmount
                            < TerminalNetworkV2_1.settings.minColonySpace) {
                            return false;
                        }
                        const { target, surplus, tolerance } = this.thresholds(partner, resource);
                        if (surplus != undefined) {
                            return partner.assets[resource] + sendAmount < surplus;
                        }
                        else {
                            return partner.assets[resource] + sendAmount <= target + tolerance;
                        }
                    });
                }
                if (validPartners.length > 0) {
                    const bestPartner = minBy(validPartners, partner => Game.market.calcTransactionCost(sendAmount, colony.name, partner.name));
                    const sendTerm = colony.terminal;
                    const recvTerm = bestPartner.terminal;
                    sendAmount = Math.min(sendAmount, sendTerm.store[resource] - this.lockedAmount(colony, resource));
                    if (resource == RESOURCE_ENERGY) {
                        const sendCost = Game.market.calcTransactionCost(sendAmount, colony.name, bestPartner.name);
                        if (sendAmount + sendCost > sendTerm.store[resource]) {
                            sendAmount -= sendCost;
                        }
                    }
                    if (!opts.dryRun) {
                        if (sendTerm.isReady) {
                            this.transfer(sendTerm, recvTerm, resource, sendAmount, `provide`);
                        }
                        else {
                            this.terminalOverload[sendTerm.room.name] = true;
                        }
                    }
                    return true;
                }
            }
        }
        if (opts.allowMarketSell) {
            const sellOpts = { dryRun: opts.dryRun };
            if (resource == RESOURCE_ENERGY || Abathur.isBaseMineral(resource)) {
                if (this.getRemainingSpace(colony) < TerminalNetworkV2_1.settings.minColonySpace) {
                    sellOpts.preferDirect = true;
                    sellOpts.ignorePriceChecksForDirect = true;
                }
            }
            const ret = Overmind.tradeNetwork.sell(colony.terminal, resource, provideAmount, sellOpts);
            this.debug(`Selling ${provideAmount} ${resource} from ${colony.print} with ` +
                `opts=${JSON.stringify(sellOpts)} via trade network (${ret})`);
            if (ret >= 0) {
                return true;
            }
        }
        return false;
    }
    handleRequestors(requestors, prioritizedPartners, opts = {}) {
        _.defaults(opts, {
            allowDivvying: false,
            takeFromColoniesBelowTarget: false,
            allowMarketBuy: Game.market.credits > TraderJoe.settings.market.credits.canBuyAbove,
            receiveOnlyOncePerTick: false,
            complainIfUnfulfilled: true,
            dryRun: false,
        });
        for (const resource of RESOURCE_EXCHANGE_ORDER) {
            for (const colony of (requestors[resource] || [])) {
                if (opts.receiveOnlyOncePerTick && colony.terminal && colony.terminal.hasReceived) {
                    continue;
                }
                const { target, surplus, tolerance } = this.thresholds(colony, resource);
                const requestAmount = target - colony.assets[resource];
                if (requestAmount <= 0)
                    continue;
                const partnerSets = _.map(prioritizedPartners, partners => partners[resource] || []);
                const success = this.handleRequestInstance(colony, resource, requestAmount, partnerSets, opts);
                if (!success && opts.complainIfUnfulfilled &&
                    Game.time % TerminalNetworkV2_1.settings.complainIfUnfulfilledFrequency == 0) {
                    this.notify(`Unable to fulfill request instance: ${printRoomName(colony.name)} ${leftArrow} ` +
                        `${requestAmount} ${resource}`);
                }
            }
        }
    }
    handleProviders(providers, prioritizedPartners, opts = {}) {
        _.defaults(opts, {
            allowPushToOtherRooms: true,
            allowMarketSell: true,
            complainIfUnfulfilled: true,
            dryRun: false,
        });
        for (const resource of RESOURCE_EXCHANGE_ORDER) {
            for (const colony of (providers[resource] || [])) {
                if (colony.terminal && !colony.terminal.isReady) {
                    continue;
                }
                const provideAmount = colony.assets[resource] - this.thresholds(colony, resource).target;
                if (provideAmount <= 0)
                    continue;
                const partnerSets = _.map(prioritizedPartners, partners => partners[resource] || []);
                const success = this.handleProvideInstance(colony, resource, provideAmount, partnerSets, opts);
                if (!success && opts.complainIfUnfulfilled &&
                    Game.time % TerminalNetworkV2_1.settings.complainIfUnfulfilledFrequency == 0) {
                    this.notify(`Unable to fulfill provide instance: ${printRoomName(colony.name)} ${rightArrow} ` +
                        `${provideAmount} ${resource}`);
                }
            }
        }
    }
    run() {
        this.assignColonyStates();
        this.handleRequestors(this.activeRequestors, [
            this.activeProviders,
            this.passiveProviders,
            this.equilibriumNodes,
            this.passiveRequestors,
        ], { requestType: 'active', takeFromColoniesBelowTarget: true });
        this.handleProviders(this.activeProviders, [
            this.activeRequestors,
            this.passiveRequestors,
            this.equilibriumNodes,
        ], { allowMarketSell: true, complainIfUnfulfilled: onPublicServer() });
        if (Overmind.tradeNetwork.ordersProcessedThisTick()) {
            const canBuyPassively = Game.market.credits >= TraderJoe.settings.market.credits.canBuyPassivelyAbove;
            this.handleRequestors(this.passiveRequestors, [
                this.activeProviders,
                this.passiveProviders,
                this.equilibriumNodes,
            ], { requestType: 'passive', complainIfUnfulfilled: false, allowMarketBuy: canBuyPassively });
        }
        this.recordStats();
        if (Game.time % 10 == 0) {
            for (const colony of this.colonies) {
                if (this.getRemainingSpace(colony) < TerminalNetworkV2_1.settings.minColonySpace
                    && !colony.state.isRebuilding) {
                    log.warning(`${colony.print} is critially full; requires immediate attention!`);
                }
            }
            if (this.notifications.length > 0) {
                this.notifications.sort();
                log.info(`Terminal network activity: ` + alignedNewline + this.notifications.join(alignedNewline));
            }
        }
    }
    isInternalTransaction(transaction) {
        return !!transaction.sender && !!transaction.sender.username &&
            !!transaction.recipient && !!transaction.recipient.username &&
            transaction.sender.username == transaction.recipient.username;
    }
    recordStats() {
        for (const colony of this.colonies) {
            if (colony.terminal) {
                this.stats.terminals.avgCooldown[colony.name] =
                    ema(colony.terminal.cooldown, this.stats.terminals.avgCooldown[colony.name] || 0, TerminalNetworkV2_1.settings.terminalCooldownAveragingWindow);
                this.stats.terminals.overload[colony.name] =
                    ema(this.terminalOverload[colony.name] ? 1 : 0, this.stats.terminals.overload[colony.name], CREEP_LIFE_TIME);
            }
        }
        const activeRequestors = {};
        const passiveRequestors = {};
        const equilibriumNodes = {};
        const passiveProviders = {};
        const activeProviders = {};
        for (const [statsTier, thisTier] of [[activeRequestors, this.activeRequestors],
            [passiveRequestors, this.passiveRequestors],
            [equilibriumNodes, this.equilibriumNodes],
            [passiveProviders, this.passiveProviders],
            [activeProviders, this.activeProviders]]) {
            for (const resource in thisTier) {
                for (const colony of thisTier[resource]) {
                    if (!statsTier[colony.name]) {
                        statsTier[colony.name] = [resource];
                    }
                    else {
                        statsTier[colony.name].push(resource);
                    }
                }
            }
            for (const colName in statsTier) {
                statsTier[colName] = _.sortBy(statsTier[colName], resource => _resourceExchangePrioritiesLookup[resource]);
            }
        }
        this.stats.states.activeRequestors = activeRequestors;
        this.stats.states.passiveRequestors = passiveRequestors;
        this.stats.states.equilibriumNodes = equilibriumNodes;
        this.stats.states.passiveProviders = passiveProviders;
        this.stats.states.activeProviders = activeProviders;
        const lastTick = Game.time - 1;
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < lastTick)
                break;
            if (!this.isInternalTransaction(transaction))
                continue;
            const resource = transaction.resourceType;
            const room = transaction.to;
            this.stats.incomingResources[resource] = this.stats.incomingResources[resource] || {};
            this.stats.incomingResources[resource][room] = this.stats.incomingResources[resource][room] || 0;
            this.stats.incomingResources[resource][room] += transaction.amount;
        }
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < lastTick)
                break;
            if (!this.isInternalTransaction(transaction))
                continue;
            const resource = transaction.resourceType;
            const room = transaction.from;
            this.stats.outgoingResources[resource] = this.stats.outgoingResources[resource] || {};
            this.stats.outgoingResources[resource][room] = this.stats.outgoingResources[resource][room] || 0;
            this.stats.outgoingResources[resource][room] += transaction.amount;
            const sendCost = Game.market.calcTransactionCost(transaction.amount, transaction.from, transaction.to);
            this.stats.sendCosts[room] = this.stats.sendCosts[room] || 0;
            this.stats.sendCosts[room] += sendCost;
            if (resource == RESOURCE_ENERGY) {
                const fractionalEnergyTransferCost = sendCost / transaction.amount;
                this.stats.fractionalEnergyTransferCost =
                    ema(fractionalEnergyTransferCost, this.stats.fractionalEnergyTransferCost, 100);
            }
        }
        this.stats.assets = this.assets;
    }
    summarize(resourceOrColony) {
        const { activeRequestors, passiveRequestors, equilibriumNodes, passiveProviders, activeProviders } = this.stats.states;
        let info = '\nTerminalNetwork Summary: \n';
        if (resourceOrColony && resourceOrColony instanceof Colony) {
            const colony = resourceOrColony;
            info += `${colony.print} actively providing -----------------------------------------------------\n` +
                `${bullet}${activeProviders[colony.name] || '(None)'}\n` +
                `${colony.print} passively providing ----------------------------------------------------\n` +
                `${bullet}${passiveProviders[colony.name] || '(None)'}\n` +
                `${colony.print} at equilibrium for -----------------------------------------------------\n` +
                `${bullet}${equilibriumNodes[colony.name] || '(None)'}\n` +
                `${colony.print} passively requesting ---------------------------------------------------\n` +
                `${bullet}${passiveRequestors[colony.name] || '(None)'}\n` +
                `${colony.print} actively requesting ----------------------------------------------------\n` +
                `${bullet}${activeRequestors[colony.name] || '(None)'}\n`;
        }
        else {
            const resource = resourceOrColony || undefined;
            if (resource) {
                info += `Active providers for ${resource} -----------------------------------------------------\n` +
                    `${bullet}${_.map(this.activeProviders[resource], col => col.printAligned + ` (${col.assets[resource]}), `) || '(None)'}\n` +
                    `Passive providers for ${resource} ----------------------------------------------------\n` +
                    `${bullet}${_.map(this.passiveProviders[resource], col => col.printAligned + ` (${col.assets[resource]}), `) || '(None)'}\n` +
                    `Equilibrium nodes for ${resource} ----------------------------------------------------\n` +
                    `${bullet}${_.map(this.equilibriumNodes[resource], col => col.printAligned + ` (${col.assets[resource]}), `) || '(None)'}\n` +
                    `Passive requestors for ${resource} ----------------------------------------------------\n` +
                    `${bullet}${_.map(this.passiveRequestors[resource], col => col.printAligned + ` (${col.assets[resource]}), `) || '(None)'}\n` +
                    `Active requestors for ${resource} -----------------------------------------------------\n` +
                    `${bullet}${_.map(this.activeRequestors[resource], col => col.printAligned + ` (${col.assets[resource]}), `) || '(None)'}\n`;
            }
            else {
                info += 'Active providers ---------------------------------------------------------------------\n';
                for (const colonyName in activeProviders) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${activeProviders[colonyName]}\n`;
                }
                info += 'Passive providers --------------------------------------------------------------------\n';
                for (const colonyName in passiveProviders) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${passiveProviders[colonyName]}\n`;
                }
                info += 'Equilibrium nodes --------------------------------------------------------------------\n';
                for (const colonyName in equilibriumNodes) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${equilibriumNodes[colonyName]}\n`;
                }
                info += 'Passive requestors -------------------------------------------------------------------\n';
                for (const colonyName in passiveRequestors) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${passiveRequestors[colonyName]}\n`;
                }
                info += 'Active requestors --------------------------------------------------------------------\n';
                for (const colonyName in activeRequestors) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${activeRequestors[colonyName]}\n`;
                }
            }
        }
        console.log(info);
    }
};
TerminalNetworkV2.settings = {
    maxEnergySendAmount: 25000,
    maxResourceSendAmount: 3000,
    maxEvacuateSendAmount: 50000,
    minColonySpace: 20000,
    terminalCooldownAveragingWindow: 1000,
    buyBaseMineralsDirectUnder: DEFAULT_TARGET - DEFAULT_TOLERANCE,
    complainIfUnfulfilledFrequency: 20,
};
TerminalNetworkV2 = TerminalNetworkV2_1 = __decorate([
    profile
], TerminalNetworkV2);

class DefenseDirective extends Directive {
    constructor(flag) {
        super(flag);
        Overmind.overseer.combatPlanner.directives.push(this);
    }
}

const THREAT_EXPIRATION = 100;
const THREAT_DECAY_TIMESCALE = 100;
const SIEGE_ANALYSIS_EXPIRATION = 2500;
const defaultCombatPlannerMemory = {
    threats: {},
    profiles: {},
    defenses: {},
    sieges: {},
    skirmishes: {},
};
class CombatPlanner {
    constructor() {
        _.defaults(this.memory, defaultCombatPlannerMemory);
    }
    get memory() {
        return Memory.combatPlanner;
    }
    static computeHitsToSpawn(room) {
        return 0;
    }
    spawnNeededCreeps() {
    }
    assembleSquads() {
        const idleCreeps = [];
        for (const creep of this.creeps) {
            if (!creep.overlord) {
                idleCreeps.push(creep);
            }
            else {
                const creepDirective = creep.overlord.directive;
                if (creepDirective && creepDirective instanceof DefenseDirective) {
                    if (this.memory.threats[creepDirective.ref]) {
                    }
                }
            }
        }
    }
    static getThreat(directive) {
        if (directive.room) {
            return {
                directive: directive,
                potentials: CombatIntel.getCombatPotentials(directive.room.hostiles),
                roomName: directive.room.name,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                }
            };
        }
        else {
            return {
                directive: directive,
                potentials: undefined,
                roomName: directive.pos.roomName,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                }
            };
        }
    }
    registerThreat(directive) {
        const threat = CombatPlanner.getThreat(directive);
        if (this.memory.threats[directive.ref]) {
            if (threat.potentials) {
                let attack, rangedAttack, heal;
                const lastPotentials = this.memory.threats[directive.ref].potentials;
                if (lastPotentials) {
                    attack = lastPotentials.attack;
                    rangedAttack = lastPotentials.ranged;
                    heal = lastPotentials.heal;
                }
                else {
                    attack = 0;
                    rangedAttack = 0;
                    heal = 0;
                }
                const decayedAttack = ema(threat.potentials.attack, attack, THREAT_DECAY_TIMESCALE);
                const decayedRangedAttack = ema(threat.potentials.ranged, rangedAttack, THREAT_DECAY_TIMESCALE);
                const decayedHeal = ema(threat.potentials.heal, heal, THREAT_DECAY_TIMESCALE);
                const potentials = {
                    attack: Math.max(threat.potentials.attack, decayedAttack),
                    ranged: Math.max(threat.potentials.ranged, decayedRangedAttack),
                    heal: Math.max(threat.potentials.heal, decayedHeal),
                };
                this.memory.threats[directive.ref].potentials = potentials;
                this.memory.threats[directive.ref].lastSeen.tick = Game.time;
            }
            else {
            }
        }
        else {
            this.memory.threats[directive.ref] = threat;
        }
    }
    static getRoomLayout(room) {
        let isBunker, isExposed, isInnerWall, isEdgeWall = false;
        const exitPositions = RoomIntel.getExitPositions(room.name);
        const terrain = Game.map.getRoomTerrain(room.name);
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        const hostileStructuresInRampart = _.filter(hostileStructures, s => s.pos.lookForStructure(STRUCTURE_RAMPART));
        isBunker = (hostileStructuresInRampart.length / hostileStructures.length >= 0.8);
        const walledOffExitTiles = _.filter(exitPositions, pos => {
            let lookPos;
            const x = pos.x;
            const y = pos.y;
            if (x == 0) {
                lookPos = new RoomPosition(x + 2, y, room.name);
            }
            else if (x == 49) {
                lookPos = new RoomPosition(x - 2, y, room.name);
            }
            else if (y == 0) {
                lookPos = new RoomPosition(x, y + 2, room.name);
            }
            else if (y == 49) {
                lookPos = new RoomPosition(x, y - 2, room.name);
            }
            else {
                lookPos = pos;
            }
            if (terrain.get(lookPos.x, lookPos.y) == TERRAIN_MASK_WALL) {
                return true;
            }
            else {
                const rampart = lookPos.lookForStructure(STRUCTURE_RAMPART);
                const wall = lookPos.lookForStructure(STRUCTURE_WALL);
                return rampart != undefined || wall != undefined;
            }
        });
        if (walledOffExitTiles.length == walledOffExitTiles.length) {
            isEdgeWall = true;
        }
        if (!isBunker && !isEdgeWall) {
            const entryPoints = _.compact([_.find(exitPositions, pos => pos.x == 0),
                _.find(exitPositions, pos => pos.x == 49),
                _.find(exitPositions, pos => pos.y == 0),
                _.find(exitPositions, pos => pos.y == 49),
            ]);
            const target = (room.spawns[0] || room.towers[0]);
            if (target) {
                const obstacles = _.filter(room.structures, s => !s.isWalkable);
                const isReachable = _.find(entryPoints, pos => Pathing.isReachable(pos, target.pos, obstacles));
                if (isReachable) {
                    isExposed = true;
                }
            }
            if (!isExposed) {
                isInnerWall = true;
            }
        }
        if (isEdgeWall) {
            return 'edgewall';
        }
        else if (isBunker) {
            return 'bunker';
        }
        else if (isExposed) {
            return 'exposed';
        }
        else if (isInnerWall) {
            return 'innerwall';
        }
        else {
            log.warning(`Inconclusive room layout for ${room.print}! Assuming inner wall.`);
            return 'innerwall';
        }
    }
    static getSiegeAnalysis(room) {
        const owner = room.owner;
        const level = room.controller ? room.controller.level : 0;
        const towerDamageSamplePositions = _.map(_.range(20), i => new RoomPosition(_.random(1, 48), _.random(1, 48), room.name));
        const maxTowerDamage = _.max(_.map(towerDamageSamplePositions, pos => CombatIntel.towerDamageAtPos(pos, true)));
        const minBarrierHits = room.barriers.length > 0 ? _.min(_.map(room.barriers, b => b.hits)) : 0;
        const avgBarrierHits = room.barriers.length > 0 ? _.sum(room.barriers, b => b.hits) / room.barriers.length : 0;
        const numWalls = room.walls.length;
        const numRamparts = room.ramparts.length;
        const expiration = getCacheExpiration(SIEGE_ANALYSIS_EXPIRATION);
        const roomLayout = this.getRoomLayout(room);
        return {
            owner,
            level,
            maxTowerDamage,
            minBarrierHits,
            avgBarrierHits,
            numWalls,
            numRamparts,
            roomLayout,
            expiration
        };
    }
    registerSiegeAnalysis(room) {
        if (!this.memory.sieges[room.name]) {
            this.memory.sieges[room.name] = {};
        }
        if (!this.memory.sieges[room.name].analysis || Game.time > this.memory.sieges[room.name].analysis.expiration) {
            this.memory.sieges[room.name].analysis = CombatPlanner.getSiegeAnalysis(room);
        }
    }
    init() {
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            if (room.owner && !room.my) {
                this.registerSiegeAnalysis(room);
            }
        }
        for (const directive of this.directives) {
            this.registerThreat(directive);
        }
    }
    run() {
    }
    visuals() {
    }
}

var Overseer_1;
const INVASION_THREAT_LEVEL_THRESHOLD = 0.25;
const getDefaultOverseerMemory = () => ({});
let Overseer = Overseer_1 = class Overseer {
    constructor() {
        this.memory = Mem.wrap(Memory, 'overseer', getDefaultOverseerMemory);
        this.directives = [];
        this.overlords = [];
        this.overlordsByColony = {};
        this._overlordsCached = false;
        this.notifier = new Notifier();
        this.combatPlanner = new CombatPlanner();
    }
    refresh() {
        this.memory = Mem.wrap(Memory, 'overseer', getDefaultOverseerMemory);
        this.notifier.clear();
    }
    try(callback, identifier) {
        if (USE_TRY_CATCH) {
            try {
                callback();
            }
            catch (e) {
                if (identifier) {
                    e.name = `Caught unhandled exception at ${'' + callback} (identifier: ${identifier}): \n`
                        + e.name + '\n' + e.stack;
                }
                else {
                    e.name = `Caught unhandled exception at ${'' + callback}: \n` + e.name + '\n' + e.stack;
                }
                Overmind.exceptions.push(e);
            }
        }
        else {
            callback();
        }
    }
    registerDirective(directive) {
        this.directives.push(directive);
        this._directiveCached = false;
    }
    removeDirective(directive) {
        _.remove(this.directives, dir => dir.name == directive.name);
        for (const name in directive.overlords) {
            this.removeOverlord(directive.overlords[name]);
        }
        this._directiveCached = false;
    }
    ensureDirectivesCached() {
        if (!this._directiveCached) {
            this.directivesByType = _.groupBy(this.directives, directive => directive.directiveName);
            this.directivesByRoom = _.groupBy(this.directives, directive => directive.pos.roomName);
            this.directivesByColony = _.groupBy(this.directives, directive => directive.colony.name || 'none');
            this._directiveCached = true;
        }
    }
    getDirectivesOfType(directiveName) {
        this.ensureDirectivesCached();
        return this.directivesByType[directiveName] || [];
    }
    getDirectivesInRoom(roomName) {
        this.ensureDirectivesCached();
        return this.directivesByRoom[roomName] || [];
    }
    getDirectivesForColony(colony) {
        this.ensureDirectivesCached();
        return this.directivesByColony[colony.name] || [];
    }
    registerOverlord(overlord) {
        this.overlords.push(overlord);
        this._overlordsCached = false;
    }
    removeOverlord(overlord) {
        _.remove(this.overlords, o => o.ref == overlord.ref);
        this._overlordsCached = false;
    }
    ensureOverlordsCached() {
        if (!this._overlordsCached) {
            this.overlords.sort((o1, o2) => o1.priority - o2.priority);
            this.overlordsByColony = _.groupBy(this.overlords, overlord => overlord.colony.name);
            for (const colName in this.overlordsByColony) {
                this.overlordsByColony[colName].sort((o1, o2) => o1.priority - o2.priority);
            }
            this._overlordsCached = true;
        }
    }
    getOverlordsForColony(colony) {
        return this.overlordsByColony[colony.name] || [];
    }
    registerLogisticsRequests(colony) {
        for (const room of colony.rooms) {
            for (const resourceType in room.drops) {
                for (const drop of room.drops[resourceType]) {
                    const inputRequest = _.find(colony.logisticsNetwork.requests, request => request.amount > 0);
                    if (inputRequest)
                        continue;
                    if (drop.amount > LogisticsNetwork.settings.droppedEnergyThreshold
                        || drop.resourceType != RESOURCE_ENERGY) {
                        colony.logisticsNetwork.requestOutput(drop, { dAmountdt: 1 });
                    }
                }
            }
        }
        for (const ruin of colony.ruins) {
            if (ruin.store.getUsedCapacity() > LogisticsNetwork.settings.droppedEnergyThreshold
                || ruin.store.getUsedCapacity() > ruin.store.energy) {
                if (colony.bunker && ruin.pos.isEqualTo(colony.bunker.anchor))
                    continue;
                colony.logisticsNetwork.requestOutput(ruin, { resourceType: 'all' });
            }
        }
        for (const tombstone of colony.tombstones) {
            if (tombstone.store.getUsedCapacity() > LogisticsNetwork.settings.droppedEnergyThreshold
                || tombstone.store.getUsedCapacity() > tombstone.store.energy) {
                if (colony.bunker && tombstone.pos.isEqualTo(colony.bunker.anchor)
                    || tombstone.pos.lookForStructure(STRUCTURE_CONTAINER))
                    continue;
                colony.logisticsNetwork.requestOutput(tombstone, { resourceType: 'all' });
            }
        }
    }
    init() {
        this.ensureDirectivesCached();
        this.ensureOverlordsCached();
        for (const directive of this.directives) {
            directive.init();
        }
        for (const overlord of this.overlords) {
            if (!overlord.isSuspended) {
                if (overlord.profilingActive) {
                    const start = Game.cpu.getUsed();
                    overlord.preInit();
                    this.try(() => overlord.init());
                    overlord.memory["S"].cpu += Game.cpu.getUsed() - start;
                }
                else {
                    overlord.preInit();
                    this.try(() => overlord.init());
                }
            }
        }
        for (const colony of getAllColonies()) {
            this.registerLogisticsRequests(colony);
        }
    }
    placeHarvestingDirectives(colony) {
        for (const source of colony.sources) {
            DirectiveHarvest.createIfNotPresent(source.pos, 'pos');
        }
        if (colony.controller.level >= 6 && colony.terminal) {
            _.forEach(colony.extractors, extractor => DirectiveExtract.createIfNotPresent(extractor.pos, 'pos'));
        }
    }
    handleBootstrapping(colony) {
        if (colony.state.isIncubating)
            return;
        const noQueen = colony.getCreepsByRole(Roles.queen).length == 0;
        if (noQueen && colony.hatchery && !colony.spawnGroup) {
            const energyToMakeQueen = bodyCost(Setups.queens.early.generateBody(colony.room.energyCapacityAvailable));
            if (colony.room.energyAvailable < energyToMakeQueen || hasJustSpawned()) {
                const result = DirectiveBootstrap.createIfNotPresent(colony.hatchery.pos, 'pos');
                if (typeof result == 'string' || result == OK) {
                    colony.hatchery.settings.suppressSpawning = true;
                }
            }
        }
    }
    handleOutpostDefense(colony) {
        for (const room of colony.outposts) {
            if (!colony.isRoomActive(room.name)) {
                continue;
            }
            if (room.dangerousPlayerHostiles.length > 0) {
                DirectiveOutpostDefense.createIfNotPresent(Pathing.findPathablePosition(room.name), 'room');
            }
            else if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) {
                if (room.invaders.length > 0 || (room.invaderCore && room.invaderCore.level == 0)) {
                    const defenseDirectives = [...DirectiveGuard.find(room.flags),
                        ...DirectiveOutpostDefense.find(room.flags)];
                    if (defenseDirectives.length == 0) {
                        const placePos = (room.invaders[0] || room.invaderCore).pos;
                        DirectiveGuard.create(placePos);
                    }
                }
            }
        }
    }
    handleColonyInvasions(colony, checkPersistent = false) {
        if (!colony.room.isSafe && colony.room.threatLevel > INVASION_THREAT_LEVEL_THRESHOLD) {
            if (checkPersistent) {
                const safetyData = RoomIntel.getSafetyData(colony.room.name);
                const invasionIsPersistent = safetyData.unsafeFor > 20;
                if (invasionIsPersistent) {
                    DirectiveInvasionDefense.createIfNotPresent(colony.controller.pos, 'room');
                }
            }
            else {
                DirectiveInvasionDefense.createIfNotPresent(colony.controller.pos, 'room');
            }
        }
    }
    handleNukeResponse(colony) {
        if (colony.room && colony.level >= DirectiveNukeResponse.requiredRCL) {
            for (const nuke of colony.room.find(FIND_NUKES)) {
                DirectiveNukeResponse.createIfNotPresent(nuke.pos, 'pos');
            }
        }
    }
    handlePowerMining(room) {
        const powerSetting = Memory.settings.powerCollection;
        const roomType = Cartographer.roomType(room.name);
        if (powerSetting.enabled && (roomType == ROOMTYPE_ALLEY || roomType == ROOMTYPE_CROSSROAD)) {
            const powerBank = _.first(room.powerBanks);
            if (powerBank && powerBank.ticksToDecay > 4000 && powerBank.power >= powerSetting.minPower) {
                if (DirectivePowerMine.isPresent(powerBank.pos)) {
                    return;
                }
                const validColonies = _.filter(getAllColonies(), colony => colony.level >= DirectivePowerMine.requiredRCL
                    && Game.map.getRoomLinearDistance(colony.name, room.name)
                        <= powerSetting.maxRange);
                for (const colony of validColonies) {
                    const route = Game.map.findRoute(colony.room, powerBank.room);
                    if (route != ERR_NO_PATH && route.length <= powerSetting.maxRange) {
                        log.info(`FOUND POWER BANK IN RANGE ${route.length}, STARTING MINING ${powerBank.room}`);
                        DirectivePowerMine.create(powerBank.pos);
                        return;
                    }
                }
            }
        }
    }
    computePossibleOutposts(colony, depth = 3) {
        return _.filter(Cartographer.findRoomsInRange(colony.room.name, depth), roomName => {
            if (Cartographer.roomType(roomName) != ROOMTYPE_CONTROLLER) {
                return false;
            }
            const alreadyAnOutpost = _.any(Overmind.cache.outpostFlags, flag => (flag.memory.setPos || flag.pos).roomName == roomName);
            const alreadyAColony = !!Overmind.colonies[roomName];
            if (alreadyAColony || alreadyAnOutpost) {
                return false;
            }
            const alreadyOwned = RoomIntel.roomOwnedBy(roomName);
            const alreadyReserved = RoomIntel.roomReservedBy(roomName);
            const isBlocked = Game.flags[roomName + '-Block'] != null;
            if (isBlocked) {
            }
            const disregardReservations = !onPublicServer();
            if (alreadyOwned || (alreadyReserved && !disregardReservations) || isBlocked) {
                return false;
            }
            const neighboringRooms = _.values(Game.map.describeExits(roomName));
            const isReachableFromColony = _.any(neighboringRooms, r => colony.roomNames.includes(r));
            return isReachableFromColony && RoomIntel.isRoomAccessible(roomName);
        });
    }
    handleNewOutposts(colony) {
        const numSources = _.sum(colony.roomNames, roomName => Memory.rooms[roomName] && Memory.rooms[roomName]["s"]
            ? Memory.rooms[roomName]["s"].length
            : 0);
        const numRemotes = numSources - colony.room.sources.length;
        let neededRemotes = Colony.settings.remoteSourcesByLevel[colony.level];
        if (getAllColonies().length <= 2) {
            neededRemotes = Math.floor(neededRemotes * 1.5);
        }
        if (numRemotes < neededRemotes) {
            const possibleOutposts = this.computePossibleOutposts(colony);
            const origin = colony.pos;
            const bestOutpost = minBy(possibleOutposts, function (outpostName) {
                const sourceInfo = RoomIntel.getSourceInfo(outpostName);
                if (!sourceInfo)
                    return false;
                const sourceDistances = _.map(sourceInfo, src => Pathing.distance(origin, src.pos));
                if (_.any(sourceDistances, dist => dist == undefined || dist > Colony.settings.maxSourceDistance)) {
                    return false;
                }
                return _.sum(sourceDistances) / sourceDistances.length;
            });
            if (bestOutpost) {
                const pos = Pathing.findPathablePosition(bestOutpost);
                log.info(`Colony ${colony.room.print} now remote mining from ${pos.print}`);
                DirectiveOutpost.createIfNotPresent(pos, 'room', { memory: { ["C"]: colony.name } });
            }
        }
    }
    handleAutoPoisoning() {
        const poisonDirectives = this.directivesByType[DirectivePoisonRoom.directiveName];
        if (poisonDirectives.length >= Memory.settings.autoPoison.maxConcurrent) {
            return;
        }
        for (const room of getAllRooms()) {
            if (DirectivePoisonRoom.canAutoPoison(room)) {
                const controller = room.controller;
                const maxRange = Memory.settings.autoPoison.maxRange;
                if (!DirectivePoisonRoom.isPresent(controller.pos)) {
                    const colonies = getAllColonies().filter(colony => colony.level >= DirectivePoisonRoom.requiredRCL
                        && Game.map.getRoomLinearDistance(room.name, colony.room.name) <= maxRange);
                    for (const colony of colonies) {
                        const route = Game.map.findRoute(colony.room, room);
                        if (route != ERR_NO_PATH && route.length <= maxRange) {
                            log.notify(`Poisoning room ${room.print}`);
                            DirectivePoisonRoom.create(controller.pos);
                            return;
                        }
                    }
                }
            }
        }
    }
    placeDirectives() {
        const allRooms = getAllRooms();
        const allColonies = getAllColonies();
        if (LATEST_BUILD_TICK == Game.time) {
            _.forEach(allColonies, colony => this.placeHarvestingDirectives(colony));
        }
        _.forEach(allColonies, colony => this.handleBootstrapping(colony));
        _.forEach(allColonies, colony => this.handleOutpostDefense(colony));
        _.forEach(allColonies, colony => this.handleColonyInvasions(colony));
        _.forEach(allColonies, colony => this.handleNukeResponse(colony));
        if (Game.time % 100 == 67) {
            _.forEach(allColonies, colony => this.handleUnkillableStrongholds(colony));
        }
        if (Memory.settings.powerCollection.enabled && Game.cpu.bucket > 8000) {
            _.forEach(allRooms, room => this.handlePowerMining(room));
        }
        if (Memory.settings.autoPoison.enabled && canClaimAnotherRoom() && Game.cpu.bucket > 9500) {
            if (p(0.05))
                this.handleAutoPoisoning();
        }
        if (getAutonomyLevel() > Autonomy.Manual) {
            _.forEach(allColonies, colony => {
                if (Game.time % Overseer_1.settings.outpostCheckFrequency == 2 * colony.id) {
                    this.handleNewOutposts(colony);
                }
                if (Game.time % 25 == 0 && colony.spawns.length == 0) {
                    if (colony.room.find(FIND_MY_SPAWNS).length == 0) {
                        const pos = Pathing.findPathablePosition(colony.room.name);
                        DirectiveColonize.createIfNotPresent(pos, 'room');
                    }
                }
            });
        }
    }
    handleUnkillableStrongholds(colony) {
        const suspensionDuration = 5000;
        for (const room of colony.outposts) {
            if (Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER &&
                room.invaderCore && room.invaderCore.level > 3) {
                const roomDirectives = Directive.find(room.flags);
                for (const directive of roomDirectives) {
                    for (const name in directive.overlords) {
                        directive.overlords[name].suspendFor(suspensionDuration);
                    }
                }
                if (colony.isRoomActive(room.name)) {
                    log.notify(`Disabling outpost ${room.print} due to Stronghold presence`);
                }
                colony.suspendOutpost(room.name, OutpostDisableReason.inactiveStronghold, suspensionDuration);
            }
        }
    }
    handleSafeMode(colony) {
        if (colony.stage == ColonyStage.Larva && onPublicServer()) {
            return;
        }
        const criticalStructures = _.compact([...colony.spawns,
            colony.storage,
            colony.terminal]);
        for (const structure of criticalStructures) {
            if (structure.hits < structure.hitsMax &&
                structure.pos.findInRange(colony.room.dangerousPlayerHostiles, 2).length > 0) {
                const ret = colony.controller.activateSafeMode();
                if (ret != OK && !colony.controller.safeMode) {
                    if (colony.terminal) {
                        DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, 'room');
                    }
                }
                else {
                    return;
                }
            }
        }
        const firstHostile = _.first(colony.room.dangerousPlayerHostiles);
        if (firstHostile && colony.spawns[0]) {
            const barriers = _.map(colony.room.barriers, barrier => barrier.pos);
            if (Pathing.isReachable(firstHostile.pos, colony.spawns[0].pos, barriers)) {
                const ret = colony.controller.activateSafeMode();
                if (ret != OK && !colony.controller.safeMode) {
                    if (colony.terminal) {
                        DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, 'room');
                    }
                }
                else {
                    return;
                }
            }
        }
    }
    handleNewShard() {
        const newShardFlags = _.filter(Game.flags, flag => flag.color === COLOR_PURPLE && flag.secondaryColor === COLOR_BROWN);
        if (newShardFlags.length == 0) {
            log.alert("No colonies found, and no purple-brown flag to bootstrap colony found.");
            return;
        }
        const targetFlag = newShardFlags[0];
        const targetRoom = targetFlag.pos.roomName;
        for (const creepName in Game.creeps) {
            const creep = Game.creeps[creepName];
            if (creep.pos.roomName != targetRoom || creep.pos.isEdge) {
                creep.moveTo(new RoomPosition(25, 25, targetRoom), { reusePath: 50 });
                continue;
            }
            if (creep.getActiveBodyparts(CLAIM) > 0) {
                const controller = creep.room.controller;
                if (!controller || controller.my)
                    continue;
                if (!creep.pos.isNearTo(controller)) {
                    creep.moveTo(controller, { reusePath: 50 });
                    continue;
                }
                creep.claimController(controller);
                continue;
            }
            if (creep.getActiveBodyparts(WORK) > 0) {
                const constructionSite = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);
                if (constructionSite && creep.store.getFreeCapacity() == 0) {
                    if (!creep.pos.isNearTo(constructionSite)) {
                        creep.moveTo(constructionSite, { reusePath: 50 });
                        continue;
                    }
                }
                if (constructionSite && creep.store[RESOURCE_ENERGY] > 0 && creep.pos.isNearTo(constructionSite)) {
                    creep.build(constructionSite);
                    continue;
                }
                if (creep.room.spawns.length == 1) {
                    const spawn = creep.room.spawns[0];
                    if (creep.store.getFreeCapacity() == 0) {
                        if (!creep.pos.isNearTo(spawn)) {
                            creep.moveTo(spawn, { reusePath: 50 });
                            continue;
                        }
                    }
                    if (creep.store[RESOURCE_ENERGY] > 0 && creep.pos.isNearTo(spawn)) {
                        creep.transfer(spawn, RESOURCE_ENERGY);
                        continue;
                    }
                }
                const sources = creep.room.find(FIND_SOURCES_ACTIVE);
                if (sources.length > 0) {
                    for (const source of sources) {
                        if (source.energy == 0)
                            continue;
                        if (!creep.pos.isNearTo(source)) {
                            creep.moveTo(source, { reusePath: 50 });
                            break;
                        }
                        else {
                            creep.harvest(source);
                            break;
                        }
                    }
                    continue;
                }
            }
        }
    }
    run() {
        const colonies = getAllColonies();
        if (colonies.length == 0 || (colonies.length == 1 && colonies[0].spawns.length == 0)) {
            log.debug("No colonies or no spawn found. Probably new shard bootstrap.");
            this.handleNewShard();
        }
        for (const directive of this.directives) {
            directive.run();
        }
        for (const overlord of this.overlords) {
            if (!overlord.isSuspended) {
                if (overlord.profilingActive) {
                    const start = Game.cpu.getUsed();
                    this.try(() => overlord.run());
                    overlord.memory["S"].cpu += Game.cpu.getUsed() - start;
                }
                else {
                    this.try(() => overlord.run());
                }
            }
        }
        for (const colony of getAllColonies()) {
            this.handleSafeMode(colony);
        }
        this.placeDirectives();
    }
    getCreepReport(colony) {
        const roleOccupancy = {};
        for (const overlord of this.overlordsByColony[colony.name]) {
            for (const role in overlord.creepUsageReport) {
                const report = overlord.creepUsageReport[role];
                if (report == undefined) {
                    if (Game.time % 100 == 0) {
                        log.info(`Role ${role} is not reported by ${overlord.ref}!`);
                    }
                }
                else {
                    if (roleOccupancy[role] == undefined) {
                        roleOccupancy[role] = [0, 0];
                    }
                    roleOccupancy[role][0] += report[0];
                    roleOccupancy[role][1] += report[1];
                }
            }
        }
        return roleOccupancy;
    }
    visuals() {
        for (const directive of this.directives) {
            directive.visuals();
        }
        for (const overlord of this.overlords) {
            overlord.visuals();
        }
        this.notifier.visuals();
    }
};
Overseer.settings = {
    outpostCheckFrequency: onPublicServer() ? 250 : 100
};
Overseer = Overseer_1 = __decorate([
    profile
], Overseer);

const CHECK_EXPANSION_FREQUENCY = 1000;
const UNOWNED_MINERAL_BONUS = 100;
const CATALYST_BONUS = 75;
const MAX_SCORE_BONUS = _.sum([UNOWNED_MINERAL_BONUS, CATALYST_BONUS]);
const TOO_CLOSE_PENALTY = 100;
const defaultExpansionPlannerMemory = () => ({});
let ExpansionPlanner = class ExpansionPlanner {
    constructor() {
        this.memory = Mem.wrap(Memory, 'expansionPlanner', defaultExpansionPlannerMemory);
    }
    refresh() {
        this.memory = Mem.wrap(Memory, 'expansionPlanner', defaultExpansionPlannerMemory);
    }
    handleExpansion() {
        const allColonies = getAllColonies();
        if (allColonies.length >= Math.min(Game.gcl.level, MAX_OWNED_ROOMS)) {
            return;
        }
        if (Game.shard.name == 'shard3') {
            if (allColonies.length >= SHARD3_MAX_OWNED_ROOMS) {
                return;
            }
        }
        const roomName = this.chooseNextColonyRoom();
        if (roomName) {
            const pos = Pathing.findPathablePosition(roomName);
            DirectiveColonize.createIfNotPresent(pos, 'room');
            log.notify(`Room ${roomName} selected as next colony! Creating colonization directive.`);
        }
    }
    chooseNextColonyRoom() {
        const possibleColonizers = [];
        for (const colony of getAllColonies()) {
            if (colony.level >= DirectiveColonize.requiredRCL
                && _.filter(colony.flags, flag => DirectiveColonize.filter(flag)).length == 0) {
                possibleColonizers.push(colony);
            }
        }
        const possibleBestExpansions = _.compact(_.map(possibleColonizers, col => this.getBestExpansionRoomFor(col)));
        log.debug(`possibleExspansions: ${JSON.stringify(possibleBestExpansions)}`);
        const bestExpansion = maxBy(possibleBestExpansions, choice => choice.score);
        if (bestExpansion) {
            log.alert(`Next expansion chosen: ${bestExpansion.roomName} with score ${bestExpansion.score}`);
            return bestExpansion.roomName;
        }
        else {
            log.alert(`No viable expansion rooms found!`);
        }
    }
    getBestExpansionRoomFor(colony) {
        const allColonyRooms = _.zipObject(_.map(getAllColonies(), col => [col.room.name, true]));
        const allOwnedMinerals = _.map(getAllColonies(), col => col.room.mineral.mineralType);
        let bestRoom = '';
        let bestScore = -Infinity;
        for (const roomName in colony.memory.expansionData.possibleExpansions) {
            let score = colony.memory.expansionData.possibleExpansions[roomName];
            if (typeof score != 'number')
                continue;
            if (score + MAX_SCORE_BONUS > bestScore) {
                const range2Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE);
                if (_.any(range2Rooms, roomName => allColonyRooms[roomName])) {
                    continue;
                }
                const range3Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE + 1);
                if (_.any(range3Rooms, roomName => allColonyRooms[roomName])) {
                    score -= TOO_CLOSE_PENALTY;
                }
                const adjacentRooms = Cartographer.findRoomsInRange(roomName, 1);
                if (_.any(adjacentRooms, roomName => Memory.rooms[roomName]["a"])) {
                    continue;
                }
                const mineralType = Memory.rooms[roomName]["m"]
                    ? Memory.rooms[roomName]["m"]["t"]
                    : undefined;
                if (mineralType) {
                    if (!allOwnedMinerals.includes(mineralType)) {
                        score += UNOWNED_MINERAL_BONUS;
                    }
                    if (mineralType == RESOURCE_CATALYST) {
                        score += CATALYST_BONUS;
                    }
                }
                if (score > bestScore && RoomIntel.isRoomAccessible(roomName)) {
                    bestScore = score;
                    bestRoom = roomName;
                }
            }
        }
        if (bestRoom != '') {
            return { roomName: bestRoom, score: bestScore };
        }
    }
    init() {
    }
    run() {
        if (Game.time % CHECK_EXPANSION_FREQUENCY == 17 && getAutonomyLevel() == Autonomy.Automatic) {
            this.handleExpansion();
        }
    }
};
ExpansionPlanner = __decorate([
    profile
], ExpansionPlanner);

let _Overmind = class _Overmind {
    constructor() {
        this.memory = Memory.Overmind;
        this.overseer = new Overseer();
        this.shouldBuild = true;
        this.expiration = Game.time + NEW_OVERMIND_INTERVAL;
        this.cache = new GameCache();
        this.colonies = {};
        this.suspendedColonies = [];
        this.suppressedColonies = [];
        this.directives = {};
        this.zerg = {};
        this.powerZerg = {};
        this.overlords = {};
        this.spawnGroups = {};
        this.colonyMap = {};
        this.terminalNetwork = new TerminalNetworkV2();
        global.TerminalNetwork = this.terminalNetwork;
        this.tradeNetwork = new TraderJoe();
        global.TradeNetwork = this.tradeNetwork;
        this.expansionPlanner = new ExpansionPlanner();
        this.roomIntel = new RoomIntel();
        this.exceptions = [];
        this.profilerRooms = {};
    }
    build() {
        if (USE_SCREEPS_PROFILER) {
            for (const name of PROFILER_INCLUDE_COLONIES) {
                this.profilerRooms[name] = true;
            }
            const myRoomNames = _.filter(_.keys(Game.rooms), name => Game.rooms[name] && Game.rooms[name].my);
            for (const name of _.sample(myRoomNames, PROFILER_COLONY_LIMIT - PROFILER_INCLUDE_COLONIES.length)) {
                this.profilerRooms[name] = true;
            }
        }
        this.cache.build();
        this.registerColonies();
        this.registerDirectives();
        _.forEach(this.colonies, c => c.spawnMoarOverlords());
        _.forEach(this.directives, d => d.spawnMoarOverlords());
        this.shouldBuild = false;
    }
    refresh() {
        this.shouldBuild = true;
        this.memory = Memory.Overmind;
        this.exceptions = [];
        this.cache.refresh();
        this.overseer.refresh();
        this.terminalNetwork.refresh();
        this.tradeNetwork.refresh();
        this.expansionPlanner.refresh();
        _.forEach(this.colonies, c => c.refresh());
        _.forEach(this.directives, d => d.refresh());
        this.registerDirectives();
        for (const o in this.overlords) {
            this.overlords[o].refresh();
        }
        for (const s in this.spawnGroups) {
            this.spawnGroups[s].refresh();
        }
        this.shouldBuild = false;
    }
    try(callback, identifier) {
        if (!USE_TRY_CATCH)
            return callback();
        try {
            callback();
        }
        catch (e) {
            if (identifier) {
                e.name = `Caught unhandled exception at ${'' + callback} (identifier: ${identifier}): \n`
                    + e.name + '\n' + e.stack;
            }
            else {
                e.name = `Caught unhandled exception at ${'' + callback}: \n` + e.name + '\n' + e.stack;
            }
            this.exceptions.push(e);
        }
    }
    handleExceptions() {
        if (this.exceptions.length == 0)
            return;
        log.warning('Exceptions present this tick! Rebuilding Overmind object in next tick.');
        Memory.stats.persistent.lastErrorTick = Game.time;
        this.shouldBuild = true;
        this.expiration = Game.time;
        if (this.exceptions.length == 1) {
            throw _.first(this.exceptions);
        }
        for (const e of this.exceptions) {
            log.throw(e);
        }
        const err = new Error('Multiple exceptions caught this tick!');
        err.stack = _.map(this.exceptions, e => e.name).join('\n');
        throw err;
    }
    registerColonies() {
        this.colonyMap = {};
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            if (!room.my)
                continue;
            const colony = Memory.colonies[roomName];
            if (colony && colony.suspend) {
                this.suspendedColonies.push(roomName);
                continue;
            }
            if (room.flags) {
                const suppressed = _.filter(room.flags, flag => DirectiveClearRoom.filter(flag) || DirectivePoisonRoom.filter(flag));
                if (suppressed.length > 0) {
                    this.suppressedColonies.push(roomName);
                    continue;
                }
            }
            this.colonyMap[roomName] = roomName;
        }
        const outpostFlagMap = _.groupBy(this.cache.outpostFlags, flag => flag.memory["C"]);
        const outpostMap = _.mapValues(outpostFlagMap, flag => _.map(flag, f => (f.memory.setPos || f.pos).roomName));
        for (const colonyName in outpostMap) {
            for (const outpostName of outpostMap[colonyName]) {
                this.colonyMap[outpostName] = colonyName;
            }
        }
        let id = 0;
        for (const colonyName in this.colonyMap) {
            if (this.colonyMap[colonyName] != colonyName)
                continue;
            if (USE_SCREEPS_PROFILER && !this.profilerRooms[colonyName]) {
                Game.time % 20 == 0 && log.alert('Suppressing instantiation of colony ' + colonyName + '.');
                continue;
            }
            this.try(() => this.colonies[colonyName] = new Colony(id, colonyName, outpostMap[colonyName]));
            id++;
        }
    }
    registerDirectives() {
        for (const flag in Game.flags) {
            if (this.directives[flag]) {
                continue;
            }
            const room = Game.flags[flag].memory["C"];
            if (room) {
                if (USE_SCREEPS_PROFILER && !this.profilerRooms[room]) {
                    continue;
                }
                const colony = Memory.colonies[room];
                if (colony && colony.suspend) {
                    continue;
                }
            }
            const directive = DirectiveWrapper(Game.flags[flag]);
            if (!directive && !SUPPRESS_INVALID_DIRECTIVE_ALERTS && Game.time % 10 == 0) {
                log.alert('Flag [' + flag + ' @ ' + Game.flags[flag].pos.print + '] does not match ' + 'a valid directive color code! (Refer to /src/directives/initializer.ts)' + alignedNewline + 'Use removeErrantFlags() to remove flags which do not match a directive.');
            }
        }
    }
    init() {
        this.try(() => RoomIntel.init());
        this.try(() => this.tradeNetwork.init());
        this.try(() => this.terminalNetwork.init());
        this.try(() => this.overseer.init(), 'overseer.init()');
        for (const colonyName in this.colonies) {
            const usedCPU = Game.cpu.getUsed();
            this.try(() => this.colonies[colonyName].init(), colonyName);
            Stats.log('cpu.usage.' + colonyName + '.init', Game.cpu.getUsed() - usedCPU);
        }
        for (const spawnGroupName in this.spawnGroups) {
            this.try(() => this.spawnGroups[spawnGroupName].init(), spawnGroupName);
        }
        this.try(() => this.expansionPlanner.init());
    }
    run() {
        for (const spawnGroupName in this.spawnGroups) {
            this.try(() => this.spawnGroups[spawnGroupName].run(), spawnGroupName);
        }
        this.try(() => this.overseer.run(), 'overseer.run()');
        for (const colonyName in this.colonies) {
            this.try(() => this.colonies[colonyName].run(), colonyName);
        }
        this.try(() => this.terminalNetwork.run());
        this.try(() => this.tradeNetwork.run());
        this.try(() => this.expansionPlanner.run());
        this.try(() => RoomIntel.run());
        if (Game.cpu.bucket == 10000 && Game.shard.name != "shard3" && Game.cpu.generatePixel) {
            Game.cpu.generatePixel();
            log.info("Generating Pixel...");
        }
    }
    postRun() {
        this.handleExceptions();
    }
    handleNotifications() {
        for (const colony of this.suspendedColonies) {
            this.overseer.notifier.alert('Colony suspended', colony, NotifierPriority.High);
        }
        for (const colony of this.suppressedColonies) {
            this.overseer.notifier.alert('Colony suppressed', colony, NotifierPriority.Low);
        }
    }
    visuals() {
        if (Game.cpu.bucket < 9000 && Game.shard.name == "shard3") {
            Game.time % 10 == 0 && log.info('CPU bucket is too low (' + Game.cpu.bucket + ') - skip rendering visuals.');
            return;
        }
        Visualizer.visuals();
        this.overseer.visuals();
        for (const c in this.colonies) {
            this.colonies[c].visuals();
        }
    }
};
_Overmind = __decorate([
    profile
], _Overmind);
var _Overmind$1 = _Overmind;
;

class VersionMigration {
    static run() {
        if (!this.memory.versions['05Xto051']) {
            this.migrate_050_051();
        }
        if (!this.memory.versions['05Xto051_part2']) {
            this.migrate_050_051_part2();
        }
        if (!this.memory.versions['05Xto051_part3']) {
            this.migrate_050_051_part3();
        }
        if (!this.memory.versions['05Xto051_part4']) {
            this.migrate_050_051_part4();
        }
        if (!this.memory.versions['051to052']) {
            this.migrate_051_052();
        }
        if (!this.memory.versions['052to053']) {
            this.migrate_052_053();
        }
        if (!this.memory.versions['053to06X_part1']) {
            this.migrate_053_06X_part1();
        }
        if (!this.memory.versions['053to06X_part2']) {
            this.migrate_053_06X_part2();
        }
        if (!this.memory.versions['053to06X_part3']) {
            this.migrate_053_06X_part3();
        }
        if (!this.memory.versions['053to06X_part4']) {
            this.migrate_053_06X_part4();
        }
        if (!this.memory.versions['053to06X_part5']) {
            this.migrate_053_06X_part5();
        }
        if (!this.memory.versions['060to07X_part1']) {
            this.migrate_060_07X_part1();
        }
    }
    static get memory() {
        return Mem.wrap(Memory.Overmind, 'versionMigrator', () => ({
            versions: {}
        }));
    }
    static migrate_050_051() {
        for (const id in Game.structures) {
            const s = Game.structures[id];
            if (s.structureType == STRUCTURE_LINK) {
                const isCommandCenterLink = s.pos.findInRange(_.compact([s.room.storage,
                    s.room.terminal]), 2).length > 0;
                const isHatcheryLink = s.pos.findInRange(s.room.spawns, 2).length > 0;
                if (!isCommandCenterLink && !isHatcheryLink) {
                    s.destroy();
                }
            }
        }
        let count = 0;
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == 'drone' &&
                creep.memory.overlord && creep.memory.overlord.includes('miningSite')) {
                creep.suicide();
                count++;
            }
        }
        this.memory.versions['05Xto051'] = true;
        log.alert(`Genocide complete: suicided ${count} innocent drones.`);
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 1) completed successfully.`);
    }
    static migrate_050_051_part2() {
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == 'reserver') {
                creep.memory.role = 'infestor';
            }
            else if (creep.memory.role == 'guard') {
                creep.memory.role = 'broodling';
            }
        }
        this.memory.versions['05Xto051_part2'] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 2) completed successfully.`);
    }
    static migrate_050_051_part3() {
        if (Memory.assimilator && Memory.assimilator.users) {
            delete Memory.assimilator.users;
        }
        this.memory.versions['05Xto051_part3'] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 3) completed successfully.`);
    }
    static migrate_050_051_part4() {
        const protectedKeywords = ['suspendUntil', 'amount', 'created', 'persistent', 'setPosition', 'rotation',
            'colony', 'parent', 'pathing', 'stats', 'safeTick', 'enhanced', 'persistent',
            'recoveryWaypoint', 'totalResources', 'maxPathLength', 'maxLinearRange'];
        for (const name in Memory.flags) {
            for (const prop in Memory.flags[name]) {
                if (!protectedKeywords.includes(prop)) {
                    delete Memory.flags[name][prop];
                }
            }
        }
        this.memory.versions['05Xto051_part4'] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 4) completed successfully.`);
    }
    static migrate_051_052() {
        if (__VERSION__ == '0.5.2') {
            for (const name in Game.creeps) {
                if (name.includes('mutalisk')) {
                    Game.creeps[name].suicide();
                }
            }
        }
        this.memory.versions['051to052'] = true;
        log.alert(`Version migration from 0.5.1 -> 0.5.2 completed successfully.`);
    }
    static migrate_052_053() {
        const newFlagKeys = {
            created: "T",
            expiration: "X",
            overlord: "O",
            colony: "C",
        };
        for (const name in Memory.flags) {
            Memory.flags[name] = _.mapKeys(Memory.flags[name], function (value, key) {
                return newFlagKeys[key] || key;
            });
            if (name.includes('harvest:')) {
                const pathing = Memory.flags[name].pathing;
                if (pathing) {
                    Memory.flags[name]['P'] = {
                        D: pathing.distance,
                        X: pathing.expiration,
                    };
                    delete Memory.flags[name].pathing;
                }
                Memory.flags[name]['u'] = Memory.flags[name].stats.usage;
                Memory.flags[name]['d'] = Memory.flags[name].stats.downtime;
                delete Memory.flags[name].stats;
            }
        }
        const newCreepKeys = {
            overlord: "O",
            colony: "C",
        };
        for (const name in Memory.creeps) {
            Memory.creeps[name] = _.mapKeys(Memory.creeps[name], function (value, key) {
                return newCreepKeys[key] || key;
            });
        }
        for (const name in Memory.colonies) {
            for (const key in Memory.colonies[name]) {
                if (key.includes('miningSite@')) {
                    delete Memory.colonies[name][key];
                }
            }
        }
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions['052to053'] = true;
        log.alert(`Version migration from 0.5.2 -> 0.5.3 completed successfully.`);
    }
    static migrate_053_06X_part1() {
        delete Memory.overseer.suspendUntil;
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions['053to06X_part1'] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 1 completed successfully.`);
    }
    static migrate_053_06X_part2() {
        if (Memory.Overmind.terminalNetwork) {
            delete Memory.Overmind.terminalNetwork;
        }
        for (const id in Game.market.orders) {
            Game.market.cancelOrder(id);
        }
        this.memory.versions['053to06X_part2'] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 2 completed successfully.`);
    }
    static migrate_053_06X_part3() {
        for (const colonyName in Memory.colonies) {
            if (Memory.colonies[colonyName].evolutionChamber) {
                delete Memory.colonies[colonyName].evolutionChamber.activeReaction;
                delete Memory.colonies[colonyName].evolutionChamber.reactionQueue;
                delete Memory.colonies[colonyName].evolutionChamber.status;
                delete Memory.colonies[colonyName].evolutionChamber.statusTick;
            }
        }
        this.memory.versions['053to06X_part3'] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 3 completed successfully.`);
    }
    static migrate_053_06X_part4() {
        for (const id in Game.market.orders) {
            const order = Game.market.orders[id];
            const deleteOrdersFor = [RESOURCE_GHODIUM, RESOURCE_ZYNTHIUM_KEANITE,
                RESOURCE_UTRIUM_LEMERGITE, RESOURCE_HYDROXIDE];
            if (deleteOrdersFor.includes(order.resourceType)) {
                Game.market.cancelOrder(id);
            }
        }
        this.memory.versions['053to06X_part4'] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 4 completed successfully.`);
    }
    static migrate_053_06X_part5() {
        log.alert(`Fetching approximate empire age...`);
        let oldestTick = Infinity;
        for (const name in Memory.colonies) {
            if (Memory.colonies[name] && Memory.colonies[name].roomPlanner) {
                const rpmem = Memory.colonies[name].roomPlanner;
                if (rpmem.lastGenerated && rpmem.lastGenerated < oldestTick) {
                    oldestTick = rpmem.lastGenerated;
                }
            }
        }
        for (const name in Memory.flags) {
            const fmem = Memory.flags[name];
            if (fmem.T && fmem.T < oldestTick) {
                oldestTick = fmem.T;
            }
        }
        if (oldestTick < Infinity) {
            Memory.tick = Game.time - oldestTick;
        }
        log.alert(`Cleaning memory...`);
        delete Memory.strategist;
        delete Memory.zoneRooms;
        Memory.roomIntel = {};
        if (Memory.stats.persistent && Memory.stats.persistent.terminalNetwork) {
            delete Memory.stats.persistent.terminalNetwork.transfers;
            delete Memory.stats.persistent.terminalNetwork.costs;
        }
        const mem = Memory;
        delete mem.pathing.paths;
        delete mem.pathing.weightedDistances;
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep) {
                delete creep.memory._go;
            }
        }
        function derefCoords(coordName) {
            const [x, y] = coordName.split(':');
            return { x: parseInt(x, 10), y: parseInt(y, 10) };
        }
        for (const name in Memory.colonies) {
            const colmem = Memory.colonies[name];
            delete colmem.abathur;
            delete colmem.expansionData;
            log.alert(`Migrating room planner memories...`);
            const validRoomPlannerMemKeys = ['active', 'relocating', 'recheckStructuresAt', 'bunkerData',
                'lastGenerated', 'mapsByLevel', 'savedFlags'];
            if (colmem.roomPlanner) {
                for (const key in colmem.roomPlanner) {
                    if (!validRoomPlannerMemKeys.includes(key)) {
                        delete colmem.roomPlanner[key];
                    }
                }
            }
            log.alert(`Migrating road planner memories...`);
            if (colmem.roadPlanner) {
                if (colmem.roadPlanner.roadLookup) {
                    const roadLookup = colmem.roadPlanner.roadLookup;
                    const roadCoordsPacked = {};
                    for (const roomName in roadLookup) {
                        const roadCoords = _.map(_.keys(roadLookup[roomName]), coordName => derefCoords(coordName));
                        roadCoordsPacked[roomName] = packCoordList(roadCoords);
                    }
                    colmem.roadPlanner.roadCoordsPacked = roadCoordsPacked;
                    delete colmem.roadPlanner.roadLookup;
                }
            }
            log.alert(`Migrating barrier planner memories...`);
            if (colmem.barrierPlanner) {
                if (colmem.barrierPlanner.barrierLookup) {
                    const barrierLookup = colmem.barrierPlanner.barrierLookup;
                    const barrierCoords = _.map(_.keys(barrierLookup), coordName => derefCoords(coordName));
                    colmem.barrierPlanner.barrierCoordsPacked = packCoordList(barrierCoords);
                    delete colmem.barrierPlanner.barrierLookup;
                }
            }
        }
        log.alert(`Clearing room memories...`);
        for (const roomName in Memory.rooms) {
            delete Memory.rooms[roomName];
        }
        this.memory.versions['053to06X_part5'] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 5 completed successfully.`);
    }
    static migrate_060_07X_part1() {
        delete Memory["assimilator"];
        delete Memory["segmenter"];
        delete Memory["remoteDebugger"];
        this.memory.versions['060to07X_part1'] = true;
        log.alert(`Version migration from 0.6.0 -> 0.7.X part 1 completed successfully.`);
    }
}

'use strict';
global.PHASE = 'build';
global.LATEST_BUILD_TICK = Game.time;
function main() {
    Error.stackTraceLimit = 20;
    Mem.load();
    if (!Mem.shouldRun())
        return;
    Mem.clean();
    if (!global.Overmind || Overmind.shouldBuild || Game.time >= Overmind.expiration) {
        PHASE = 'build';
        delete global.Overmind;
        Mem.garbageCollect(true);
        global.Overmind = new _Overmind$1();
        Overmind.build();
        LATEST_BUILD_TICK = Game.time;
    }
    else {
        PHASE = 'refresh';
        Overmind.refresh();
    }
    PHASE = 'init';
    Overmind.init();
    PHASE = 'run';
    Overmind.run();
    PHASE = 'postRun';
    Overmind.visuals();
    Stats.run();
    Memory.tick++;
    Overmind.postRun();
}
function onGlobalReset() {
    global.LATEST_GLOBAL_RESET_TICK = Game.time;
    global.LATEST_GLOBAL_RESET_DATE = new Date();
    if (USE_SCREEPS_PROFILER)
        screepsProfiler.enable();
    Mem.format();
    OvermindConsole.init();
    VersionMigration.run();
    Memory.stats.persistent.lastGlobalReset = Game.time;
    OvermindConsole.printUpdateMessage();
}
let _loop;
if (USE_SCREEPS_PROFILER) {
    _loop = () => screepsProfiler.wrap(main);
}
else {
    _loop = main;
}
const loop = _loop;
onGlobalReset();

exports.loop = loop;
